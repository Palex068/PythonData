# 5.3. Модель исключений Python. Try, except, else, finally. Модули

При выполнении заданий к главам вы скорее всего нередко сталкивались с возникновением различных ошибок. 

На этой главе мы изучим подход, который позволяет обрабатывать ошибки после их возникновения.

Напишем программу, которая будет считать обратные значения для целых чисел из заданного диапазона и выводить их в одну строку с разделителем ";". 

Один из вариантов кода для решения этой задачи выглядит так:

    print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))

Программа получилась в одну строчку за счёт использования списочных выражений. 

Однако при вводе диапазона чисел, включающем в себя 0 (например, от -1 до 1), программа выдаст следующую ошибку:

    ZeroDivisionError: division by zero

В программе произошла ошибка "деление на ноль". 

Такая ошибка, возникающая при выполнении программы и останавливающая её работу, называется исключением.

Попробуем в нашей программе избавиться от возникновения исключения деления на ноль. 

Пусть при попадании 0 в диапазон чисел, обработка не производится и выводится сообщение "Диапазон чисел содержит 0". 

Для этого нужно проверить до списочного выражения наличие нуля в диапазоне:

    interval = range(int(input()), int(input()) + 1)
    if 0 in interval:
        print("Диапазон чисел содержит 0.")
    else:
        print(";".join(str(1 / x) for x in interval))

Теперь для диапазона, включающего в себя 0, например, от -2 до 2, исключения ZeroDivisionError не возникнет. 

Однако при вводе строки, которую невозможно преобразовать в целое число (например, "a"), будет вызвано другое исключение:

    ValueError: invalid literal for int() with base 10: 'a'

Произошло исключение ValueError. 

Для борьбы с этой ошибкой нам придётся проверить, что строка состоит только из цифр. 

Сделать это нужно до преобразования в число. Тогда наша программа будет выглядеть так:

    start = input()
    end = input()
    # Метод lstrip("-"), удаляющий символы "-" в начале строки, нужен для учёта
    # отрицательных чисел, иначе isdigit() вернёт для них False
    if not (start.lstrip("-").isdigit() and end.lstrip("-").isdigit()):
        print("Необходимо ввести два числа.")
    else:
        interval = range(int(start), int(end) + 1)
        if 0 in interval:
            print("Диапазон чисел содержит 0.")
        else:
            print(";".join(str(1 / x) for x in interval))

Теперь наша программа работает без ошибок и при вводе строк, которые нельзя преобразовать в целое число.

Подход, который был нами применён для предотвращения ошибок, называется "Look Before You Leap" (LBYL), или "посмотри перед прыжком". В программе, реализующей такой подход, проверяются возможные условия возникновения ошибок до исполнения основного кода.

Подход LBYL имеет недостатки. Программу из примера стало сложнее читать из-за вложенного условного оператора. Проверка условия, что строка может быть преобразована в число, выглядит даже сложнее, чем списочное выражение. Вложенный условный оператор не решает поставленную задачу, а только лишь проверяет входные данные на корректность. Легко заметить, что решение основной задачи заняло меньше времени, чем составление условий проверки корректности входных данных.

Существует другой подход для работы с ошибками: "Easier to Ask Forgiveness than Permission" (EAFP) или "проще извиниться, чем спрашивать разрешение". В этом подходе сначала исполняется код, а в случае возникновения ошибок происходит их обработка. Подход EAFP реализован в Python в виде обработки исключений.

Исключения в Python являются классами ошибок. В Python есть много стандартных исключений. Они имеют определённую иерархию за счёт механизма наследования классов. В документации Python версии 3.10.8 приводится следующее дерево иерархии стандартных исключений:

    BaseException
    +-- SystemExit
    +-- KeyboardInterrupt
    +-- GeneratorExit
    +-- Exception
        +-- StopIteration
        +-- StopAsyncIteration
        +-- ArithmeticError
        |    +-- FloatingPointError
        |    +-- OverflowError
        |    +-- ZeroDivisionError
        +-- AssertionError
        +-- AttributeError
        +-- BufferError
        +-- EOFError
        +-- ImportError
        |    +-- ModuleNotFoundError
        +-- LookupError
        |    +-- IndexError
        |    +-- KeyError
        +-- MemoryError
        +-- NameError
        |    +-- UnboundLocalError
        +-- OSError
        |    +-- BlockingIOError
        |    +-- ChildProcessError
        |    +-- ConnectionError
        |    |    +-- BrokenPipeError
        |    |    +-- ConnectionAbortedError
        |    |    +-- ConnectionRefusedError
        |    |    +-- ConnectionResetError
        |    +-- FileExistsError
        |    +-- FileNotFoundError
        |    +-- InterruptedError
        |    +-- IsADirectoryError
        |    +-- NotADirectoryError
        |    +-- PermissionError
        |    +-- ProcessLookupError
        |    +-- TimeoutError
        +-- ReferenceError
        +-- RuntimeError
        |    +-- NotImplementedError
        |    +-- RecursionError
        +-- SyntaxError
        |    +-- IndentationError
        |         +-- TabError
        +-- SystemError
        +-- TypeError
        +-- ValueError
        |    +-- UnicodeError
        |         +-- UnicodeDecodeError
        |         +-- UnicodeEncodeError
        |         +-- UnicodeTranslateError
        +-- Warning
            +-- DeprecationWarning
            +-- PendingDeprecationWarning
            +-- RuntimeWarning
            +-- SyntaxWarning
            +-- UserWarning
            +-- FutureWarning
            +-- ImportWarning
            +-- UnicodeWarning
            +-- BytesWarning
            +-- EncodingWarning
            +-- ResourceWarning

Для обработки исключения в Python используется следующий синтаксис:

    try:
        <код , который может вызвать исключения при выполнении>
    except <классисключения_1>:
        <код обработки исключения>
    except <классисключения_2>:
        <код обработки исключения>
    ...
    else:
        <код выполняется, если не вызвано исключение в блоке try>
    finally:
        <код , который выполняется всегда>

Блок try содержит код, в котором нужно обработать исключения, если они возникнут. 

При возникновении исключения интерпретатор последовательно проверяет в каком из блоков except обрабатывается это исключение. 

Исключение обрабатывается в первом блоке except, обрабатывающем класс этого исключения или базовый класс возникшего исключения. 

Необходимо учитывать иерархию исключений для определения порядка их обработки в блоках except. 

Начинать обработку исключений следует с более узких классов исключений. 

Если начать с более широкого класса исключения, например, Exception, то всегда при возникновении исключения будет срабатывать первый блок except. 

Сравните два следующих примера. 

В первом порядок обработки исключений указан от производных классов к базовым, а во втором – наоборот.

    try:
        print(1 / int(input()))
    except ZeroDivisionError:
        print("Ошибка деления на ноль.")
    except ValueError:
        print("Невозможно преобразовать строку в число.")
    except Exception:
        print("Неизвестная ошибка.")

При вводе значений "0" и "a" получим ожидаемый соответствующий возникающим исключениям вывод:

    Невозможно преобразовать строку в число.
и

    Ошибка деления на ноль.

Второй пример:

    try:
        print(1 / int(input()))
    except Exception:
        print("Неизвестная ошибка.")
    except ZeroDivisionError:
        print("Ошибка деления на ноль.")
    except ValueError:
        print("Невозможно преобразовать строку в число.")

При вводе значений "0" и "a" получим в обоих случаях неинформативный вывод:

    Неизвестная ошибка.

Необязательный блок else выполняет код в случае, если в блоке try не вызвано исключение. Добавим блок else в пример для вывода сообщения об успешном выполнении операции:

    try:
        print(1 / int(input()))
    except ZeroDivisionError:
        print("Ошибка деления на ноль.")
    except ValueError:
        print("Невозможно преобразовать строку в число.")
    except Exception:
        print("Неизвестная ошибка.")
    else:
        print("Операция выполнена успешно.")

Теперь при вводе корректного значения, например, "5", вывод программы будет следующим:

    2.0
    Операция выполнена успешно.

Блок finally выполняется всегда, даже если возникло какое-то исключение, не учтённое в блоках except или код в этих блоках сам вызвал какое-либо исключение. Добавим в нашу программу вывод строки "Программа завершена" в конце программы даже при возникновении исключений:

    try:
        print(1 / int(input()))
    except ZeroDivisionError:
        print("Ошибка деления на ноль.")
    except ValueError:
        print("Невозможно преобразовать строку в число.")
    except Exception:
        print("Неизвестная ошибка.")
    else:
        print("Операция выполнена успешно.")
    finally:
        print("Программа завершена.")

Перепишем код, созданный с применением подхода LBYL, для первого примера из этой главы с использованием обработки исключений:

    try:
        print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
    except ZeroDivisionError:
        print("Диапазон чисел содержит 0.")
    except ValueError:
        print("Необходимо ввести два числа.")

Теперь наша программа читается намного легче. При этом создание кода для обработки исключений не заняло много времени и не потребовало проверки сложных условий.

Исключения можно принудительно вызывать с помощью оператора raise. Этот оператор имеет следующий синтаксис:

    raise <класс исключения>(параметры)

В качестве параметра можно, например, передать строку с сообщением об ошибке.

В Python можно создавать свои собственные исключения. 

Синтаксис создания исключения такой же, как и у создания класса. 

При создании исключения его необходимо наследовать от какого-либо стандартного класса-исключения.

Напишем программу, которая выводит сумму списка целых чисел, и вызывает исключение, если в списке чисел есть хотя бы одно чётное или отрицательное число. Создадим свои классы исключений:

+ NumbersError – базовый класс исключения;
+ EvenError – исключение, которое вызывается при наличии хотя бы одного чётного числа;
+ NegativeError – исключение, которое вызывается при наличии хотя бы одного отрицательного числа.
##
    class NumbersError(Exception):
        pass


    class EvenError(NumbersError):
        pass


    class NegativeError(NumbersError):
        pass


    def no_even(numbers):
        if all(x % 2 != 0 for x in numbers):
            return True
        raise EvenError("В списке не должно быть чётных чисел")


    def no_negative(numbers):
        if all(x >= 0 for x in numbers):
            return True
        raise NegativeError("В списке не должно быть отрицательных чисел")


    def main():
        print("Введите числа в одну строку через пробел:")
        try:
            numbers = [int(x) for x in input().split()]
            if no_negative(numbers) and no_even(numbers):
                print(f"Сумма чисел равна: {sum(numbers)}.")
        except NumbersError as e:  # обращение к исключению как к объекту
            print(f"Произошла ошибка: {e}.")
        except Exception as e:
            print(f"Произошла непредвиденная ошибка: {e}.")

            
    if __name__ == "__main__":
        main()

Обратите внимание: в программе основной код выделен в функцию main. А код вне функций содержит только условный оператор и вызов функции main при выполнении условия \_\_name__ == "\_\_main__". 

Это условие проверяет, запущен ли файл как самостоятельная программа или импортирован как модуль.

Любая программа, написанная на языке программирования Python может быть импортирована как модуль в другую программу. 

В идеологии Python импортировать модуль – значит полностью его выполнить. 

Если основной код модуля содержит вызовы функций, ввод или вывод данных без использования указанного условия \_\_name__ == "\_\_main__", то произойдёт полноценный запуск программы. 

А это не всегда удобно, если из модуля нужна только отдельная функция или какой-либо класс.

При изучении модуля itertools, мы говорили о том, как импортировать модуль в программу. 

Покажем ещё раз два способа импорта на примере собственного модуля.

Для импорта модуля из файла, например example_module.py, нужно указать его имя, если он находится в той же папке, что и импортирующая его программа:

    import example_module

Если требуется отдельный компонент модуля, например функция или класс, то импорт можно осуществить так:

    from example_module import some_function, ExampleClass

Обратите внимание: при втором способе импортированные объекты попадают в пространство имён новой программы. Это означает, что они будут объектами новой программы, и в программе не должно быть других объектов с такими же именами.
    