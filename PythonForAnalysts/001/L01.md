# Продолжение знакомства с jupyter notebook Лекция 1.

На этой лекции мы узнаем:

+ Узнать, как работать с jupyter notebook эффективней
+ Научиться красиво и доступно оформлять jupyter notebook
+ Посмотреть на функционал модуля Random
+ Более детально изучить словари, функции в Python
+ Разобраться с генераторами
+ Познакомиться с list, set, dict comprehensions 

## План лекции 1
1. [Термины лекции](#термины-лекции)
2. [Введение](#введение)
3. [Jupyter notebook](#jupyter-notebook)
    + [Сочетания клавиш в режиме редактирования](#сочетания-клавиш-в-режиме-редактирования)
    + [Сочетания клавиш в режиме ввода команд](#сочетания-клавиш-в-режиме-ввода-команд)
4. [Markdown](#markdown)
    + [Теги HTML](#теги-html)
5.	[Словари](#словари)
6.	[Модуль Random](#модуль-random)
7.	[Функции](#функции)
    + [Аргументы по позиции и по имени](#аргументы-по-позиции-и-по-имени)
    + [Аргументы по умолчанию](#аргументы-по-умолчанию)
    + [Аргумент *args](#аргумент-args)
    + [Аргумент *kwargs](#аргумент-kwargs)
    + [Аннотирование типов](#аннотирование-типов)
8.	[Генератор](#генератор)
9.	[Comprehensions](#comprehensions)
    + [List comprehensions](#list-comprehensions)
    + [Использование условий](#использование-условий)
    + [Set и dict comprehensions](#set-и-dict-comprehensions)
10. [Рекомендуемая дополнительная литература или материалы](#рекомендуемая-дополнительная-литература-или-материалы)
11. [Используемая литература или материалы](#используемая-литература-или-материалы)
12. [Дополнительные материалы *args, *kwargs](/PythonForAnalysts/L01_args_kwargs.ipynb)
13. [Доп материалы](/PythonForAnalysts/001/S01_dop.ipynb)
14. [Решение задач v1](/PythonForAnalysts/001/S01.ipynb)
15. [Решение задач v2](/PythonForAnalysts/001/S01v2.ipynb)
16. [Домашняя работа](/PythonForAnalysts/001/HW01.ipynb)

[План курса](/PythonForAnalysts/README.MD)

## Термины лекции 
__Markdown__ - облегчённый язык разметки, созданный с целью обозначения форматирования в простом тексте, с максимальным сохранением его читаемости человеком, и пригодный для машинного преобразования в языки для продвинутых публикаций. 

__Тэг HTML__ - элемент языка разметки. Текст, содержащийся между начальным и конечным тегом, отображается и размещается в соответствии со свойствами, указанными в начальном теге. 

__Словарь__ - неупорядоченная структура данных, которая позволяет хранить пары «ключ — значение». 

__Вложенный словарь__ – это словарь, содержащий другие словари.

__Аргумент функции__ — значение, которое передается в функцию при её вызове.

__Позиционный аргумент__ - это аргумент, передаваемый в функцию в определенной последовательности (на определенных позициях), без указания их имен.

__Именованный аргумент__ - это аргумент, передаваемые в функцию при помощи имени. 

__Генератор__ - это объект, который сразу при создании не вычисляет значения всех своих элементов. 

[План лекции](#план-лекции-1)

<hr>

## Введение
Всем привет!

![Введение](/PythonForAnalysts/Pictures/001_086.PNG)

Меня зовут Юля Пономарева, я инженер машинного обучения, работаю чаще с задачами в области компьютерного зрения - это всё, что связано с распознаванием визуальных образов на картинках или видео потоках. <br>
Получается, что я дарую зрение машинам. 

Но еще очень часто приходят задачи из области аналитики, где есть большой массив данных, который нужно проанализировать, построить графики, которые наглядно показывают проблему и предложить решение. 

Из наиболее запомнившихся проектов:
1. Прогнозирование выручки в новой торговой точке по местоположению
2. Прогнозирование стоимости недвижимости по характеристикам квартиры
3. Веду канал на youtube [machine learrrning](https://www.youtube.com/c/machinelearrrning)


А также рассказываю про машинное обучение и инструменты для аналитиков на [youtube](https://www.youtube.com/c/machinelearrrning) канале. 

## Продолжение знакомства с jupyter notebook

Сегодня будем дальше погружаться в jupyter notebook, узнаем, как эффективно работать с этим инструментом, рассмотрим более детальную работу со структурой данных словарь, обсудим аргументы в функциях и познакомимся с генераторами на Python.  

[План лекции](#план-лекции-1)

<hr>

## Jupyter notebook

И начнем с работы в интерактивной среде разработки. В наших ноутбуках есть два вида ячеек. Ниже график показывает два типа ячеек.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_001.png)

К примеру, для проведения анализа набора данных по успешности рекламной кампании стоит пользоваться jupyter notebook, ведь мы можем писать код, а можем писать текст, что очень удобно для записей интерпретаций графиков - визуализировали данные и сразу же их проинтерпретировали в текстовой ячейке ниже. 

У нас есть возможность вести разработку и параллельно комментировать наши действия.

Также в ноутбуках есть два режима: режим ввода команд и режим редактирования. <br>
Обратите внимание, чем они отличаются:
+ Режим ввода команд имеет выделенную синюю область, а
+ режим редактирования имеет зеленую обводку.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_002.png)

В режиме ввода команд мы можем перемещаться по ячейкам, удалять их, добавлять новые, останавливать их работу. А во втором режиме можем редактировать содержимое ячейки.

## Сочетания клавиш в режиме редактирования

![Сочетания клавиш в режиме редактирования](/PythonForAnalysts/Pictures/001_087.PNG)

А теперь пройдемся по горячим сочетаниям клавиш. 

__Горячие сочетание клавиш__ (шорткат [англ. shortcut]) — это нажатие кнопки/клавиши (или сочетания клавиш) на клавиатуре, которому назначено некое действие — команды, исполняемые данной системой. 

Примером шортката является знакомое и любимое __Ctrl + C__ для копирования текста и __Ctrl + V__ для вставки скопированного. 

И начнем свое обсуждение с режима ввода редактирования __(edit mode)__, чтобы в нем оказаться нужно нажать на __Enter__, тогда вы сможете перемещаться в рамках одной ячейки и писать код или текст.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_003.png)

Из стандартных команд по работе с текстом - это:
1.	__Ctrl+A__ - выделить всё
2.	__Ctrl+Home__ - подняться на начало ячейки
3.	__Ctrl+End__ - опуститься на конец ячейки
4.	__Ctrl+Left__ - перемещаться на одно слово влево
5.	__Ctrl+Right__ - перемещаться на одно слово вправо

Если вы пишите код и хотите сэкономить свое время, то можете пользоваться автодополнением, нажатием на __Tab__, тогда у вас высветятся подсказки.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_004.png)

А если вдруг забыли, в каком порядке идут аргументы в функции, то для того, чтобы вспомнить можно нажать на __Shift+Tab__ и выскакивает небольшая документация, посвященная этой функции.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_005.png)

Или же подобную документацию можно получить, если перед функцией написать знак вопроса __(?)__:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_006.png)

И еще несколько приятных сочетаний клавиш:
1.	__Ctrl+Z__ - откатить только что сделанное действие
2.	__Ctrl+/__ - закомментировать или раскомментировать
3.	__Ctrl+D__ - удалить целую строку

## Сочетания клавиш в режиме ввода команд

![Сочетания клавиш в режиме редактирования](/PythonForAnalysts/Pictures/001_088.PNG)

С режимом редактирования разобрались, а теперь движемся к режиму команд __(command mode)__, чтобы в нём очутиться нужно нажать на __Escape__, тогда вы сможете перемещаться по ячейкам вверх и вниз с помощью клавиш “стрелка вверх” и “стрелка вниз”.

1.	__А__ - создать новую ячейку сверху
2.	__B__ - создать ячейка снизу текущей
3.	__X__ - вырезать ячейку
4.	__C__ - копировать ячейку
5.	__V__ - вставить ячейку

Из интересного еще есть клавиша __F__, которая находит нужный набор символов и меняет на другое.

Для этого во-первых, нужно находится в выбранной ячейке, во-вторых нужно находиться в режиме ввода команд, чтобы была синяя обводка у рамки, ну а в-третьих, нужно нажать на __F__.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_007.png)

Движемся дальше и обсудим, как поменять тип ячейки:
1.	если хочется из ячейки сделать код, то можно нажать на __Y__
2.	а если хочется наоборот поменять на текст, то нажимайте на __M__.

Если вы где-то в коде поймали ошибку, но вам лень считать, в какой строке это произошло, то можно нажать на __L__ и тогда юпитер покажет нумерацию строк. Если вам надоест смотреть на эти цифры можно нажать снова на __L__.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_008.png)

На __H__ можно посмотреть на сочетания клавиш, некоторые из которых мы с вами уже посмотрели.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_009.png)

Если у вас ячейка долго выполняется, а у вас нет столько времени, то можно прекратить её выполнение, нажав на __I, I__.

И чтобы перезапустить весь ноутбук можно нажать на __0,0__, но будьте аккуратней, ведь так все ваши переменные сотрутся и всё начнется с чистого листа. 

Если к этому готовы, то нажимайте на рестарт. 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_010.png)

[План лекции](#план-лекции-1)

<hr>

## Markdown

![Введение](/PythonForAnalysts/Pictures/001_089.PNG)

__Markdown__ - облегчённый язык разметки, созданный с целью обозначения форматирования в простом тексте, с максимальным сохранением его читаемости человеком, и пригодный для машинного преобразования в языки для продвинутых публикаций. 

Этот язык разметки нужен для того, чтобы создавать красиво оформленные тексты. Вам не нужно использовать Microsoft Word или подобные программы, чтобы создавать документы с жирным или курсивным начертанием, цитатами, ссылками и таблицами.

Плавно переходим к ячейке с текстом и обсудим, как можно её красиво оформить. Можно из ячейки с текстом делать заголовок, путем нажатия на цифры от $1$ до $6$.

$1$ - это самый большой заголовок, а $6$ - это самый маленький заголовок.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_011.png)

При этом можно менять заголовок через решетку (#), принцип здесь такой же, $1$ решетка - самый большой заголовок, а $6$ решеток - самый маленький.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_012.png)

Для оформления и выделения мы используем символы, которые должны располагаться перед и после фразы или слова, которое нужно оформить.

-	** или __ - выделение текста жирным
-	\* или _ - выделение текста курсивом
-	\- - добавление списка в текст
-	можно писать формулы на языке [LaTex](/Articles/_Latex/README.MD)
-	плюс можно пользоваться тегами из языка разметки __html__, чтобы добавлять изображения, ссылки, таблицы и многое другое

![Введение](/PythonForAnalysts/Pictures/001_090.PNG)

### Теги HTML
	
Тэг __HTML__ - элемент языка разметки. 

Текст, содержащийся между начальным и конечным тегом, отображается и размещается в соответствии со свойствами, указанными в начальном теге. 

Теги нужны для того, чтобы при отображении язык разметки понимал, что имеет дело не с простым текстом, а с элементом форматирования. И нужно применить какое-то действие. <br>
К примеру, любой сайт, на который вы можете перейти, содержит огромное количество тегов. Без них не было бы такого красивого форматирования страниц с текстами разных начертаний, шрифтов, с таблицами, картинками и гиперссылками.

Рассмотрим пару самых полезных тегов.

1. img, сюда в src можно передать адрес любой картинки с интернета

![Jupyter notebook](/PythonForAnalysts/Pictures/001_013.png)

2. \<b> оформляем наш текст в этот тег, чтобы он стал жирным

![Jupyter notebook](/PythonForAnalysts/Pictures/001_014.png)

3.	\<i> окружаем текст этим тегом, чтобы он был написан курсивом 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_015.png)

<i>курсив</i>

4.	\<br> чтобы текст писался с новой строки

![Jupyter notebook](/PythonForAnalysts/Pictures/001_016.png)

![Jupyter notebook](/PythonForAnalysts/Pictures/001_017.png)

5.	и давайте обсудим \<table>, с помощью него можно создавать таблицы

![Jupyter notebook](/PythonForAnalysts/Pictures/001_018.png)

Сначала пишем тег \<table> и \</table>, чтобы указать границы таблицы, затем, чтобы создать строку пишем \<tr>, а чтобы написать значение в столбце, пишем тег \<td>.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_019.png)

Для более комфортной и эффективной работы в интерактивной среде разработки jupyter notebook есть горячие сочетания клавиш, которые мы рассмотрели. 

А чтобы в ноутбуке было все читаемо и доступно мы познакомились с markdown, который позволяет писать форматируемый текст для комментирования кода и фиксирования своих мыслей, выводов и идей. 

[План лекции](#план-лекции-1)

<hr>

## Словари

Отлично, с ноутбуком и markdown’ом разобрались, дальше движемся к расширению наших знаний по структуре данных __dict__ и будем с ним работать в юпитер ноутбуке.

![Введение](/PythonForAnalysts/Pictures/001_091.PNG)

__Словарь__ - неупорядоченная структура данных, которая позволяет хранить пары «ключ — значение». 

Данный словарь использует строки в качестве ключей, однако ключом может являться в принципе любой неизменяемый тип данных. Значением же конкретного ключа может быть что угодно.

Чтобы вспомнить про эту структуру данных и узнать новые подходы для работы с ней, возьмем данные про John Doe, которые лежат в словаре. 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_020.png)

Чтобы достать нужный объект по ключу, к примеру __‘name’__, нужно после имени словаря указать квадратные скобки и в них передать имя желаемого ключа.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_021.png)

Или можем получить все ключи, для этого вызываем метод __keys()__, возвращается список из ключей.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_022.png)

По аналогии со ключами словаря, для получения всех значений можем вызвать метод __values()__.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_023.png)

А  если хочется получить и ключи, и значения сразу, то тут используем __items()__, возвращается кортеж, где в первом элементе будет стоять ключ, а во втором элементе - значение.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_024.png)

Вот по этой структуре данных можно итерироваться, получая сразу ключи и значения за одну итерацию.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_025.png)

Так же можем добавить новые сведения про John Doe в наши данные. Хотим добавить информацию о росте, для этого пишем новый ключ __‘height’__ и через знак равно значение роста.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_026.png)

При этом если такой ключ уже был, то мы его перезапишем на новое значение, даже если мы этого не хотели.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_027.png)

К примеру, у нас уже записан возраст John’а, он у нас $32$-летний, а мы вдруг ошибочно хотим снова записать ключ __‘age’__. И всё перезаписывается.<br>
Это поведение кода для нас может быть неприемлемым. 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_029.png)

Если боитесь перезаписать существующие ключи, то можете пользоваться методом __setdefault()__, тогда Python сначала посмотрит, а есть ли такой ключ в словаре и если он есть, то вернет его значение, а если такого ключа нет, то запишется на то, которое указано в методе. <br>
Видим, что у нас ничего не поменялось в ключе возраста, как там был возраст $32$, так он и остался:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_030.png)

Есть еще один интересный способ, как можно менять значения в словаре, через метод __update()__. 

Метод __update()__ обновляет словарь элементами из другого объекта словаря или из итерируемых пар ключ-значение. 

Функция добавляет элемент(ы) в словарь, если ключ отсутствует в словаре. Если ключ находится в словаре, он обновляет ключ новым значением. 

Попытаемся поменять возраст John на 14 через метод update() и видим, что здесь нет проверки: а есть ли уже такой ключ, как было в setdefault(), здесь просто происходит перезапись:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_031.png)

И перезаписывает он не только существующие ключи, но и записывает новые, при этом здесь записывается вложенный словарь в ключ __‘body’__. 

![Введение](/PythonForAnalysts/Pictures/001_092.PNG)

Вложенный словарь – это словарь, содержащий другие словари.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_032.png)

Получить элемент из вложенного словаря можно через обращение к первому ключу __‘body’__, где получим словарь:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_033.png)

А затем обращаемся к ключу __‘height’__, чтобы получить рост из словаря:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_034.png)

[План лекции](#план-лекции-1)

<hr>

## Модуль Random

![Введение](/PythonForAnalysts/Pictures/001_093.PNG)

Модуль random предоставляет функции для генерации случайных чисел или к примеру, для случайного выбора элементов последовательности. Посмотрим на самые полезные функции.

При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из множества значение, к примеру, чтобы только на этом объекте показать проведенную работу аналитика, а не чтобы выводить весь массив данных.

# random.randint(A, B) 
возвращает случайное целое число из диапазона $A$ до $B$.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_035.png)

При этом значение на выходе всегда будет разное, если будем перезапускать данную ячейку, а чтобы значение случайности всегда было одинаковое можем зафиксировать 

# random.seed(n)

И теперь сколько бы мы раз не перезапускали эту ячейку, генерация всегда будет одинаковая:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_036.png)

# random.random()
возвращает случайное число от $0$ до $1$:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_037.png)

# random.uniform(A, B)
возвращает случайное число с плавающей точкой в диапазоне от $A$ до $B$.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_038.png)

# random.sample(data, k)
возвращает список длиной k из последовательности data.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_039.png)

# random.shuffle(data) 
перемешивает последовательность, при этом изменяется сама последовательность, ничего не возвращается.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_040.png)

# random.choice(data)
возвращает случайный элемент из последовательности.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_041.png)

[План лекции](#план-лекции-1)

<hr>

## Функции

Функция в python - объект, который принимает аргументы, производит с ними желаемые действия и возвращает значение. 

Также функция — это фрагмент программного кода, который решает какую-либо задачу. <br>
Его можно вызывать в любом месте основной программы. <br>
Функции помогают избегать дублирования кода при многократном его использовании. 

__Аргумент функции__ — значение, которое передается в функцию при её вызове.

## Аргументы по позиции и по имени 

Аргументы бывают:
1.	Позиционными<br>
__Позиционный аргумент__ - это аргумент, передаваемый в функцию в определенной последовательности (на определенных позициях), без указания их имен
2.	Именованными<br>
__Именованный аргумент__ - это аргумент, передаваемые в функцию при помощи имени. 

В функцию подсчета суммы передаем два аргумента по позиции:  

![Jupyter notebook](/PythonForAnalysts/Pictures/001_042.png)

Можно передать их по имени, первый аргумент называется a, второй называется b:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_043.png)

Если мы сначала попытаемся передать аргумент b, а затем аргумент a по порядку, то ничего не получится, ведь по порядку сначала надо принять a, а только потом b.

Но передать их по именам можно:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_044.png)

А вот если сначала указать b по имени, а аргумент a по порядку, то будет ошибка, что позиционный аргумент идет после аргумента по имени, так делать в Python нельзя:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_045.png)

Зато можно сначала указать по порядку аргументы, а затем по имени и никаких ошибок:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_046.png)

Так что стратегия такая: сначала все порядковые аргументы, а затем все именованные.

![Введение](/PythonForAnalysts/Pictures/001_094.PNG)

## Аргументы по умолчанию

В функцию можно передавать аргументы по умолчанию, это те аргументы, значения которых будут использованы, если не передали им явное значение при вызове.

Такую функцию можно вызвать без аргументов и всё отработает без ошибок, ведь два аргумента имеют значения, хотя мы их не указывали при вызове: 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_047.png)

А вот если не указать обычный рядовой аргумент, то будет ошибка, что функция ожидает обязательный позиционный аргумент, но он не пришел на вход:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_048.png)

Менять аргументы по умолчанию, конечно же, можно:  

![Jupyter notebook](/PythonForAnalysts/Pictures/001_049.png)

# Аргумент *args

![Введение](/PythonForAnalysts/Pictures/001_095.PNG)

*args — это сокращение от «arguments» (аргументы).

Оператор \* чаще всего ассоциируется у людей с операцией умножения, но в Python он имеет и другой смысл. 

Этот оператор позволяет «распаковывать» объекты, внутри которых хранятся некие элементы.

Дело в том, что «args» — это всего лишь набор символов, которым принято обозначать аргументы. 

Самое главное тут — это оператор \*.<br> 
А то, что именно идёт после него, особой роли не играет. 

Благодаря использованию \* мы создали список позиционных аргументов на основе того, что было передано функции при вызове.

Давайте вернемся к функции суммирования двух элементов, а что если элементов будет не два, а три? Нужно будет переписывать функцию.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_050.png)

А если аргументов будет не три, а пять, снова изменять функцию.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_051.png)

Чтобы не менять постоянно реализацию функции можно воспользоваться аргументом *args, он помогает, когда в вашу функцию может поступать разное количество входных значений.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_052.png)

И такая реализация будет работать с разным количеством параметров, хоть с одним, хоть с тремя и так далее:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_053.png)

Аргумент *args из себя представляет кортеж, который может быть любой длины, по которому можно итерироваться при желание, или же можно доставать объекты, или же можно просуммировать:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_054.png)

Так же в args можно передавать элементы разных типов данных:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_055.png)

Но аккуратней с списками, потому что список - это один элемент:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_056.png)

Чтобы каждый элемент списка, считался самостоятельным аргументом нужно его распаковать, используя символ звездочки: 

![Jupyter notebook](/PythonForAnalysts/Pictures/001_057.png)

## Аргумент **kwargs

![Введение](/PythonForAnalysts/Pictures/001_096.PNG)

**kwargs — сокращение от «keyword arguments» (именованные аргументы).

Главное — это два символа **. <br>

Благодаря им создается словарь, в котором содержатся именованные аргументы, переданные функции при ее вызове.

Еще один интересный атрибут, у которого похожая логика на args, только здесь атрибуты будут именованными. 

Аргумент *kwargs из себя представляет словарь, который может содержать любое количество элементов

![Jupyter notebook](/PythonForAnalysts/Pictures/001_058.png)

К этим ключам при необходимости можно обращаться, а какие-то ключи могут быть проигнорированы:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_059.png)

Так же в функцию с атрибутом **kwargs можно передавать словарь, но его тоже нужно распаковать, используя две звездочки:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_060.png)

## Аннотирование типов

Когда работаете с Python функциями, то возникает неочевидная проблема. 

Порой забываешь, а какого типа должны быть входные параметры и чего вообще ждать на выходе. <br>
Здесь может помочь аннотирование типов. 

Можно через двоеточие указывать, какой тип ждет функция для каждого аргумента. 

А для вывода через -> можно указать ожидаемый тип на выходе функции:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_061.png)

Функция ждет int - целые числа, передаем их в функцию, всё работает и на выходе получаем int:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_062.png)

Но если передадим в эту функцию float значения, то снова всё работает, а на выходе тоже float:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_063.png)

Еще забавней, когда строки можно передать в функцию для подсчета суммы и всё равно не поймаем ошибку:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_064.png)

А всё это связано с тем, что аннотирование типов нужно только для разработчика, чтобы он сам не запутался в своем коде, Python никак не согласуется с этими аннотациями. 

Конечно IDE может подсвечивать данный кусок кода и мягко ругаться, но не более, ошибок здесь не будет.

[План лекции](#план-лекции-1)

<hr>

## Генератор

![Введение](/PythonForAnalysts/Pictures/001_097.PNG)

Допустим, у вас есть файл, который весит десяток гигабайт.<br>
Из него нужно выбрать и обработать строки, подходящие под какое-то условие. 

Что в такой ситуации делать? <br>
А можно обрабатывать такие объемы данных небольшими порциями, чтобы не вызывать переполнения памяти. 
В Python на этот случай есть специальный инструмент — генераторы.

Генератор - это объект, который сразу при создании не вычисляет значения всех своих элементов. 

Генератор хранит в памяти:
1.	последний вычисленный элемент
2.	правило перехода к следующему
3.	условие, при котором выполнение прерывается

Вычисление следующего значения происходит лишь при выполнении метода __next()__. 

Предыдущее значение при этом теряется.

Этим генераторы отличаются от списков, ведь списки хранят в памяти все свои элементы, и удалить их можно только программно. Вычисления с помощью генераторов экономят память.

Чтобы создать генератор, необходимо определить функцию, как обычно, но использовать __yield__ вместо __return__:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_065.png)

Оператор __yield__ приостанавливает функцию и сохраняет локальное состояние, чтобы его можно было возобновить с того места, где оно было остановлено.

Вызов функции не выполняет ее, а функция только возвращает объект-генератор:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_066.png)

При первом вызове __next()__ выполнение начинается с начала функции и продолжается до оператора __yield__, где возвращается значение справа от оператора:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_067.png)

Последующие вызовы __next()__ продолжаются с оператора __yield__ до конца функции, затем новый обход, который идет в начало функции и выполняется снова до оператора __yeild__:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_068.png)

Потом еще раз тоже самое, но если __yield__ больше не вызывается (в нашем случае означает, что условие __while__ не выполняется, потому что __current >= 0__), возникает исключение __StopIteration__:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_069.png)

По генератору можем итерироваться через цикл __for__. <br>

К примеру, создадим объект генератора, который реализовали выше и запишем в переменную __gen_a__. <br>
Теперь по нему можем пройтись в цикле, используя __for__, печатая каждый элемент на экран:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_070.png)

А если захотим еще раз пройтись по этой же переменной, то ничего не вернется, это снова подтверждение тому, что генератор хранит только один элемент за раз, а не весь массив данных, как это делает список:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_071.png)

Работа с потоками данных и большими файлами, такими например как CSV, являются наиболее распространенными вариантами использования генераторов. 

Предположим, что хотите посчитать количество имеющихся в нем рядов:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_072.png)

Можно предположить что csv_gen - список. <br>
А чтобы его заполнить, csv_reader() открывает файл и загружает его содержимое в csv_gen.<br>
 Затем итерируемся по списку, увеличивая значение row_count для каждого нового ряда.

![Jupyter notebook](/PythonForAnalysts/Pictures/001_073.png)

Всё кажется довольно логичным, но что, если файл будет слишком большим и не будет помещаться в память? В этом случае при выполнении кода выпадет ошибка по памяти:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_074.png)

Можем переписать функцию csv_reader через генератор. <br>
В этой версии открываем файл, проходим его по строкам и извлекает для чтения только отдельный ряд, вместо того, чтобы возвращать весь файл целиком:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_075.png)

Генераторы позволяют запрашивать значения по мере необходимости, делая наш код более эффективным в использовании памяти.

[План лекции](#план-лекции-1)

<hr>

## Comprehensions

## List comprehensions

Давайте вспомним про цикл for, если мы пользуемся им, чтобы из одного списка сделать новый список, то следуем этим пунктам:
1.	Создаем пустой список
2.	Итерируемся по объекту (или range)
3.	Добавляем каждый элемент в список

![Jupyter notebook](/PythonForAnalysts/Pictures/001_076.png)

Или же можем пользоваться List comprehensions - это чудесный способ составления списков. Можем переписать цикл for всего в одну строку кода:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_077.png)

Вместо того, чтобы создавать пустой список и добавлять каждый элемент в конец, мы просто определяем список и его содержимое одновременно, следуя этому формату:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_078.png)

где
-	__expression__ <br>
какое-то вычисление, вызов функции или любое другое допустимое выражение, которое возвращает значение.
-	__member__ <br>
объект или значение в списке или итерируемым объекте.
-	__iterable__ <br>
объект, по которому можно итерироваться (список, множество, последовательность, генератор)

## Использование условий

Условные выражения позволяют отфильтровывать нежелательные значения. Снова сначала рассмотрим реализацию через цикл:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_079.png)

А теперь с помощью list comprehension:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_080.png)

Гораздо более наглядно.

При этом условия могут быть сложнее, можем возвращать объект из итерируемого объекта или же заменять его на что-то, используя конструкцию if else:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_081.png)

Если условие хочется вынести отдельно, то можно реализовать дополнительную функцию для этого:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_082.png)

## Set и dict comprehensions

Помимо list comprehension в Python еще возможно создавать множественные и словарные представления (set comprehensions и dictionary comprehensions).

set comprehension почти точно такое же, как и list comprehensions. <br>
Разница лишь в том, что заданные значения обеспечивают, чтобы выходные данные не содержали дубликатов. 

Создать set comprehension можно, используя фигурные скобки вместо квадратных:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_083.png)

Dict comprehensions создаются аналогично, только еще добавляется определение ключа:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_084.png)

И напоследок, можем замерить производительность подходов, list comprehensions побеждают обычные циклы:

![Jupyter notebook](/PythonForAnalysts/Pictures/001_085.png)

На следующей лекции будем знакомиться с анализом данных с помощью библиотеки Pandas. Она позволяет быстро считать статистики, фильтроваться по данным и сортировать их.

[План лекции](#план-лекции-1)

<hr>

## Рекомендуемая дополнительная литература или материалы

1.	[Модуль Random](https://pythonworld.ru/moduli/modul-random.html)
2.	[Jupyter Notebook для начинающих](https://webdevblog.ru/jupyter-notebook-dlya-nachinajushhih-uchebnik/)
3.	[Добавляем в Jupyter Notebook красоту и интерактивность](https://habr.com/ru/post/485318/)
4.	[Введение в генераторы Python](https://webdevblog.ru/vvedenie-v-generatory-python/)
5.	[Что такое *args и **kwargs в Python?](https://habr.com/ru/company/ruvds/blog/482464/)
6.	[Что такое list comprehension? Зачем оно? Какие ещё бывают?](https://dvmn.org/encyclopedia/qna/5/chto-takoe-list-comprehension-zachem-ono-kakie-esche-byvajut/)

## Используемая литература или материалы
1.	[Генераторы Python](https://pythonist.ru/generatory-python-ih-sozdanie-i-ispolzovanie/)
2.	[Когда использовать List Comprehension в Python](https://webdevblog.ru/kogda-ispolzovat-list-comprehension-v-python/)

[План лекции](#план-лекции-1)

<hr>

[План курса](/PythonForAnalysts/README.MD)

<hr>