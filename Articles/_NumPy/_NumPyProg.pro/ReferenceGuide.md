# Reference Guide Справочное руководство

# Содержание

1. [Создание массивов](#1-создание-массивов)<br>
1.1. [Автозаполнение массивов](#11-автозаполнение-массивов)<br>
1.2. [Заполнение данными](#12-заполнение-данными)<br>
1.3. [Создание массивов записей](#12-заполнение-данными)<br>
1.4. [Создание массивов символов](#14-создание-массивов-символов)<br>
1.5. [Числовые диапазоны](#15-числовые-диапазоны) <br>
1.6. [Создание матриц](#16-создание-матриц) <br>
2. Операции над массивами <br>
2.1. Основные операции <br>
2.2. Изменение формы массива <br>
2.3. Транспозиционные операции <br>
2.4. Изменение количества измерений <br>
2.5. Изменение типа массива <br>
2.6. Соединение массивов <br>
2.7. Разбиение массивов <br>
2.8. Циклические массивы <br>
2.9. Добавление и удаление элементов <br>
2.10. Изменение порядка элементов <br>
3. Математические функции <br>
Тригонометрические функции <br>
Гиперболические функции <br>
Округление <br>
Суммы, разности, произведения <br>
Экспоненцирование и логарифмирование <br>
Другие специальные функции <br>
Операции с плавающей точкой <br>
Арифметические операции <br>
Операции с комплексными числами <br>
Прочие математические функции <br>
4. Генерация случайных данных <br>
Получение простых случайных данных <br>
Перестановки <br>
Генератор псевдо-случайных чисел <br>
5. Статистика <br>
Основные статистические характеристики <br>
Средние и отклонения <br>
Корреляции <br>
Гистограммы <br>
6. Линейная алгебра <br>
Произведение векторов и матриц <br>
Разложения матриц <br>
Нормы и прочие числовые характеристики матриц <br>
Собственные значения матриц <br>
Системы уравнений и обратные матрицы <br>
Исключения <br>
7. Ввод вывод данных <br>
Файлы NumPy (npy, npz) <br>
Текстовые файлы <br>
Необработанные бинарные файлы <br>
Строковое представление <br>
Параметры текстового представления <br>
Источники данных <br>
Системы счисления <br>
8. Работа с индексом <br>
Создание индексных массивов <br>
Индексоподобные операции <br>
Вставка данных в массив <br>
Итерирование массивов <br>
9.Сортировка, поиск, подсчет <br>
Сортировка <br>
Поиск <br>
Подсчет <br>

# 1. Создание массивов
## 1.1. Автозаполнение массивов

[Содержание](#содержание)

###  empty()

Возвращает новый массив заданной формы и типа без инициированных записей.

__numpy.empty__
    
    numpy.empty(shape, dtype=float, order='C')

Функция empty() возвращает новый массив заданной формы и типа без инициированных записей.

Параметры:
+ _shape_ - целое число, список или кортеж целых чисел  <br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ _dtype_ - тип данных NumPy (необязательный) <br>
Определяет тип данных выходного массива.
+ _order_ - 'C' или 'F' (необязательный) <br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.
Возвращает:
+ _результат_ - массив NumPy <br>
Массив неициированных (случайных) значений, указанной формы, типа и порядка.

Смотрите так же: empty_like, zeros, ones, full

Замечание<br>
Функция empty в отличие от таких функций как zeros или ones не устанавливает элементы массива в какое-то определенное значение и работает немного быстрее. 

В результате работы функции empty все элементы приобретают случайное значение, которое зависит от состояния памяти, однако, использовать эту функцию в качестве генератора псевдослучайных чисел настоятельно не рекомендуется.

Функция может оказаться крайне полезной, если в вашем коде приходится очень часто создавать временные массивы.

Примеры

    >>> import numpy as np
    

При первом вызове функции все элементы окажутся случайными:

    a = np.empty([2,3])
    >>> a
    array([[  2.45047495e-260,  -1.84746290e-072,  -5.75988362e-044],
        [  1.51671551e-314,   1.51662710e-314,   3.60739299e-313]])

При последующих вызовах функции с теми же параметрами

    >>> a = np.empty([2,3])
    >>> a                      

все элементы окажутся равны нулю (или прежними)

    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])

    >>> a = np.empty([3,3], dtype = int)
    >>> a
    array([[         0,    6553601,      25600],
        [1677722215,   40173569,   16876288],
        [1677722458,  693305346,         10]])
    >>> 
    >>> a = np.empty([2,2], dtype = np.int8)
    >>> a
    array([[ -1,  -1],
        [ -1, 127]], dtype=int8)
    >>>
    >>> a = np.empty(7, dtype = np.complex64)
    >>> a
    array([ -1.21864286e-05 -1.21864286e-05j,
            0.00000000e+00 +0.00000000e+00j,
            0.00000000e+00 +9.10844002e-44j,
            -1.21864286e-05 +4.55124964e-33j,
            0.00000000e+00 +0.00000000e+00j,
            0.00000000e+00 +5.74532370e-44j,
            -1.21864286e-05 -1.21864286e-05j], dtype=complex64)


[Содержание](#содержание)

### empty_like()
Возвращает новый массив с формой и типом данных указанного массива без инициированных записей.

__numpy.empty_like__

    numpy.empty_like(a, dtype=None, order='K', subok=True)

Функция empty_like() возвращает новый массив без инициированных записей с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив <br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива

+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
    Этот параметр определяет в каком порядке массивы должны храниться в памяти: 
    + строчном C-стиле или 
    + столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умолчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив неинициированных (случайных) значений с формой и типом данных указанного массива a.

Замечание

Функция empty_like (так же как и функция empty) не устанавливает элементы массива в какое-то определенное значение и работает немного быстрее чем такие функции как zeros_like или ones_like. <br>
В результате работы функции empty_like все элементы приобретают случайное значение, которое зависит от состояния памяти, однако, использовать эту функцию в качестве генератора псевдослучайных чисел настоятельно не рекомендуется.

    Примеры
    >>> a = np.array([[1,2],[2,1]])
    >>> 
    >>> b = np.empty_like(a)
    >>> b
    array([[0, 0],
        [0, 0]])
    >>> 
    >>> #  Размер и тип данных массивов 'a' и 'b' совпадают:
    ... b.shape == a.shape, b.dtype == a.dtype
    (True, True)
    >>>
    >>> a = np.array([[1,2,3,4],[5,6,7,8]], dtype = np.int8)
    >>> 
    >>> b = np.empty_like(a)
    >>> b
    array([[   0,    0,    0,    0],
        [-118, -114,  -23,   62]], dtype=int8)
    >>> 
    >>> b.shape == a.shape, b.dtype == a.dtype
    (True, True)

[Содержание](#содержание)

### eye()
Возвращает новый массив в котором диагональные элементы равны единице, а все остальные равны нулю.<br>
__numpy.eye__

    numpy.eye(N, M=None, k=0, dtype=<type 'float'>, order='C')

Функция eye() возвращает двумерный массив у которого все элементы по диагонали равны 1, а все остальные равны 0.

Параметры:
+ N - целое число<br>
Задает количество строк выходного массива.
+ M - целое число (необязательный)<br>
Задает количество столбцов выходного массива. Если этот параметр не задан то M = N.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив размером (N, M) с единицами по указанной диагонали и остальными нулевыми элементами.

Смотрите так же: identity, diag, diagflat

Примеры

    >>> import numpy as np
    >>> 
    >>> np.eye(3)    #  Квадратный массив с 1 по главной диагонали
    array([[ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]])
    >>> 
    >>> np.eye(3, 5)    #  Прямоугольный массив с 1 по угловой диагонали
    array([[ 1.,  0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.,  0.],
        [ 0.,  0.,  1.,  0.,  0.]])
    >>> 
    >>> np.eye(3, 5, k=2)     #  Смещение диагонали вверх на две позиции
    array([[ 0.,  0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  0.,  1.]])
    >>> 
    >>> np.eye(5, 3, k=-2)     #  Смещение диагонали вниз на две позиции
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]])
    >>> 
    >>> np.eye(5, dtype = np.int8)    #  Указание типа элементов
    array([[1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1]], dtype=int8)

[Содержание](#содержание)

### identity()
Возвращает новый квадратный массив с единицами по главной диагонали.

__numpy.identity__

    numpy.identity(n, dtype=None)

Функция identity() возвращает квадратный массив с единицами по главной диагонали, при этом остальные элементы выходного массива равны 0. Эквивалентна eye(n, dtype=dtype).

Параметры:
+ n - целое число<br>
Задает размеры квадратного массива (n x n).
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
Возвращает:
+ результат - массив NumPy<br>
Квадратный массив с единицами по главной диагонали, остальные элементы которого равны 0.

Смотрите так же: [eye](#eye), diag, diagflat

Примеры

    >>> import numpy as np
    >>> 
    >>> np.identity(4)
    array([[ 1.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  1.]])
    >>> 
    >>> np.identity(4, dtype = np.int8)
    array([[1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]], dtype=int8)

[Содержание](#содержание)

### ones()
Возвращает новый массив заданной формы и типа, заполненный единицами.

__numpy.ones__

    numpy.ones(shape, dtype=None, order='C')

Функция __ones()__ возвращает новый массив указанной формы и типа, заполненный единицами.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив из единиц, указанной формы, типа и порядка.

Смотрите так же: ones_like, zeros, empty, full

Примеры

    >>> import numpy as np
    >>> 
    >>> np.ones(10)
    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
    >>> 
    >>> np.ones(10, dtype = np.int8)
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int8)
    >>> 
    >>> np.ones((3, 5))
    array([[ 1.,  1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.,  1.]])
    >>> 
    >>> np.ones((3, 1))
    array([[ 1.],
        [ 1.],
        [ 1.]])
    >>>
    >>> m = (3, 2, 2)
    >>> 
    >>> np.ones(m)
    array([[[ 1.,  1.],
            [ 1.,  1.]],

        [[ 1.,  1.],
            [ 1.,  1.]],

        [[ 1.,  1.],
            [ 1.,  1.]]])


[Содержание](#содержание)

### ones_like()

Возвращает новый массив с формой и типом данных указанного массива, заполненный единицами.

__numpy.ones_like__

    numpy.ones_like(a, dtype=None, order='K', subok=True)

Функция ones_like() возвращает новый массив из единиц с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>

    Этот параметр определяет в каком порядке массивы должны храниться в памяти: 
    + строчном C-стиле или столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.

+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив из единиц, с формой и типом данных указанного массива a.

Смотрите так же: ones, zeros_like, empty_like, full_like

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[7, 7], [1, 1]])
    >>> a
    array([[7, 7],
        [1, 1]])
    >>> 
    >>> np.ones_like(a)
    array([[1, 1],
        [1, 1]])
    >>> 
    >>> np.ones_like(a, dtype = np.int8)
    array([[1, 1],
        [1, 1]], dtype=int8)
    >>> 
    >>> b = np.arange(8, dtype = np.float32)
    >>> b
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.], dtype=float32)
    >>> 
    >>> b = b.reshape(2, 4)
    >>> b
    array([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.]], dtype=float32)
    >>> 
    >>> np.ones_like(b)
    array([[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]], dtype=float32)

Смотрите так же: arange, reshape

[Содержание](#содержание)

### zeros()
Возвращает новый массив заданной формы и типа, заполненный нулями.

__numpy.zeros__
    
    numpy.zeros(shape, dtype=float, order='C')

Функция zeros() возвращает новый массив указанной формы и типа, заполненный нулями.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив из нулей, указанной формы, типа и порядка.

Смотрите так же: zeros_like, ones, empty, full

Примеры

    >>> import numpy as np
    >>> 
    >>> np.zeros(4)    #  Массив-строка из нулей
    array([ 0.,  0.,  0.,  0.])
    >>> 
    >>> np.zeros((4, 1))    #  Массив-столбец из нулей
    array([[ 0.],
        [ 0.],
        [ 0.],
        [ 0.]])
    >>> 
    >>> np.zeros((3, 3))    #  Массив из нулей указанных размеров
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])
    >>> 
    >>> np.zeros((3, 3), dtype = np.int8)    #  Указываем форму и тип данных
    array([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]], dtype=int8)
    >>>
    >>>
    >>> #  zeros может применяться для создания и 
    ... #  заполнения структурированных массивов:
    ... f = np.zeros((5), dtype=[('x', 'i2'), ('y', 'f4')])
    >>> 
    >>> f
    array([(0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0)], 
        dtype=[('x', '<i2'), ('y', '<f4')])
    >>>
    >>> f['x']
    array([0, 0, 0, 0, 0], dtype=int16)
    >>> 
    >>> f['y']
    array([ 0.,  0.,  0.,  0.,  0.], dtype=float32)

[Содержание](#содержание)

### zeros_like()
Возвращает новый массив с формой и типом данных указанного массива, заполненный нулями.

__numpy.zeros_like__
    
    numpy.zeros_like(a, dtype=None, order='K', subok=True)

Функция zeros_like() возвращает новый массив из нулей с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>

    Этот параметр определяет в каком порядке массивы должны храниться в памяти:
    + строчном C-стиле или столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив из нулей, с формой и типом данных указанного массива a.

Смотрите так же: zeros, empty_like, ones_like, full_like

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a
    array([1, 2, 3, 4, 5])
    >>> 
    >>> np.zeros_like(a)
    array([0, 0, 0, 0, 0])
    >>> 
    >>> b = np.arange(16, dtype = np.float64)
    >>> b = b.reshape((4, 4))
    >>> b
    array([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.],
        [ 12.,  13.,  14.,  15.]])
    >>> 
    >>> c = np.zeros_like(b)
    >>> c
    array([[ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.]])
    >>> 
    >>> c.dtype
    dtype('float64')

Смотрите так же: arange, reshape

[Содержание](#содержание)

### full()
Возвращает новый массив заданной формы и типа все элементы которого равны указанному значению.

__numpy.full__

    numpy.full(shape, fill_value, dtype=None, order='C')

Функция full() возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ fill_value - число или любое допустимое значение NumPy<br>
Все элементы выходного массива будут равны fill_value.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив указанной формы, типа и порядка, все элементы которого равны указанному в fill_value значению.

Смотрите так же: full_like, empty, zeros, ones

Замечание

Если параметр dtype не указан то тип данных выходного массива будет таким же как у fill_value, который можно узнать, выполнив np.array(fill_value).dtype:

    >>> fill_value = 3.14
    >>>
    >>> np.array(fill_value).dtype
    dtype('float64')

Примеры

    >>> import numpy as np
    >>> 
    >>> np.full(4, 5)    #  Может появиться предупреждение
    /home/n1/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:301:
    FutureWarning: in the future, full((4,), 5)
    will return an array of dtype('int32')
    format(shape, fill_value, array(fill_value).dtype), FutureWarning)
    array([ 5.,  5.,  5.,  5.])
    >>> # т.е. в будущем  full((4,), 5) вернет массива типа 'int32'
    ... #  на вычислениях это никак не скажется
    ... 
    >>> np.full(4, 5) + 1
    array([ 6.,  6.,  6.,  6.])
    >>> 
    >>> np.full((3, 3), 5, dtype = int)
    array([[5, 5, 5],
        [5, 5, 5],
        [5, 5, 5]])
    >>>
    >>>
    >>> #  Можно заполнить массив значением inf или nan:
    ... np.full((3, 3),np.inf)
    array([[ inf,  inf,  inf],
        [ inf,  inf,  inf],
        [ inf,  inf,  inf]])
    >>> 
    >>> np.full((3, 3),np.nan)
    array([[ nan,  nan,  nan],
        [ nan,  nan,  nan],
        [ nan,  nan,  nan]])
    >>>
    >>>
    >>> #  Или строками:
    ... np.full((3, 3), 'a')
    array([['a', 'a', 'a'],
        ['a', 'a', 'a'],
        ['a', 'a', 'a']], dtype='<U1')


[Содержание](#содержание)

### full_like()
Возвращает новый массив с формой и типом данных указанного массива, все элементы которого равны указанному значению.

__numpy.full_like__

    numpy.full_like(a, fill_value, dtype=None, order='K', subok=True)

Функция full_like() возвращает новый массив все элементы которого равны указанному значению fill_value, а форма и тип данных такие же как у указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива
+ fill_value - число или любое допустимое значение NumPy<br>
Все элементы выходного массива будут равны fill_value.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив все элементы, кторого равны fill_value, с формой и типом данных указанного массива a

Смотрите так же: full, zeros_like, ones_like empty_like

Замечание

Если параметр dtype не указан то тип данных выходного массива будет таким же как у fill_value, который можно узнать, выполнив np.array(fill_value).dtype:

    >>> fill_value = 3.14
    >>>
    >>> np.array(fill_value).dtype
    dtype('float64')

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a
    array([1, 2, 3, 4, 5])
    >>> 
    >>> np.full_like(a, 77)
    array([77, 77, 77, 77, 77])
    >>> 
    >>> b = np.arange(16, dtype = np.float64)
    >>> b = b.reshape((4,4))
    >>> b
    array([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.],
        [ 12.,  13.,  14.,  15.]])
    >>> 
    >>> c = np.full_like(b, 77)
    >>> c
    array([[ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.]])
    >>> 
    >>> c.dtype
    dtype('float64')
    >>>
    >>> a = np.array([1,2,3,4,5])    #  Если тип исходного массива int
    >>>                              #  а fill_value типа float,
    >>> np.full_like(a, 0.1)         #  то данные из дробной части потеряются.
    array([0, 0, 0, 0, 0])
    >>> 
    >>> np.full_like(a, 0 + 5j)      #  Это же касается и комплексных чисел
    /home/n1/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:361:
    ComplexWarning: Casting complex values to real discards the imaginary part
    multiarray.copyto(res, fill_value, casting='unsafe')
    array([0, 0, 0, 0, 0])
    >>>
    >>> #  Можно заполнить массив значением inf или nan
    ... 
    >>> c = np.full_like(b, np.inf)
    >>> c
    array([[ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf]])
    >>> 
    >>> c = np.full_like(b, np.nan)
    >>> c
    array([[ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan]])
    >>>
    >>> #  Для заполнения массива строками
    ... #  необходимо указать тип данных np.unicode
    ... 
    >>> c = np.full_like(b, 'a', dtype = np.unicode)
    >>> c
    array([['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a']], 
        dtype='<U1')

Смотрите так же: arange, reshape

[Содержание](#содержание)

## 1.2. Заполнение данными

### array()
Создает массив NumPy.

__numpy.array__

    numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Функция array() создает массив NumPy.

Параметры:
+ object - подобный массиву объект<br>
Список или кортеж, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если: метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (dtype, order и т.д.)
+ order - 'K', 'A', 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Если object - это массив NumPy, то флаг 'K' либо сохраняет порядок исходного массива либо устанавливает самый близкий по структуре; флаг 'A' установит макет памяти выходного массива в 'F' если массив object является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. По умолчанию флаг установлен в значение 'K'.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию в False), то выходной массив будет использовать тип подкласса массива object, если False то тип массива базового класса.
+ ndmin- целое число (необязательный)<br>
Определяет минимальное количество измерений результирующего массива, которое, по мере необходимости, будет прикреплено к его форме для удовлетворения этого требования.

Возвращает:
+ результат - массив NumPy<br>
Массив удовлетворяющий всем указанным требованиям.

Смотрите так же: empty, empty_like, zeros, zeros_like, ones, ones_like, full, full_like

Замечание

Довольно большое значение имеет параметр order, который отвечает за порядок хранения массива в памяти. В некоторых ситуациях этот порядок может изменяться, что в редких случаях может приводить к ошибкам. Например при выполении транспонирования массива порядок 'C' может измениться на порядок 'F':

    >>> a = np.array([[1, 2], [1, 2]])
    >>> a
    array([[1, 2],
        [1, 2]])
    >>> 
    >>> b = a.T    #  Присвоим массиву 'b' транспонированную матрицу 'a' 
    >>> b
    array([[1, 1],
        [2, 2]])
    >>> 
    >>> #  Теперь проверим порядок хранения в памяти
    ... 
    >>> a.flags
    C_CONTIGUOUS : True
    F_CONTIGUOUS : False
    OWNDATA : True
    WRITEABLE : True
    ALIGNED : True
    UPDATEIFCOPY : False
    >>> 
    >>> b.flags
    C_CONTIGUOUS : False
    F_CONTIGUOUS : True
    OWNDATA : False
    WRITEABLE : True
    ALIGNED : True
    UPDATEIFCOPY : False

Как видно, массив a до транспонирования имел C_CONTIGUOUS : True и F_CONTIGUOUS : False т.е. был организован в C-стиле, после транспонирования он сменился на стиль Fortran: C_CONTIGUOUS : False и F_CONTIGUOUS : True.

Если параметр order установлен в значение 'A' и в качестве object указан массив с порядком отличным от 'F' или 'C', то результирующий массив не всегда будет иметь ожидаемый флаг 'C'. В редких случаях это так же может приводить к ошибкам.

Примеры

    >>> import numpy as np
    >>> 
    >>> np.array([1, 2, 3, 4, 5, 6, 7])
    array([1, 2, 3, 4, 5, 6, 7])
    >>> 
    >>>
    >>> #  Если элементы разного типа, то все они приводятся к наиболее общему:
    ... np.array([1, 1, 2, 2, 3.14, 3.14])
    array([ 1.  ,  1.  ,  2.  ,  2.  ,  3.14,  3.14])
    >>> 
    >>> np.array([1+1j, 1+1j, 2, 2, 3.14, 3.14])
    array([ 1.00+1.j,  1.00+1.j,  2.00+0.j,  2.00+0.j,  3.14+0.j,  3.14+0.j])
    >>> 
    >>>
    >>> np.array([[1, 2], [3, 4]])    #  Двумерный массив
    array([[1, 2],
        [3, 4]])
    >>> #  Создание трехмерного массива
    >>> np.array([[[1, 1], [2, 2]],    
    ...           [[3, 3], [4, 4]],
    ...           [[5, 5], [6, 6]]])
    array([[[1, 1],
            [2, 2]],

        [[3, 3],
            [4, 4]],

        [[5, 5],
            [6, 6]]])
    >>>
    >>>
    >>> #  Создание массива у которого минимум 2 измерения:
    ... a = np.array([1, 3, 5], ndmin = 2)
    >>> a
    array([[1, 3, 5]])
    >>>
    >>>
    >>> #  Указание типа данных массива:
    ... np.array([[1, 2], [3, 4]], dtype = complex)
    array([[ 1.+0.j,  2.+0.j],
        [ 3.+0.j,  4.+0.j]])
    >>> 
    >>>
    >>> #  Создание структурированного массива:
    ... y = np.array([(1, 1), (2, 4), (3, 9), (4, 16)], dtype = [('x','i2'),('f_x','f4')])
    >>> y['x']
    array([1, 2, 3, 4], dtype=int16)
    >>> y['f_x']
    array([  1.,   4.,   9.,  16.], dtype=float32)
    >>> 
    >>> 
    >>> #  Создание массивов с использованием подклассов:
    ... np.array(np.mat('1 1 1; 2 2 2; 3 3 3'))
    array([[1, 1, 1],
        [2, 2, 2],
        [3, 3, 3]])
    >>> 
    >>> np.array(np.mat('1 1 1; 2 2 2; 3 3 3'), subok = True)
    matrix([[1, 1, 1],
            [2, 2, 2],
            [3, 3, 3]])

[Содержание](#содержание)

### asarray()
Преобразует последовательность в массив NumPy.

__numpy.asarray__

    numpy.asarray(a, dtype=None, order=None)
Функция asarray() преобразует последовательность в массив NumPy.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. По умолчанию установлен в 'C'.

Возвращает:
+ результат - массив NumPy<br>
Интерпретация входных данных a, как массива NumPy. Если входные данные являются массивом NumPy, то никакое копирование данных не выполняется (эквивалентно array(a, dtype, copy=False, order=order)). Если входные данные являются подклассом ndarray, то возвращается базовый класс ndarray.

Смотрите так же: array, asanyarray, ascontiguousarray, asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> np.asarray(a)
    array([1, 2, 3])
    >>> 
    >>> b = [[1, 2], [3, 4]]
    >>> np.asarray(b)
    array([[1, 2],
        [3, 4]])
    >>> 
    >>> 
    >>> #  Массивы NumPy не копируются
    ... 
    >>> a = np.array([1, 2, 3])
    >>> b = np.asarray(a)
    >>> 
    >>> b is a    #  Данные в 'b' физически те же что и в 'a'
    True
    >>> a[0] = 77    #  Изменения в массиве 'a'
    >>> a
    array([77,  2,  3])
    >>>
    >>> b    #  Повлекут за собой изменения в массиве 'b'
    array([77,  2,  3])
    >>> 
    >>> 
    >>> #  Копирование происходит только
    ... #  при несоответствии типов данных массивов
    ... a = np.array([1,2,3], dtype = np.int8)    #  одинаковые типы данных
    >>> b = np.asarray(a, dtype = np.int8)
    >>> b is a
    True
    >>> 
    >>> b = np.asarray(a, dtype = np.float32)    #  разные типы данных
    >>> b is a
    False
    >>> 
    >>> 
    >>> #  Вместо подкласса будет возвращен базовый класс:
    ... a = np.mat('1 1; 2 2')
    >>> a
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> b = np.asarray(a)
    >>> b
    array([[1, 1],
        [2, 2]])
    >>> 
    >>> 
    >>> #  Список массивов преобразуется в массив:
    ... a = np.array([1, 1])
    >>> b = np.array([2, 2])
    >>> 
    >>> c = [a, b]
    >>> 
    >>> d = np.asarray(c)
    >>> d
    array([[1, 1],
        [2, 2]])

[Содержание](#содержание)

### asanyarray()
Преобразует последовательность в массив NumPy, пропуская подклассы ndarray.

__numpy.asanyarray__

    numpy.asanyarray(a, dtype=None, order=None)

Функция asanyarray() преобразует последовательность в массив NumPy, не приводя подклассы ndarray к базовому классу.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. По умолчанию установлен в 'C'.

Возвращает:
+ результат - массив NumPy<br>
Интерпретация входных данных a, как массива NumPy. Если a является объектом ndarray или его подклассом, то он не копируется и возвращается в неизменном виде (эквивалентно array(a, dtype, copy=False, order=order, subok=True)).

Смотрите так же: array, asarray, ascontiguousarray, asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> np.asanyarray(a)
    array([1, 2, 3])
    >>> 
    >>> 
    >>> #  Массивы NumPy не копируются:
    ... a = np.array([1, 2, 3])
    >>> b = np.asanyarray(a)
    >>> 
    >>> b is a    #  Данные в 'b' физически те же что и в 'a'
    True
    >>> a[0] = 77    #  Изменения в массиве 'a'
    >>> a
    array([77,  2,  3])
    >>> 
    >>> b    #  Повлекут за собой изменения в массиве 'b'
    array([77,  2,  3])
    >>>
    >>>
    >>> #  Копирование происходит только
    ... #  при несоответствии типов данных массивов
    ... 
    >>> a = np.array([1,2,3], dtype = np.int8)
    >>> b = np.asanyarray(a, dtype = np.int8)
    >>> b is a
    True
    >>> 
    >>> b = np.asanyarray(a, dtype = np.float32)
    >>> b is a
    False
    >>> 
    >>> 
    >>> #  Подкласс будет возвращен как есть:
    ... a = np.mat('1 1; 2 2')
    >>> a
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> b = np.asanyarray(a)
    >>> b
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> 
    >>> #  Список массивов преобразуется в массив
    ... a = np.array([1, 1])
    >>> b = np.array([2, 2])
    >>> c = [a, b]
    >>> 
    >>> d = np.asanyarray(c)
    >>> d
    array([[1, 1],
        [2, 2]])

[Содержание](#содержание)

### ascontiguousarray()

Возвращает непрерывный массив в памяти с организацией порядка элементов в С-стиле.

__numpy.ascontiguousarray__

    numpy.ascontiguousarray(a, dtype=None)

Функция ascontiguousarray() возвращает непрерывный массив в памяти с организацией порядка элементов в С-стиле.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

Возвращает:
+ результат - массив NumPy<br>
Интерпретирует входные данные a как массив NumPy, с порядком организации в памяти в С-стиле (эквивалентно array(a, dtype, copy=False, order='C', ndmin=1)). Если в качестве a передан существующий массив NumPy, с порядком организации в памяти отличным от C-стиля, то он будет к нему приведен. Если указать параметр dtype, то он изменит тип данных выходного массива.

Смотрите так же: asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> 
    >>>np.ascontiguousarray(a)
    array([1, 2, 3])
    >>>
    >>> 
    >>> #  Создаваемые массивы имеют порядок в С-стиле:
    ... a = np.array([[1, 2], [3, 4]])
    >>> a
    array([[1, 2],
        [3, 4]])
    >>>
    >>> a.flags['C_CONTIGUOUS']
    True
    >>> 
    >>> b = a.T    #  Транспонирование меняет порядок с 'C' на 'F':
    >>> b
    array([[1, 3],
        [2, 4]])
    >>> 
    >>> b.flags['C_CONTIGUOUS']
    False
    >>> 
    >>>  #  Мы можем изменить порядок на 'C':
    ... b = np.ascontiguousarray(b)
    >>> b.flags['C_CONTIGUOUS']
    True
    >>> b    #  Не изменяя форму и содержимое самого массива
    array([[1, 3],
        [2, 4]])


[Содержание](#содержание)

### asmatrix()
Интерпретирует входные данные как матрицу.

__numpy.asmatrix__

    numpy.asmatrix(a, dtype=None)

Функция asmatrix() интерпретирует входные данные как матрицу.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)

Возвращает:
+ результат - матрица NumPy<br>
Интерпретация входных данных a, как матрицы NumPy.

Смотрите так же: mat, bmat

Замечание

В отличие от функции matrix, функция asmatrix не выполняет копирования объектов ясли они уже являются матрицами или объектами ndarray, т.е. функция asmatrix эквивалентна matrix(a, copy = False).

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательности в матрицу:
    >>> a = [1, 2]
    >>> 
    >>> np.asmatrix(a)
    matrix([[1, 2]])
    >>> 
    >>>
    >>> b = np.array([[1, 2], [3, 4]])
    >>> 
    >>> #  Преобразование массива в матрицу не выполняет копирования:
    >>> c = np.asmatrix(b)
    >>> c
    matrix([[1, 2],
            [3, 4]])
    >>> 
    >>> c is b
    False
    >>> 
    >>> b[0,0] = 77    #  Изменение в 'b'
    >>> b
    array([[77,  2],
        [ 3,  4]])
    >>> 
    >>> c    #  Приведет к изменениям в 'c'
    matrix([[77,  2],
            [ 3,  4]])

[Содержание](#содержание)

### copy()
Возвращает копию массива.

__numpy.copy__

    numpy.copy(a, order='K')

Функция copy() возвращает массив-копию указанного объекта.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
Этот параметр определяет в каком порядке копия массива должна храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
Возвращает:
+ результат - массив NumPy<br>
Интерпретирует входные данные a как массив NumPy и делает их полную копию

Смотрите так же: array, copyto

Замечание

Функции numpy.copy(a, order='K') и ndarray.copy(order='C') очень похожи, но имеют разные, установленные по умолчанию, параметры order. Функция numpy.copy(a, order='K') так же эквивалентна np.array(a, copy=True).

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> 
    >>> b = a    #  'b' - это указатель на данные из 'a'
    >>> 
    >>> a
    array([1, 2, 3, 4, 5])
    >>> b
    array([1, 2, 3, 4, 5])
    >>> 
    >>> b is a    #  Это один и тот же объект
    True
    >>>
    >>> a[0] = 111     #  Изменения в 'a'
    >>> a
    array([111,   2,   3,   4,   5])
    >>>
    >>> b    #  Повлекут изменения в 'b'
    array([111,   2,   3,   4,   5])
    >>> 
    >>> c = np.copy(a)    #  'c' - это копия 'a'
    >>> 
    >>> a
    array([111,   2,   3,   4,   5])
    >>> c
    array([111,   2,   3,   4,   5])
    >>> 
    >>> c is a    #  Это два разных объекта
    False
    >>> 
    >>> a[0] = 999     #  Изменения в 'a'
    >>> a
    array([999,   2,   3,   4,   5])
    >>>
    >>> c     #  Никак не отразятся в 'с'
    array([111,   2,   3,   4,   5])

[Содержание](#содержание)

### frombuffer()
Преобразует буфер в одномерный массив.

__numpy.frombuffer__

    numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)

Функция frombuffer() интерпретирует буфер как одномерный массив.

Параметры:
+ buffer - буфер-подобный объект<br>
Объект, который имеет интерфейс буфера.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. По умолчанию float.
+ count - целое число (необязательный)<br>
Количество считываемых элементов из буфера. По умолчанию count=-1, что означает чтение всех данных из буфера.
+ offset - целое число (необязательный)<br>
Задает позицию начала чтения из буфера. По умолчанию offset=0

Возвращает:
+ результат - массив NumPy<br>
Интерпретация данных из буфера, как одномерного массива NumPy.

Смотрите так же: fromfile, fromfunction, fromstring, fromiter

Замечание

Если данные в буфере находятся не в машинном байтовом порядке, то это должно быть указано в типе данных:

    >>> dt = np.dtype(np.unicode)
    >>> dt = dt.newbyteorder('<')
    >>> np.frombuffer(buffer, dtype=dt)

Данные результирующего массива не будут разбиты на байты, но будут правильно интерпретироваться.

Примеры

    >>> import numpy as np
    >>> s1 = b'abcdefg'
    >>> 
    >>> np.frombuffer(s1, dtype = 'S1')
    array([b'a', b'b', b'c', b'd', b'e', b'f', b'g'], 
        dtype='|S1')
    >>> 
    >>> s2 = b'\x01\x02\x03\x04\x05\x06\x07'
    >>>
    >>> np.frombuffer(s2, dtype=np.int8)
    array([1, 2, 3, 4, 5, 6, 7], dtype=int8)
    >>>
    >>> np.frombuffer(s2, dtype=np.int8, count = 3, offset = 2)
    array([3, 4, 5], dtype=int8)

[Содержание](#содержание)

### fromfile()
Создает массив из текстового или двоичного файла.

__numpy.fromfile__

    numpy.fromfile(file, dtype=float, count=-1, sep='')

Функция fromfile() создает массив из данных в текстовом или двоичном файле.<br> Является очень эффективным методом чтения двоичных данных с известным типом данных, а так же чтения текстовых файлов с простым форматированием.<br> Данные, написанные с использованием метода tofile, так же могут быть прочитаны с использованием этой функции.

Параметры:
+ file - файл или строка с именем файла<br>
Файл или файловый объект.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Для двоичных файлов он используется что бы определить размер и порядок байтов элементов в файле.
+ count - целое число (необязательный)<br>
Определяет количество считываемых элементов из файла. По умолчанию count=-1 что означает все элементы, т.е. весь файл целиком.
+ sep - строка-разделитель<br>
Разделитель между элементами в текстовом файле. Если sep = '' указывает на то что файл следует рассматривать как двоичный.

Возвращает:
+ результат - массив NumPy<br>
Массив, созданный из данных, находящихся в текстовом или двоичном файле.

Смотрите так же: frombuffer, fromfunction, fromstring, fromiter

Замечание

При использовании двоичных файлов на разных платформах следует помнить, что хранение данных в двоичных файлах зависит от используемой платформы, и ко всему прочему информация о порядке байтов и типе данных в них не сохраняется. Данные удобно хранить в независимом от платформы формате .npy, с использованием функций save и load.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1,2,3], dtype = int)
    >>>
    >>> #  Создание двоичного файла:
    ... a.tofile('file_name')
    >>> 
    >>> #  Создание массива из данных в двоичном файле:
    ... b = np.fromfile('a', dtype = int )
    >>> b
    array([1, 2, 3])
    >>> 
    >>> 
    >>> #  Создание текстового файла:
    ... np.savetxt('file_name', a, newline=',')
    >>>
    >>> #  Создание массива из данных в текстовом файле:
    ... c = np.fromfile('file_name', sep = ',')
    >>> c
    array([ 1.,  2.,  3.])

[Содержание](#содержание)

### fromfunction()
Создает массив с выполнением указанной функции над каждым элементом.

__numpy.fromfunction__

    numpy.fromfunction(function, shape, **kwargs)

Функция fromfunction() создает массив, выполняя функцию над каждым элементом.

Параметры:
+ function - подлежащая выполнению функция<br>

Функция может содержать N параметров, при этом количество параметров определяет размерность выходного массива.<br> Каждый из N параметров перебирает элементы вдоль определенной оси.<br> Например, если мы используем два параметра, и указываем размеры массива (3, 3), то один из параметров пробегал бы значения массива

    array([[0,0,0],[1,1,1],[2,2,2]]),

а другой значения массива
    
    array([[0,1,2],[0,1,2],[0,1,2],])

+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

Возвращает:
+ результат - массив NumPy<br>
Массив все элементы которого представляют собой результат работы указанной функции.

Смотрите так же: frombuffer, fromfile, fromstring, fromiter

Примеры

    >>> import numpy as np
    >>> 
    >>> np.fromfunction(lambda x, y: x == y, (4,4), dtype = int)
    array([[ True, False, False, False],
        [False,  True, False, False],
        [False, False,  True, False],
        [False, False, False,  True]], dtype=bool)
    >>> 
    >>> np.fromfunction(lambda x, y: x + 0*y, (4,4), dtype = int)
    array([[0, 0, 0, 0],
        [1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3]])
    >>> 
    >>> np.fromfunction(lambda x, y: 0*x + y, (4,4), dtype = int)
    array([[0, 1, 2, 3],
        [0, 1, 2, 3],
        [0, 1, 2, 3],
        [0, 1, 2, 3]])
    >>> 
    >>> np.fromfunction(lambda x, y: x + y, (4,4), dtype = int)
    array([[0, 1, 2, 3],
        [1, 2, 3, 4],
        [2, 3, 4, 5],
        [3, 4, 5, 6]])
    >>> 
    >>> np.fromfunction(lambda x, y: x**2 + y**2, (4,4), dtype = int)
    array([[ 0,  1,  4,  9],
        [ 1,  2,  5, 10],
        [ 4,  5,  8, 13],
        [ 9, 10, 13, 18]])

[Содержание](#содержание)

### fromiter()
Создает одномерный массив из итерируемого объекта.

__numpy.fromiter__

    numpy.fromiter(iterable, dtype, count=-1)

Функция fromiter() создает одномерный массив из итерируемого объекта.

Параметры:
+ iterable - итерируемый объект.<br>
Объект, который поддерживает интерфейс итераций.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ count - целое число (необязательный)<br>
Количество считываемых элементов из объекта. По умолчанию count=-1, что означает чтение всех элементов.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив значений из указанного итерируемого объекта.

Смотрите так же: frombuffer, fromfile, fromstring, fromfunction

Замечание

Если количество элементов в итерируемом объекте известно, то указав его в параметре count, можно немного повысить производительность функции fromiter. данный параметр позволяет сразу создать выходной массив и затем заполнять его, а не изменять его каждый раз с добавлением нового элемента.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = range(10)
    >>> 
    >>> np.fromiter(a, dtype = int)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>> 
    >>> 
    >>> b = [2*x + 1 for x in range(10)]
    >>> b
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    >>> 
    >>> np.fromiter(b, dtype = int)
    array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19])

[Содержание](#содержание)

### fromstring()
Создает одномерный массив из строки.

__numpy.fromstring__

    numpy.fromstring(string, dtype=float, count=-1, sep='')

Функция fromstring() создает новый одномерный массив, который заполнен данными из указанной строки.

Параметры:
+ string - строка<br>
Строка с данными, например '1, 2, 3, 4,'
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. По умолчанию float. Для двоичных данных должен быть указан обязательно.
+ count - целое число (необязательный)<br>
Указывает количество считываемых элементов указанного типа из строки. По умолчанию count=-1, что означает считываение всех данных из строки.
+ sep - строка-разделитель (необязательный)<br>
Разделитель между элементами в строке. Если sep = '' указывает на то, что данные в строке следует рассматривать как двоичные.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив заполненный данными из указанной строки.

Смотрите так же: frombuffer, fromfile, fromiter, fromfunction

Примеры

    >>> import numpy as np
    >>> 
    >>> np.fromstring('1 2 3 4 5', dtype = int, sep = ' ')
    array([1, 2, 3, 4, 5])
    >>> 
    >>> a = '1, 2, 3, 4, 5, 6, 7'
    >>> 
    >>> np.fromstring(a, dtype = int, sep = ', ')
    array([1, 2, 3, 4, 5, 6, 7])
    >>> 
    >>> np.fromstring(a, dtype = int, count = 3, sep = ', ')
    array([1, 2, 3])

[Содержание](#содержание)

### loadtxt()
Создает массив из данных в текстовом файле.

__numpy.loadtxt__

    numpy.loadtxt(fname, dtype='float', comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes')

Функция loadtxt() создает новый массив из данных в текстовом файле.

Параметры:
+ fname - файл или строка с именем файла<br>
Файл, файловый объект.<br> Если расширение имени файла - .gz или .bz2, то файл сначала распаковывается.<br> Для Python3.X файловые объекты должны возвращать строки байтов.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.<br> По умолчанию float. <br>Если в файле находятся структурированные данные, т.е. структурированный тип данных, то результирующий массив будет одномерным, а каждая строка файла станет его отдельным элементом. <br>В этом случае, необходимо определить структурированный тип данных, количество полей в котором должно соответствовать количеству колонок в текстовом файле.
+ comments - строка или последовательность строк (необязательный)<br>
Символы или список символов, используемых для указания начала строк-комментариев.<br> Байтовые строки декодируются как Latin-1.<br> По умолчанию используется символ '#'.
+ delimiter - строка (необязательный)<br>
Строка-разделитель между значениями в текстовом файле. Байтовые строки декодируются как Latin-1. По умолчанию используется пробел.
+ converters - словарь (необязательный)<br>
Словарь, в качестве ключей которого используются целые числа соответствующие столбцам данных в файле. <br>Значение ключа сопоставляет соответствующий ключу столбец с соответствующей ключу функцией конвертирования. 
Например:

    converters = {3: lambda x: float(x.lstrip('$') or 0)}.

+ skiprows - целое число (необязательный)<br>
Указывает количество строк, которые необходимо пропустить. По умолчанию равно 0.
+ usecols - целое число или кортеж целых чисел (необязательный)<br>
Указывает какие столбцы будут считаны. <br>Первый столбец имеет номер 0. <br>По умолчанию usecols=None что соответствует чтению всех столбцов в файле. <br>Целое число, например usecols=1 так же как и кортеж с одним значением usecols=(1,) приведет к считыванию единственного из всех столбца в файле, т.е. будет прочитан только второй столбец.
+ unpack - True или False (необязательный)<br>
Если этот параметр равен True, то все столбцы текстового файла могут быть разделены и распакованы с помощью a, b, c = loadtxt(...). <br>Использование структурированного типа данных приводит к тому, что для каждого отдельного поля будет возвращен отдельный массив. <br>По умолчанию unpack=False
+ ndmin - целое число (необязательный)<br>
Определяет минимальную размерность возвращаемого массива. По умолчанию ndmin=0 что соответствует сжатию всех осей длинной 1, до одной оси.

Возвращает:
+ результат - массив NumPy<br>
Массив неициированных (случайных) значений, указанной формы, типа и порядка.

Смотрите так же: fromfile

Замечание

Данная функция предназначена для быстрого чтения данных в простом текстовом формате. Все строки в текстовом файле должны иметь одинаковое количество значений. Функция genfromtxt может обеспечить чтение данных из текстовых файлов с более сложным форматом.

Примеры

Для примера создадим небольшой текстовый файл loadtxt_example.txt из 6 колонок: "Атомный номер", "Обозначение элемента", "Группа", "Период", "Атомная масса", "Радиус атома".

    #  Некоторые данные о 15 химических элементах.
    #  Сдесь представлены: "Атомный номер", 
    #  "Обозначение элемента", "Группа", "Период", 
    #  "Атомный масса", "Радиус атома (pm)"


    1 H 7 1 1.00797 25
    2 He 8 1 4.0026 30
    3 Li 1 2 6.939 145
    4 Be 2 2 9.0122 105
    5 B 3 2 10.811 85
    6 C 4 2 12.01115 70
    7 N 5 2 14.0067 65
    8 O 6 2 - 60
    9 F 7 2 18.9984 50
    10 Ne 8 2 20.179 40
    11 Na 1 3 22.9898 180
    12 Mg 2 3 24.305 150
    13 Al 3 3 26.9815 125
    14 Si 4 3 28.086 110
    15 P 5 3 - 100

В данном примере текстовый файл находится в той же директории, в которой происходит выполнение скрипта Python.

    >>> import numpy as np
    >>> 
    >>> fname = 'loadtxt_example.txt'
    >>> 
    >>> dt_1 = np.dtype([('№','i2'),('symbol','|S2'),('radius','i2'),])
    >>> 
    >>> a = np.loadtxt(fname, dtype=dt_1, skiprows=6, usecols=(0,1,5))
    >>> 
    >>> a
    array([(1, b'H', 25), (2, b'He', 30), (3, b'Li', 145), (4, b'Be', 105),
        (5, b'B', 85), (6, b'C', 70), (7, b'N', 65), (8, b'O', 60),
        (9, b'F', 50), (10, b'Ne', 40), (11, b'Na', 180), (12, b'Mg', 150),
        (13, b'Al', 125), (14, b'Si', 110), (15, b'P', 100)], 
        dtype=[('№', '<i2'), ('symbol', 'S2'), ('radius', '<i2')])
    >>> 
    >>> 
    >>> 
    >>> def parse_mas(s):
            try:
                return float(s)
            except ValueError:
                return np.nan
    >>> 
    >>> dt_2 = np.dtype([('№','i2'),('symbol','|S2'),('mass','f4'),])
    >>> 
    >>> b = np.loadtxt(fname, dtype=dt_2, skiprows=6, usecols=(0,1,4), converters={4: parse_mas})
    >>> 
    >>> b
    array([(1, b'H', 1.0079699754714966), (2, b'He', 4.002600193023682),
        (3, b'Li', 6.939000129699707), (4, b'Be', 9.012200355529785),
        (5, b'B', 10.810999870300293), (6, b'C', 12.011150360107422),
        (7, b'N', 14.006699562072754), (8, b'O', nan),
        (9, b'F', 18.99839973449707), (10, b'Ne', 20.179000854492188),
        (11, b'Na', 22.98979949951172), (12, b'Mg', 24.30500030517578),
        (13, b'Al', 26.98150062561035), (14, b'Si', 28.086000442504883),
        (15, b'P', nan)], 
        dtype=[('№', '<i2'), ('symbol', 'S2'), ('mass', '<f4')])
    >>> 
    >>> 
    >>> dt_3 = np.dtype([('symbol','|S2'),('radius','i2'),])
    >>> 
    >>> a, b = np.loadtxt(fname, dtype=dt_3, skiprows=6, usecols=(1,5), unpack = True)
    >>> 
    >>> a
    array([b'H', b'He', b'Li', b'Be', b'B', b'C', b'N', b'O', b'F', b'Ne',
        b'Na', b'Mg', b'Al', b'Si', b'P'], 
        dtype='|S2')
    >>> 
    >>> b
    array([ 25,  30, 145, 105,  85,  70,  65,  60,  50,  40, 180, 150, 125,
        110, 100], dtype=int16)

[Содержание](#содержание)

## 1.3. Создание массивов записей

### core.records.array()
Создает массив записей из указанного объекта.

__numpy.core.records.array__

    numpy.core.records.array(object, dtype=None, shape=None, offset=0, strides=None, formats=None, names=None, titles=None, aligned=False, byteorder=None, copy=True)

Функция core.records.array() создает массив записей из массивов и других массиво-подобных объектов.

Параметры:
+ object - подобный массиву объект<br>
Список или кортеж, а так же любая функция или объект с методом, возвращаеющие список или кортеж.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ strides - кортеж целых чисел (необязательный)<br>
Целые числа определяют сколько байтов в памяти занимает каждый элемент массива.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например:

    ['U2','i2','f4','f2']. 

Указание типов данных напрямую, например:

    [int, complex, int, int, float]

не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. <br>При этом имена и псевдонимы эквивалентны, например, если имя полей массива
    a ['p', 'q'], 

а псевдонимы полей 

    ['p_prime', 'q-prime'],

то a['p'] эквивалентно a['p_prime'].

+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (dtype, order и т.д.)

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей, созданный из указанного объекта.

Смотрите так же: core.records.fromarrays, core.records.fromfile, core.records.fromrecords, core.records.fromstring

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> 
    >>> np.core.records.array(a)
    rec.array([[1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]], 
            dtype=int32)
    >>> 
    >>> b = [(1, 1), (2, 4), (3, 9)]
    >>> c = np.core.records.array(b, formats = ['i2', 'f2'], names = ('x', 'y'))
    >>> 
    >>> c
    rec.array([(1, 1.0), (2, 4.0), (3, 9.0)], 
            dtype=[('x', '<i2'), ('y', '<f2')])
    >>> 
    >>> c['x']
    array([1, 2, 3], dtype=int16)
    >>> 
    >>> c['y']
    array([ 1.,  4.,  9.], dtype=float16)

[Содержание](#содержание)

### core.records.fromarrays()
Создает массив записей из одномерных массивов.

__numpy.core.records.fromarrays__

    numpy.core.records.fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromarrays() создает массив записей из списка массивов.

Параметры:
+ arrayList - список массивов<br>
Список одномерных массивов с одинаковым количество элементов .
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей свормированный из списка массивов.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromrecords, core.records.fromstring

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array(['x1', 'x2', 'x3', 'x4'])
    >>> b = np.array([1, 2, 3, 4])
    >>> c = np.array(['y1', 'y2', 'y3', 'y4'])
    >>> d = np.array([1, 4, 9, 16])
    >>> 
    >>> rec = np.core.records.fromarrays([a,b,c,d],formats = ['U2','i2','U2','f2',], names='a,b,c,d')
    >>> 
    >>> 
    >>> rec
    rec.array([('x1', 1, 'y1', 1.0), ('x2', 2, 'y2', 4.0), ('x3', 3, 'y3', 9.0),
    ('x4', 4, 'y4', 16.0)], 
            dtype=[('a', '<U2'), ('b', '<i2'), ('c', '<U2'), ('d', '<f2')])
    >>> 
    >>> rec[1]
    ('x2', 2, 'y2', 4.0)
    >>> 
    >>> rec[2]
    ('x3', 3, 'y3', 9.0)
    >>> 
    >>> 
    >>> rec.a
    array(['x1', 'x2', 'x3', 'x4'], 
        dtype='<U2')
    >>> 
    >>> rec.b
    array([1, 2, 3, 4], dtype=int16)

[Содержание](#содержание)

### core.records.fromrecords()
Создает массив записей из списка записей в текстовой форме.

__numpy.core.records.fromrecords__

    numpy.core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromrecords() создает массив записей из списка записей.

Параметры:
+ recList - список записей<br>
Список записей с одинаковым количество элементов.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей сформированный из списка записей.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromarrays, core.records.fromstring

Замечание

Данные одного и того же поля могут быть абсолютно разными (гетерогенными), им будет присвоен наиболее общий тип данных. Данная функция удобна для создания небольших массивов записей. Если она используется для создания больших массивов записей, еще и без определения параметра formats (может определяться автоматически), то это может занять довольно много времени. Использование списка кортежей немного ускоряет процесс создания.

Примеры

    >>> import numpy as np
    >>> 
    >>> rec = np.core.records.fromrecords([('x1', 1, 'y1' ,1),
                                        ('x2', 2, 'y2', 4),
                                        ('x3', 3, 'y3', 9),
                                        ('x4', 4, 'y4', 16)],
                                        formats = ['U2', 'i2', 'U2', 'f2'],
                                        names='a, b, c, d')
    >>> 
    >>> rec
    rec.array([('x1', 1, 'y1', 1.0), ('x2', 2, 'y2', 4.0), ('x3', 3, 'y3', 9.0),
    ('x4', 4, 'y4', 16.0)], 
            dtype=[('a', '<U2'), ('b', '<i2'), ('c', '<U2'), ('d', '<f2')])
    >>> 
    >>> rec[1]
    ('x2', 2, 'y2', 4.0)
    >>> 
    >>> rec[2]
    ('x3', 3, 'y3', 9.0)
    >>> 
    >>> rec.a
    array(['x1', 'x2', 'x3', 'x4'], 
        dtype='<U2')
    >>> 
    >>> rec.b
    array([1, 2, 3, 4], dtype=int16)
    >>> 
    >>> rec.col1
    array([ 1.,  2.,  3.])
    >>> 
    >>> rec.col2
    array(['3.14', '-', '(5+2j)'], 
        dtype='<U32')


[Содержание](#содержание)

### core.records.fromstring()
Создает (только для чтения) массив записей из двоичных данных, находящихся в строке.

__numpy.core.records.fromstring__

    numpy.core.records.fromstring(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromstring() создает массив записей из двоичных данных, находящихся в строке.

Параметры:
+ datastring - строка<br>
Строка с двоичными данными.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается. Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Интерпретация двоичных данных в строке как массива записей.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromarrays, core.records.fromrecords

Замечание

Двоичные данные в строке разделяются на поля в соответствии с количеством байтов отведенным под каждое поле, т.е. если формат записи определен как formats = ['i2', 'i2'], то каждые 4 байта в строке будут интерпретироваться как одна запись массива.

Примеры

    >>> a = b'\x01\x00\x02\x00'
    >>> np.core.records.fromstring(a, formats = ['i2', 'i2'], names = 'x, y')
    rec.array([(1, 2)], 
            dtype=[('x', '<i2'), ('y', '<i2')])
    >>> 
    >>> a = b'\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00'
    >>> 
    >>> rec1 = np.core.records.fromstring(a, formats = ['i2', 'i2'], names = 'x, y')
    >>> 
    >>> rec1
    rec.array([(1, 2), (3, 4), (5, 6)], 
            dtype=[('x', '<i2'), ('y', '<i2')])
    >>> 
    >>> rec2 = np.core.records.fromstring(a, formats = ['i2', 'i4'], names = 'x, y')
    >>> rec2
    rec.array([(1, 196610), (4, 393221)], 
            dtype=[('x', '<i2'), ('y', '<i4')])
    >>>
    >>> rec1.x
    array([1, 3, 5], dtype=int16)
    >>> 
    >>> rec2.y
    array([196610, 393221])

[Содержание](#содержание)

### core.records.fromfile()
Создает массив записей из файла с двоичными данными.

__numpy.core.records.fromfile__

    numpy.core.records.fromfile(fd, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromfile() создает массив записей из двоичных данных, находящихся в файле.

Параметры:
+ fd - файловый объект<br>
Объект файла, который поддерживает произвольный доступ.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается. Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Интерпретация двоичных данных в файле как массива записей.

Смотрите так же: core.records.array, core.records.fromstring, core.records.fromarrays, core.records.fromrecords

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([('x1', 1), ('x2', 2), ('x3', 3),], dtype = 'U2,f4')
    >>> 
    >>> a
    array([('x1', 1.0), ('x2', 2.0), ('x3', 3.0)], 
        dtype=[('f0', '<U2'), ('f1', '<f4')])
    >>> 
    >>> a.tofile('file_name')    #  Помещаем 'a' в двоичный файл
    >>> 
    >>>
    >>> #  Создание массива записей из данных в двоичном файле
    ... rec = np.core.records.fromfile('file_name', formats='U2,f4', names = 'x, n')
    >>> rec
    rec.array([('x1', 1.0), ('x2', 2.0), ('x3', 3.0)], 
            dtype=[('x', '<U2'), ('n', '<f4')])
    >>> 
    >>> rec.x
    array(['x1', 'x2', 'x3'], 
        dtype='<U2')
    >>> rec.n
    array([ 1.,  2.,  3.], dtype=float32)

[Содержание](#содержание)

## 1.4. Создание массивов символов

### core.defchararray.array()
Создает массив символов chararray.

__numpy.core.defchararray.array__

    numpy.core.defchararray.array(obj, itemsize=None, copy=True, unicode=None, order=None)

Функция core.defchararray.array() создает массив символов.

Параметры:
+ obj - последовательность строк<br>
Любая последовательность, которая может быть интерпретирована как массив или сам массив NumPy значениями которого являются строки, в том числе и строки символов юникода.
+ itemsize - целое число (необязательный)<br>
Определяет количество символов на элемент результирующего массива. Определяется автоматически если itemsize=None и obj - массив или последовательность Python. Если параметр itemsize указан и obj является строкой, то obj будет разбит на указанное в itemsize количество частей.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (itemsize, unicode и т.д.)
+ unicode - False или True (необязательный)<br>
Если unicode = True, то результирующий массив может содержать символы юникода, если unicode = False, то только 8-битные символы. Если unicode = None то этот параметр, в зависимости от obj, будет определен автоматически.
+ order - 'C', 'F' или 'A' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'.

Возвращает:
+ результат - массив символов NumPy<br>
Массив символов, созданный из указанного объекта.

Смотрите так же: core.defchararray.asarray

Замечание

Эта функция предназначена для обратной совместимости со старыми версиями Numarray. Для быстрых векторных строков операций лучше использовать numpy.char.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = 'abcdef'
    >>> np.core.defchararray.array(a)
    chararray(['abcdef'], 
        dtype='<U6')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 1)
    chararray(['a', 'a', 'a', 'a', 'a', 'a'], 
        dtype='<U1')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 2)
    chararray(['ab', 'ab', 'ab'], 
        dtype='<U2')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 3)
    chararray(['abc', 'abc'], 
        dtype='<U3')
    >>> 
    >>> 
    >>> a = ['a', 'b', 'c']
    >>> np.core.defchararray.array(a)
    chararray(['a', 'b', 'c'], 
        dtype='<U1')
    >>> 
    >>> 
    >>> d = [['a', 'b'], ['c', 'd']]
    >>> np.core.defchararray.array(d)
    chararray([['a', 'b'],
        ['c', 'd']], 
        dtype='<U1')
    >>>
    >>> # Пробелы с конца строки убираются автоматически
    ... d = [[' a ', ' b '], [' c ', ' d ']]
    >>> np.core.defchararray.array(d)
    chararray([[' a', ' b'],
        [' c', ' d']], 
        dtype='<U3')

[Содержание](#содержание)

### core.defchararray.asarray()
Преобразует последовательность в массив символов chararray.

__numpy.core.defchararray.asarray__

    numpy.core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)

Функция core.defchararray.asarray() преобразует входные данные в массив символов, при этом данные копируются только если эти входные данные уже не являются массивом символов.

Параметры:
+ obj - некоторая последовательность строк<br>
Входные данные которые могут быть преобразованы в массив символов: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ itemsize - целое число (необязательный)<br>
Определяет количество символов на элемент результирующего массива. Определяется автоматически если itemsize=None и obj - массив или последовательность Python. Если параметр itemsize указан и obj является строкой, то obj будет разбит на указанное в itemsize количество частей.
+ unicode - False или True (необязательный)<br>
Если unicode = True, то результирующий массив может содержать символы юникода, если unicode = False, то только 8-битные символы. Если unicode = None то этот параметр, в зависимости от obj, будет определен автоматически.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив символов, созданный из указанного объекта.

Смотрите так же: core.defchararray.array

Замечание

Эта функция предназначена для обратной совместимости со старыми версиями Numarray. Для быстрых векторных строков операций лучше использовать numpy.char.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = ['a', 'b', 'c']
    >>>
    >>> np.core.defchararray.asarray(a)
    chararray(['a', 'b', 'c'], 
        dtype='<U1')
    >>> 
    >>> a = [(['a', 'b'], ['c', 'd']), (['d', 'c'], ['b', 'a'])]
    >>> 
    >>> np.core.defchararray.asarray(a)
    chararray([[['a', 'b'],
            ['c', 'd']],

        [['d', 'c'],
            ['b', 'a']]], 
        dtype='<U1')

[Содержание](#содержание)

## 1.5. Числовые диапазоны

### arange()
Возвращает одномерный массив с равномерно распределенными значениями внутри указанного интервала.

__numpy.arange__

    numpy.arange([start, ]stop, [step, ]dtype=None)

Функция arange() возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала.

Параметры:
+ start - число (необязательный)<br>
Число, которое является началом интервала. По умолчанию равно 0.
+ stop - число<br>
Определяет конец интервала, при этом сам интервал это значение не включает. Если шаг (step) не является целым числом, то в некоторых случаях, из-за округление вещественных чисел указанное значение stop может оказаться включенным в интервал.
+ step - число (необязательный)<br>
Определяет интервал между значениями. По умолчанию равен 1. Если данный параметр указан, то значение start так же необходимо указать.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Массив равномерно разнесенных значений.

Смотрите так же: linspace, logspace, geomspace

Замечание

Интервал является полуоткрытым [start, stop), т.е. включает в себя значение start, но не включает значение stop. Если в качестве аргументов указаны вещественные числа, то длинна результата будет равна ceil((stop - start)/step). Из-за округления вещественных чисел, последний элемент выходного массива может оказаться больше значения stop.

Примеры

    >>> import numpy as np
    >>> 
    >>> np.arange(7)
    array([0, 1, 2, 3, 4, 5, 6])
    >>> 
    >>> np.arange(7.)
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.])
    >>> 
    >>> np.arange(15,22)
    array([15, 16, 17, 18, 19, 20, 21])
    >>> 
    >>> np.arange(10,30,2)
    array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28])
    >>> 
    >>> np.arange(0.1, 2.2, 0.3)
    array([ 0.1,  0.4,  0.7,  1. ,  1.3,  1.6,  1.9,  2.2])

[Содержание](#содержание)

### linspace()
Возвращает одномерный массив с равномерно распределенными значениями внутри указанного интервала.

__numpy.linspace__

    numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

Функция linspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны внутри заданного интервала.

Параметры:
+ start - число<br>
Число, которое является началом последовательности.
+ stop - число<br>
Число, которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение stop включается в интервал и является последним. В противном случае stop не входит в интервал. По умолчанию endpoint = True
+ retstep - True или False (необязательный)<br>
Если retstep = True, то будет возвращено значение шага между элементами.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра endpoint равномерно распределенны внутри закрытого ([start, stop]) или полуоткрытого ([start, stop)) интервала.
+ шаг - вещественное число (необязательно)<br>
Значение шага между элементами. Возвращается только в том случае, если retstep = True.

Смотрите так же: arange, logspace, geomspace

Примеры

    >>> np.linspace(0, 1)
    array([0.        , 0.02040816, 0.04081633, ..., 0.95918367, 0.97959184,
        1.        ])
    >>> 
    >>> np.linspace(0, 1, num = 5)
    array([0.  , 0.25, 0.5 , 0.75, 1.  ])
    >>> 
    >>> np.linspace(0, 1, num = 5, endpoint = False)
    array([0. , 0.2, 0.4, 0.6, 0.8])
    >>> 
    >>> np.linspace(0, 1, num = 5, endpoint = False, retstep = True)
    (array([0. , 0.2, 0.4, 0.6, 0.8]), 0.2)
    >>>
    >>>
    >>> #  На равные промежутки можно разбивать
    >>> #  интервалы комплексных чисел:
    >>> x = np.linspace(0+0j, 4+4j, 5)
    >>> x
    array([0.+0.j, 1.+1.j, 2.+2.j, 3.+3.j, 4.+4.j])

[Содержание](#содержание)

### logspace()
Возвращает одномерный массив значений, равномерно распределенных по логарифмической шкале.

__numpy.logspace__

    numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)

Функция logspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны по логарифмической шкале внутри заданного интервала.

Параметры:
+ start - вещественное число<br>
Число, которое является началом последовательности, которое равно base ** start (base в степени start).
+ stop - вещественное число<br>
Число (base ** stop), которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение base ** stop включается в интервал и является последним. В противном случае base ** stop не входит в интервал. По умолчанию endpoint = True
+ base - вещественное число (необязательный)<br>
Основание логарифмической шкалы. По умолчанию base = 10.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра ndpoint равномерно распределенны по логарифмической шкале внутри закрытого ([base ** start, base ** stop]) или полуоткрытого ([base ** start, base ** stop)) интервала.

Смотрите так же: arange, linspace, geomspace

Примеры

    >>> np.logspace(0, 3)
    array([   1.        ,    1.1513954 ,    1.32571137, ...,  754.31200634,
            868.51137375, 1000.        ])
    >>> 
    >>> np.logspace(0, 3, num = 10)
    array([   1.        ,    2.15443469,    4.64158883,   10.        ,
            21.5443469 ,   46.41588834,  100.        ,  215.443469  ,
            464.15888336, 1000.        ])
    >>> 
    >>> np.logspace(0, 3, num = 10, endpoint = False)
    array([  1.        ,   1.99526231,   3.98107171,   7.94328235,
            15.84893192,  31.6227766 ,  63.09573445, 125.89254118,
        251.18864315, 501.18723363])
    >>> 
    >>> np.logspace(0, 10, num = 10, base = 2)
    array([1.00000000e+00, 2.16011948e+00, 4.66611616e+00, 1.00793684e+01,
        2.17726400e+01, 4.70315038e+01, 1.01593667e+02, 2.19454460e+02,
        4.74047853e+02, 1.02400000e+03])
    >>> 
    >>> np.logspace(0, 10, num = 10, base = np.e)
    array([1.00000000e+00, 3.03773178e+00, 9.22781435e+00, 2.80316249e+01,
        8.51525577e+01, 2.58670631e+02, 7.85771994e+02, 2.38696456e+03,
        7.25095809e+03, 2.20264658e+04])

[Содержание](#содержание)

### geomspace()
Возвращает одномерный массив значений, которые представляют собой геометрическую прогрессию.

__numpy.geomspace__
    
    numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None)

Функция geomspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны по шкале геометрической прогрессии внутри заданного интервала.

Параметры:
+ start - число<br>
Число, которое является началом последовательности.
+ stop - число<br>
Число, которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение stop включается в интервал и является последним. В противном случае stop не входит в интервал. По умолчанию endpoint = True
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра ndpoint равномерно распределенны по шкале геометрической прогрессии внутри закрытого ([start, stop]) или полуоткрытого ([start, stop)) интервала.

Смотрите так же: arange, linspace, logspace

Замечание

Если входные параметры или параметр dtype являются комплексными числами, то значения элементов выходного массива будут расположены на логарифмической спирали в комплексной плоскости. Через две точки может проходить бесконечное количество спиралей, но значения будут расположены на той спирали, которая соединяет точки кратчайшим образом.

Примеры

    >>> np.geomspace(1, 32)
    array([ 1.        ,  1.07329065,  1.15195282, ..., 27.77891541,
        29.81485021, 32.        ])
    >>> 
    >>> np.geomspace(1, 32, num = 6)
    array([ 1.,  2.,  4.,  8., 16., 32.])
    >>> 
    >>> np.geomspace(1, 32, num = 6, endpoint = False)
    array([ 1.        ,  1.78179744,  3.1748021 ,  5.65685425, 10.0793684 ,
        17.95939277])

[Содержание](#содержание)

### meshgrid()
Создает список массивов координатных сеток.

__numpy.meshgrid__
    
    numpy.meshgrid(x1, x2,..., xn, **kwargs)

Функция meshgrid() создает список массивов координатных сеток N-мерного координатного пространства для указанных одномерных массивов координатных векторов. Координатное пространство - это пространство N-мерных точек-координат, причем каждой точке в таком пространстве соответствует комбинация одного значения из каждого координатного массива.

Параметры:
+ x1, x2,..., xn - последовательность<br>
Одномерные массивы, которые определяют координатную сетку.
+ indexing - ‘xy’, ‘ij’ (необязательный)<br>
Определяет декартово ‘xy’ (по умолчанию) или матричное ‘ij’ индексирование выходного массива.
+ sparse - True или False (необязательный)<br>
Если True, то для экономии памяти выводятся сжатые до одной оси массивы координатных сеток. По умолчанию sparse = False.
+ copy - True или False (необязательный)<br>
Если False, то для экономии памяти возвращается представление исходных координатных массивов. По умолчанию copy = True.

Возвращает:
+ [X1, X2, X3, ... , Xn] - список массивов NumPy<br>
Для N входных одномерных координатных векторов возвращается список массивов координатных cеток. <br>Если длинна координатных массивов len(x1) = L1; len(x2) = L2; len(xN) = LN, то при indexing = 'ij' размеры массивов координатных сеток будут равны (L1, L2, L3, ... , LN). <br>В случае, если параметр indexing = 'xy', то размеры массивов координатных сеток будут (L2, L1, L3, ... , LN), при этом повторение элементов так же окажется несколько инным.

В двумерном случае, когда длинна массива x1 равна M, а длинна вектора x2 равна N, то при indexing = 'xy' размеры массивов координатных сеток будут равны (N, M), а при indexing = 'ij' (M, N).

Допускаются случаи 0-мерного и 1-мерного пространства.

Смотрите так же: mgrid, ogrid

Замечание

Важно помнить, что если параметры sparse и copy равны False, то скорее всего будут возвращеные несмежные массивы. Кроме того, к одной ячейке памяти могут относиться несколько элементов транслируемого массива.

Примеры

    >>> import numpy as np
    >>> 
    >>> x = [1, 2, 3, 4, 5]
    >>> 
    >>> y = [0, 5, 10, 15, 20, 25, 30]
    >>> 
    >>> #  Список координатных сеток:
    ... XY = np.meshgrid(x, y)
    >>> XY
    [array([[1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5]]),
    array([[ 0,  0,  0,  0,  0],
        [ 5,  5,  5,  5,  5],
        [10, 10, 10, 10, 10],
        [15, 15, 15, 15, 15],
        [20, 20, 20, 20, 20],
        [25, 25, 25, 25, 25],
        [30, 30, 30, 30, 30]])]
    >>>
    >>> # Распаковка координатных сеток в отдельные массивы
    ... xy_grid, yx_grid = np.meshgrid(x, y)
    >>> 
    >>> xy_grid
    array([[1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5]])
    >>> 
    >>> xy_grid.shape, len(x), len(y)
    ((7, 5), 5, 7)
    >>> 
    >>> yx_grid
    array([[ 0,  0,  0,  0,  0],
        [ 5,  5,  5,  5,  5],
        [10, 10, 10, 10, 10],
        [15, 15, 15, 15, 15],
        [20, 20, 20, 20, 20],
        [25, 25, 25, 25, 25],
        [30, 30, 30, 30, 30]])
    >>> 
    >>> yx_grid.shape, len(x), len(y)
    ((7, 5), 5, 7)

Установка параметра indexing в значение 'ij', приводит к тому, что размеры массивов координатных сеток меняются, при этом несколько меняется и порядок повторения элементов:

    >>> x = [1, 2]
    >>> y = [0, 5, 10]
    >>> z = [0, 0.1, 0.2, 0.3]
    >>> 
    >>> XYZ_indexingXY = np.meshgrid(x, y, z)
    >>> XYZ_indexingXY
    [array([[[1, 1, 1, 1],
            [2, 2, 2, 2]],

            [[1, 1, 1, 1],
            [2, 2, 2, 2]],

            [[1, 1, 1, 1],
            [2, 2, 2, 2]]]), 

    array([[[ 0,  0,  0,  0],
            [ 0,  0,  0,  0]],

        [[ 5,  5,  5,  5],
            [ 5,  5,  5,  5]],

        [[10, 10, 10, 10],
            [10, 10, 10, 10]]]), 
            
    array([[[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]]])]
    >>> 
    >>>
    >>> XYZ_indexingIJ = np.meshgrid(x, y, z, indexing = 'ij')
    >>> XYZ_indexingIJ
    [array([[[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]],

            [[2, 2, 2, 2],
            [2, 2, 2, 2],
            [2, 2, 2, 2]]]), 
            
    array([[[ 0,  0,  0,  0],
            [ 5,  5,  5,  5],
            [10, 10, 10, 10]],

        [[ 0,  0,  0,  0],
            [ 5,  5,  5,  5],
            [10, 10, 10, 10]]]), 

    array([[[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]]])]
    >>> 
    >>> XYZ_indexingXY[0].shape, XYZ_indexingXY[1].shape, XYZ_indexingXY[2].shape
    ((3, 2, 4), (3, 2, 4), (3, 2, 4))
    >>> 
    >>> XYZ_indexingIJ[0].shape, XYZ_indexingIJ[1].shape, XYZ_indexingIJ[2].shape
    ((2, 3, 4), (2, 3, 4), (2, 3, 4))

В случае большого количества длинных координатных векторов, результирующий массив координатного пространства будет иметь огромное количество элементов и, соответственно, занимать много памяти. В этом легко убедиться даже на трех небольших массивах:

    >>> x = [1, 2, 3]
    >>> y = [0, 5, 10, 15]
    >>> z = [0, 0.1, 0.2, 0.3, 0.4]
    >>> 
    >>> XYZ = np.meshgrid(x, y, z)
    >>> XYZ
    [array([[[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]]]),
    array([[[ 0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0]],

        [[ 5,  5,  5,  5,  5],
            [ 5,  5,  5,  5,  5],
            [ 5,  5,  5,  5,  5]],

        [[10, 10, 10, 10, 10],
            [10, 10, 10, 10, 10],
            [10, 10, 10, 10, 10]],

        [[15, 15, 15, 15, 15],
            [15, 15, 15, 15, 15],
            [15, 15, 15, 15, 15]]]),
    array([[[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]]])]

Установка параметра sparse в значение True может значительно снизить затраты памяти. В результате мы получим массивы сеток сжатые до одной оси, т.е. лишь одна ось в таком массиве имеет длинну большую 1. При этом, сами массивы могут быть легко транслированы относительно друг друга:

    >>> x = [1, 2, 3, 4, 5]
    >>> y = [0, 5, 10, 15, 20, 25, 30, 35, 40]
    >>> z = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.]
    >>> 
    >>> XYZ = np.meshgrid(x, y, z, sparse = True)
    >>> XYZ
    [array([[[1],
            [2],
            [3],
            [4],
            [5]]]),

    array([[[ 0]],

        [[ 5]],

        [[10]],

        [[15]],

        [[20]],

        [[25]],

        [[30]],

        [[35]],

        [[40]]]),

    array([[[ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ]]])]
    >>>
    >>> 
    >>> XYZ[0].shape, XYZ[1].shape, XYZ[2].shape
    ((1, 5, 1), (9, 1, 1), (1, 1, 11))
    >>> 

[Содержание](#содержание)

### mgrid[]
Возвращает массив плотных координатных сеток

__numpy.mgrid__

    numpy.mgrid[index object] = <numpy.lib.index_tricks.nd_grid object>

Функция mgrid() возвращает массив плотных координатных сеток N-мерного координатного пространства для указанных в виде диапазонов одномерных массивов координатных векторов.

Параметры:
+ index object - объект индексации<br>
Под объектом индексации понимается список из двух или трех элементов, например [0:5] или [0:5:10j]. Если элементов в списке всего два, то это интерпретируется как полуоткрытый интервал [start, ... , stop), в котором все элементы отличаются на 1, а значение stop в сам интервал не входит. В качестве третьего элемента указывается мнимая часть комплексного числа, которое указывает на количество равномерно разнесенных элементов внутри закрытого интервала [start, ... , stop], при этом значение stop попадает в интервал.

Возвращает:
+ результат - массив NumPy<br>
Массив плотных координатных сеток N-мерного координатного пространства, количество и размеры которых зависят от указанных диапазонов.

Смотрите так же: meshgrid, ogrid

Примеры

    >>> import numpy as np
    >>> 
    >>> np.mgrid[0:4, 4:8]
    array([[[0, 0, 0, 0],
            [1, 1, 1, 1],
            [2, 2, 2, 2],
            [3, 3, 3, 3]],

        [[4, 5, 6, 7],
            [4, 5, 6, 7],
            [4, 5, 6, 7],
            [4, 5, 6, 7]]])
    >>> 
    >>> np.mgrid[0:0.9:10j]
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
    >>>
    >>> np.mgrid[0:15:6j]
    array([  0.,   3.,   6.,   9.,  12.,  15.])
    >>> 
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])
    >>>
    >>>
    >>> x, y = np.mgrid[0:0.8:5j, 0:15:4j]
    >>> x
    array([[ 0. ,  0. ,  0. ,  0. ],
        [ 0.2,  0.2,  0.2,  0.2],
        [ 0.4,  0.4,  0.4,  0.4],
        [ 0.6,  0.6,  0.6,  0.6],
        [ 0.8,  0.8,  0.8,  0.8]])
    >>> y
    array([[  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.]])

Замечание

Функции meshgrid, mgrid и ogrid очень похожи друг на друга. meshgrid является самой гибкой, mgrid выдает только плотные массивы координатных сеток, а ogrid только сжатые до одной оси. При этом функция mgrid может быть легко переопределена в функцию ogrid:

    >>> np.mgrid = np.lib.index_tricks.nd_grid(sparse=True)
    >>>
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]
    >>>
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]

[Содержание](#содержание)

### ogrid[]
Возвращает открытую сетку значений.

__numpy.ogrid__

    numpy.ogrid[index object] = <numpy.lib.index_tricks.nd_grid object>

Функция ogrid() возвращает массив сжатых координатных сеток N-мерного координатного пространства для указанных в виде диапазонов одномерных массивов координатных векторов.

Параметры:
+ index object - объект индексации<br>
Под объектом индексации понимается список из двух или трех элементов, например [0:5] или [0:5:10j]. Если элементов в списке всего два, то это интерпретируется как полуоткрытый интервал [start, ... , stop), в котором все элементы отличаются на 1, а значение stop в сам интервал не входит. В качестве третьего элемента указывается мнимая часть комплексного числа, которое указывает на количество равномерно разнесенных элементов внутри закрытого интервала [start, ... , stop], при этом значение stop попадает в интервал.

Возвращает:
+ результат - массив NumPy<br>
Массив сжатых до одной оси координатных сеток N-мерного координатного пространства, таких что только одна ось (размерность) содержит количество элементов большее 1.

Смотрите так же: meshgrid, mgrid

Примеры

    >>> import numpy as np
    >>> 
    >>> np.ogrid[0:4, 4:8]
    [array([[0],
        [1],
        [2],
        [3]]), array([[4, 5, 6, 7]])]
    >>> 
    >>> np.ogrid[0:0.9:10j]
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
    >>> 
    >>> np.ogrid[0:15:6j]
    array([  0.,   3.,   6.,   9.,  12.,  15.])
    >>> 
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]
    >>> 
    >>> x, y = np.ogrid[0:0.8:5j, 0:15:4j]
    >>> 
    >>> x
    array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]])
    >>>
    >>> y
    array([[  0.,   5.,  10.,  15.]])
    >>> 
    >>> x.shape, y.shape
    ((5, 1), (1, 4))

Замечание

Функции meshgrid, mgrid и ogrid очень похожи друг на друга. meshgrid является самой гибкой, mgrid выдает только плотные массивы координатных сеток, а ogrid только сжатые до одной оси. Если диапазонов много и сами они очень велики, то результат функции mgrid может потребовать очень много памяти, чего нельзя сказать о функции ogrid, массивы которой сжаты и могут быть легко транслированы относительно друг друга. Однако, сама функция ogrid может быть легко переопределена в функцию mgrid:

    >>> np.ogrid = np.lib.index_tricks.nd_grid(sparse=False)
    >>> 
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])
    >>> 
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])

## 1.6. Создание матриц

[Содержание](#содержание)

### mat()
Преобразует входную последовательность в матрицу.

__numpy.mat__

    numpy.mat(object, dtype=None)

Функция mat() интерпретирует входные данные как матрицу.

Параметры:
+ object - подобный матрице объект<br>
Строка, список или кортеж, а так же любая функция или объект с методом, возвращаеющие список или кортеж, которые могут быть интерпретированы как матрица.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходной матрицы.

Возвращает:
+ matrix - массив NumPy<br>
Интерпретация входных данных как матрицы.

Смотрите так же: bmat

Замечание

Входные данные могут быть интерпретированы, как матрицы, только если из них возможно построить одномерный или двумерный прямоугольный (квадратный) массив.

Просто отформатированные строки, например такие как '1 1; 2 2', '1, 1; 2, 2' или '1,1;2,2' тоже могут интерпретироваться как матрицы.

В отличие от функций matrix и asmatrix, функция mat не делает копию данных если входные данные уже являются массивом NumPy или матрицей. Эквивалентна matrix(data, copy=False).

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Создание матриц из строк
    ...
    >>> np.mat('1 1 1 1')
    matrix([[1, 1, 1, 1]])
    >>>
    >>> np.mat('1, 1, 1, 1')
    matrix([[1, 1, 1, 1]])
    >>>
    >>> np.mat('1, 1, 1, 1')
    matrix([[1, 1, 1, 1]])
    >>>
    >>> np.mat('1, 1; 1, 1')
    matrix([[1, 1],
            [1, 1]])
    >>>
    >>> 
    >>> a = [1, 2, 3, 4, 5]
    >>> 
    >>> b = np.mat(a)
    >>> b
    matrix([[1, 2, 3, 4, 5]])
    >>> 
    >>>
    >>> #  Если входные данные не являются массивом или матрицей,
    ... #  то входные данные копируются.
    ...
    >>> a[0] = 111    #  Изменение списка 'a' не отразится 
    >>> a
    [111, 2, 3, 4, 5]
    >>>
    >>> b             #  не отразится на матрице 'b'.
    matrix([[1, 2, 3, 4, 5]])
    >>> 
    >>> 
    >>> #  Если входные данные являются массивом или матрицей,
    ... #  то входные данные не копируются.
    ...
    >>> a = np.array([[1, 1], [2, 2]])
    >>> a
    array([[1, 1],
        [2, 2]])
    >>> 
    >>> b = np.mat(a)
    >>> b
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> a[0] = 77    #  Изменение массива 'a' не отразится
    >>> a
    array([[77, 77],
        [ 2,  2]])
    >>> 
    >>> b            #  отразится на матрице 'b'.
    matrix([[77, 77],
            [ 2,  2]])

[Содержание](#содержание)

### bmat()
Создает матрицу из строки, вложенной последовательности или массива.

__numpy.bmat__

    numpy.bmat(object, ldict=None, gdict=None)

Функция bmat() создает матрицу из массивов-подблоков.

Параметры:
+ object - строка или подобный массиву объект<br>
Входные данные с перечислением необходимого порядка массивов-подблоков.
+ ldict - словарь (необязательный)<br>
Словарь, который заменяет локальные операнды в текущей строке. Игнорируется, если obj не является строкой или gdict=None.
+ gdict - словарь (необязательный)<br>
Словарь, который заменяет глобальные операнды в текущей строке. Игнорируется, если obj не является строкой.

Возвращает:
+ matrix - матрица NumPy<br>
Интерпретация входных данных как матрицы.

Смотрите так же: mat

Примеры

    >>> import numpy as np
    >>> a = [1, 1]
    >>> b = [2, 2]
    >>> np.bmat([[a], [b]])
    matrix([[1, 1, 2, 2]])
    >>>
    >>> np.bmat([[[a], [b]], [[a], [b]]])
    matrix([[1, 1, 2, 2],
            [1, 1, 2, 2]])
    >>> 
    >>> 
    >>> a = np.arange(0, 4).reshape(2, 2)
    >>> a
    array([[0, 1],
        [2, 3]])
    >>> b = np.arange(4, 8).reshape(2, 2)
    >>> b
    array([[4, 5],
        [6, 7]])
    >>> c = np.arange(8, 12).reshape(2, 2)
    >>> c
    array([[ 8,  9],
        [10, 11]])
    >>> d = np.arange(12, 16).reshape(2, 2)
    >>> d
    array([[12, 13],
        [14, 15]])
    >>> 
    >>> np.bmat([[a, b],[c, d]])
    matrix([[ 0,  1,  4,  5],
            [ 2,  3,  6,  7],
            [ 8,  9, 12, 13],
            [10, 11, 14, 15]])
    >>> 
    >>> np.bmat('a b; c d')
    matrix([[ 0,  1,  4,  5],
            [ 2,  3,  6,  7],
            [ 8,  9, 12, 13],
            [10, 11, 14, 15]])
    >>> 
    >>> np.bmat([a, b, c, d])
    matrix([[ 0,  1,  4,  5,  8,  9, 12, 13],
            [ 2,  3,  6,  7, 10, 11, 14, 15]])
    >>>
    >>> np.bmat('a b c d')
    matrix([[ 0,  1,  4,  5,  8,  9, 12, 13],
            [ 2,  3,  6,  7, 10, 11, 14, 15]])
    >>> 
    >>> np.bmat([[a], [b], [c], [d]])
    matrix([[ 0,  1],
            [ 2,  3],
            [ 4,  5],
            [ 6,  7],
            [ 8,  9],
            [10, 11],
            [12, 13],
            [14, 15]])
    >>>
    >>> np.bmat('a; b; c; d')
    matrix([[ 0,  1],
            [ 2,  3],
            [ 4,  5],
            [ 6,  7],
            [ 8,  9],
            [10, 11],
            [12, 13],
            [14, 15]])
    >>>
    >>>
    >>> np.bmat('a b c d',
                ldict = {'a':a, 'b':b, 'c':c,'d':d},
                gdict = {'a':a, 'b':b, 'c':c, 'd':d})
    matrix([[ 0,  1,  4,  5,  8,  9, 12, 13],
            [ 2,  3,  6,  7, 10, 11, 14, 15]])
    >>>
    >>> np.bmat('a b c d', 
                ldict = {'a':a, 'b':a, 'c':a, 'd':a}, 
                gdict = {'a':a, 'b':a, 'c':a, 'd':a})
    matrix([[0, 1, 0, 1, 0, 1, 0, 1],
            [2, 3, 2, 3, 2, 3, 2, 3]])
    >>>
    >>> r = np.zeros((2, 2), dtype = int)
    >>> r
    array([[0, 0],
        [0, 0]])
    >>>
    >>> np.bmat('a b c d', ldict = {'a':r, 'b':a, 'c':r, 'd':a}
                        gdict = {'a':r, 'b':a, 'c':r, 'd':a})
    matrix([[0, 0, 0, 1, 0, 0, 0, 1],
            [0, 0, 2, 3, 0, 0, 2, 3]])

[Содержание](#содержание)

### diag()
Извлекает диагональ из массива, а так же позволяет строить диагональные массивы.

__numpy.diag__

    numpy.diag(v, k=0)

Функция diag() позволяет извлекать диагональ из массива, а так же строить диагональные массивы из одномерных массивов.

Параметры:
+ v - подобный массиву объект<br>
Двумерные или одномерные массивы, матрицы, списки или кортежи, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.

Возвращает:
+ ndarray - массив NumPy<br>
Указанная диагональ массива или диагональный массив из указанного одномерного массива.

Смотрите так же: eye, diagflat, tri, tril, triu

Замечание

Если в качестве параметра v указан двумерный массив, то будет извлечена его диагональ. Если v это одномерный массив, то из него будет построен диагональный массив.

Возвращает ли данная функция копию или представление данных исходного массива зависит от того какую версию NumPy вы используете.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]])
    >>> a
    array([[1, 2, 3, 4],
        [4, 1, 2, 3],
        [3, 4, 1, 2],
        [2, 3, 4, 1]])
    >>> 
    >>> np.diag(a)
    array([1, 1, 1, 1])
    >>> 
    >>> np.diag(a, k=1)
    array([2, 2, 2])
    >>> 
    >>> np.diag(a, k=-1)
    array([4, 4, 4])
    >>> 
    >>> 
    >>> np.diag(np.diag(a))
    array([[1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]])
    >>> 
    >>> np.diag(np.diag(a, k=1))
    array([[2, 0, 0],
        [0, 2, 0],
        [0, 0, 2]])
    >>> 
    >>> np.diag(np.diag(a, k=-1))
    array([[4, 0, 0],
        [0, 4, 0],
        [0, 0, 4]])
    >>> 
    >>> 
    >>> #  Диагональный массив можно построить 
    ... #  на основании имеющегося одномерного массива:
    ... a = np.array([1, 2, 3, 4, 5, 6])
    >>> a
    array([1, 2, 3, 4, 5, 6])
    >>> 
    >>> np.diag(a)
    array([[1, 0, 0, 0, 0, 0],
        [0, 2, 0, 0, 0, 0],
        [0, 0, 3, 0, 0, 0],
        [0, 0, 0, 4, 0, 0],
        [0, 0, 0, 0, 5, 0],
        [0, 0, 0, 0, 0, 6]])

[Содержание](#содержание)

### diagflat()
Создает диагональный массив из элементов указанного массива.

__numpy.diagflat__

numpy.diagflat(v, k=0)

Функция diagflat() сжимает входной массив до одной оси и строит из него диагональный массив.

Параметры:
+ v - подобный массиву объект<br>
Двумерные или одномерные массивы, матрицы, списки или кортежи, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.

Возвращает:
+ ndarray - массив NumPy<br>
Двумерный диагональный массив.

Смотрите так же: eye, diag, tri, tril, triu

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3])
    >>> 
    >>> np.diagflat(a)
    array([[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]])
    >>> 
    >>> np.diagflat(a, k=1)
    array([[0, 1, 0, 0],
        [0, 0, 2, 0],
        [0, 0, 0, 3],
        [0, 0, 0, 0]])
    >>> 
    >>> np.diagflat(a, k=-1)
    array([[0, 0, 0, 0],
        [1, 0, 0, 0],
        [0, 2, 0, 0],
        [0, 0, 3, 0]])
    >>> 
    >>> b = np.array([[1, 3], [2, 4]])
    >>> b
    array([[1, 3],
        [2, 4]])
    >>> 
    >>> np.diagflat(b)
    array([[1, 0, 0, 0],
        [0, 3, 0, 0],
        [0, 0, 2, 0],
        [0, 0, 0, 4]])
    >>> 
    >>> np.diagflat(b, k=1)
    array([[0, 1, 0, 0, 0],
        [0, 0, 3, 0, 0],
        [0, 0, 0, 2, 0],
        [0, 0, 0, 0, 4],
        [0, 0, 0, 0, 0]])
    >>> 
    >>> c = np.array([[1], [3], [4], [5]])
    >>> c
    array([[1],
        [3],
        [4],
        [5]])
    >>> 
    >>> np.diagflat(c)
    array([[1, 0, 0, 0],
        [0, 3, 0, 0],
        [0, 0, 4, 0],
        [0, 0, 0, 5]])

[Содержание](#содержание)

### tri()
Создает массив у которого все элементы ниже указанной диагонали равны 1, а все остальные равны 0.

__numpy.tri__

    numpy.tri(N, M=None, k=0, dtype=<type 'float'>)

Функция tri() возвращает треугольный массив в котором на заданной диагонали и ниже ее расположены единицы, а выше нее расположены нули.

Параметры:
+ N - целое число<br>
Задает количество строк выходного массива.
+ M - целое число (необязательный)<br>
Задает количество столбцов выходного массива. Если M = None (по умолчанию), то M = N
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. По умолчанию float

Возвращает:
+ ndarray - массив NumPy<br>
Треугольный массив T c размерами (N x M). Элементы которого на главной диагонали и под ней равны 1, а остальные равны 0. То есть T[i,j] = 1 если i <= j + k и 0 в противном случае.

Смотрите так же: eye, diag, diagflat, tril, triu

Примеры

    >>> import numpy as np
    >>> 
    >>> np.tri(4)
    array([[ 1.,  0.,  0.,  0.],
        [ 1.,  1.,  0.,  0.],
        [ 1.,  1.,  1.,  0.],
        [ 1.,  1.,  1.,  1.]])
    >>> 
    >>> np.tri(4, k=1)
    array([[ 1.,  1.,  0.,  0.],
        [ 1.,  1.,  1.,  0.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]])
    >>> 
    >>> np.tri(4, k=-1)
    array([[ 0.,  0.,  0.,  0.],
        [ 1.,  0.,  0.,  0.],
        [ 1.,  1.,  0.,  0.],
        [ 1.,  1.,  1.,  0.]])
    >>> 
    >>> np.tri(4, 8)
    array([[ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
        [ 1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.],
        [ 1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.],
        [ 1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.]])
    >>> 
    >>> np.tri(4, 8, k=3)
    array([[ 1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.],
        [ 1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.],
        [ 1.,  1.,  1.,  1.,  1.,  1.,  0.,  0.],
        [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.]])
    >>> 
    >>> np.tri(4, 8, k=3, dtype = np.int8)
    array([[1, 1, 1, 1, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1, 0]], dtype=int8)

[Содержание](#содержание)

### tril()
Заменяет на 0 все элементы массива, которые оказались выше указанной диагонали.

__numpy.tril__

    numpy.tril(m, k=0)

Функция tril() преобразует указанный массив в треугольный у которого все элементы выше указанной диагонали равны 0.

Параметры:
+ m - подобный массиву объект<br>
Двумерные, матрицы, списки или кортежи, а так же любая функция или объект с методом, возвращаеющие список или кортеж.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.

Возвращает:
ndarray - массив NumPy<br>
Возвращает копию указанного массива, с той же формой и типом данных, у которого все элементы выше указанной диагонали равны 0.

Смотрите так же: eye, diag, diagflat, tri, triu

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]])
    >>> a
    array([[1, 2, 3, 4],
        [4, 1, 2, 3],
        [3, 4, 1, 2],
        [2, 3, 4, 1]])
    >>> 
    >>> np.tril(a)
    array([[1, 0, 0, 0],
        [4, 1, 0, 0],
        [3, 4, 1, 0],
        [2, 3, 4, 1]])
    >>> 
    >>> np.tril(a, k=1)
    array([[1, 2, 0, 0],
        [4, 1, 2, 0],
        [3, 4, 1, 2],
        [2, 3, 4, 1]])
    >>> 
    >>> np.tril(a, k=-1)
    array([[0, 0, 0, 0],
        [4, 0, 0, 0],
        [3, 4, 0, 0],
        [2, 3, 4, 0]])

[Содержание](#содержание)

### triu()
Заменяет на 0 все элементы массива, которые оказались ниже указанной диагонали.

__numpy.triu__

    numpy.triu(m, k=0)

Функция triu() преобразует указанный массив в треугольный у которого все элементы ниже указанной диагонали равны 0.

Параметры:
+ m - подобный массиву объект<br>
Двумерные, матрицы, списки или кортежи, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.

Возвращает:
+ m - подобный массиву объект<br>
Двумерные, матрицы, списки или кортежи, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.

Смотрите так же: eye, diag, diagflat, tri, tril

Примеры

    >>> a = np.array([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]])
    >>> a
    array([[1, 2, 3, 4],
        [4, 1, 2, 3],
        [3, 4, 1, 2],
        [2, 3, 4, 1]])
    >>> 
    >>> np.triu(a)
    array([[1, 2, 3, 4],
        [0, 1, 2, 3],
        [0, 0, 1, 2],
        [0, 0, 0, 1]])
    >>> 
    >>> np.triu(a, k=1)
    array([[0, 2, 3, 4],
        [0, 0, 2, 3],
        [0, 0, 0, 2],
        [0, 0, 0, 0]])
    >>> 
    >>> np.triu(a, k=-1)
    array([[1, 2, 3, 4],
        [4, 1, 2, 3],
        [0, 4, 1, 2],
        [0, 0, 4, 1]])

[Содержание](#содержание)

### vander()
Создает матрицу Вандермонда.

__numpy.vander__

    numpy.vander(x, N=None, increasing=False)

Функция vander() возвращает матрицу Вандермонда.

Параметры:
+ m - подобный массиву объект<br>
Одномерные, матрицы, списки или кортежи, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ N - целое число (необязательный)<br>
Определяет количество столбцов выходного массива. Если N не указано, то возвращается квадратный массив.
+ increasing - True или False (необязательный)<br>
Определяет направление увеличения степени. Если True, то степени увеличиваются слева на право, если False (по умолчанию), то справа на лево.

Возвращает:
+ ndarray - массив NumPy<br>
Преобразует указанный одномерный массив в матрицу Вандермонда, в каждой строке которого расположены степени элементов из указанного одномерного массива.

Примеры

    >>> import numpy as np
    >>>
    >>> a = [1, 2, 3, 4, 5]
    >>> 
    >>> np.vander(a)
    array([[  1,   1,   1,   1,   1],
        [ 16,   8,   4,   2,   1],
        [ 81,  27,   9,   3,   1],
        [256,  64,  16,   4,   1],
        [625, 125,  25,   5,   1]])
    >>> 
    >>> np.vander(a, N=3)
    array([[ 1,  1,  1],
        [ 4,  2,  1],
        [ 9,  3,  1],
        [16,  4,  1],
        [25,  5,  1]])
    >>> b = [2,3]
    >>> 
    >>> np.vander(a, N=7)
    array([[    1,     1,     1,     1,     1,     1,     1],
        [   64,    32,    16,     8,     4,     2,     1],
        [  729,   243,    81,    27,     9,     3,     1],
        [ 4096,  1024,   256,    64,    16,     4,     1],
        [15625,  3125,   625,   125,    25,     5,     1]])
    >>>
    >>> np.vander(a, N=7, increasing=True)
    array([[    1,     1,     1,     1,     1,     1,     1],
        [    1,     2,     4,     8,    16,    32,    64],
        [    1,     3,     9,    27,    81,   243,   729],
        [    1,     4,    16,    64,   256,  1024,  4096],
        [    1,     5,    25,   125,   625,  3125, 15625]])

[Содержание](#содержание)

# 2. Операции над массивами

## 2.1. Основные операции

### copyto(dst, src[, casting, where])
Копирует данные из одного массива в другой с выполнением транслирования если это необходимо.

__numpy.copyto__

    numpy.copyto(dst, src, casting='same_kind', where=True)

Функция copyto() копирует данные из одного массива в другой с выполнением транслирования если это необходимо.

Параметры:
+ dst - массив NumPy<br>
Массив в который будут скопированы значения.
+ src - массив NumPy или подобный ему объект.<br>
Массив из которого будут скопированы данные.
+ casting - 'no', 'equiv', 'safe', 'same_kind', 'unsafe', (необязательный)
    Этот параметр определяет какой тип данных может возникать при копировании. 
    + Значение 'no' запрещает отбрасывание типа данных, т.е. при копировании будет скопирован и тип данных; 
    + 'equiv' допускает только изменение порядка байтов; 
    + 'safe' допускает только те типы данных, которые сохраняют данные; 
    + 'same_kind' (по умолчанию) допускает только безопасные методы округления и отбрасывания, например такие как float64 в float32; 
    + 'unsafe' допускает любые преобразования данных.
+ where - список или массив булевых значений<br>
Массив булевых значений, который транслируется по массиву dst и определяет какие элементы будут скопированы из src в dst. По умолчанию равен True, что означает копирование всех данных.

Возвращает:
+ ndarray - массив NumPy<br>
Массив, который содержит копию значений элементов другого массива, при этом тип данных, в зависимости от параметра casting может и не соответствовать типу данных исходного массива.

Смотрите так же: copy

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[1, 2], [1, 2]])
    >>> 
    >>> b = np.array([[0, 9], [9, 0]])
    >>> 
    >>> np.copyto(a, b)    #  Копирует значения из 'b' в 'a'
    >>> 
    >>> a
    array([[0, 9],
        [9, 0]])
    >>> 
    >>> b
    array([[0, 9],
        [9, 0]])
    >>> 
    >>> a is b    #  массив 'a' стал полной копией 'b'
    False
    >>> 
    >>> c = np.array([7, 1])
    >>> 
    >>> np.copyto(a, c)    #  'c' транслируется по массиву 'a'
    >>> 
    >>> a
    array([[7, 1],
        [7, 1]])
    >>> 
    >>>
    >>> a = np.zeros((5, 5))
    >>> a
    array([[ 0.,  0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.,  0.]])
    >>> 
    >>> d = np.array([2, 3, 5, 7, 11])    #  'd' будет транслирован по 'a'
    >>> 
    >>> # Параметр 'where' укажет какие значения будут скопированы
    >>> np.copyto(a,d, where = [True, False, True, False, True])
    >>> 
    >>> a
    array([[  2.,   0.,   5.,   0.,  11.],
        [  2.,   0.,   5.,   0.,  11.],
        [  2.,   0.,   5.,   0.,  11.],
        [  2.,   0.,   5.,   0.,  11.],
        [  2.,   0.,   5.,   0.,  11.]])

[Содержание](#содержание)

## 2.2. Изменение формы массива

### reshape(a, newshape[, order])
Изменяет форму массива без изменения его данных.

__numpy.reshape__

    numpy.reshape(a, newshape, order='C')

Функция reshape() изменяет форму массива без изменения его данных.

Данная функция аналогична методу базового класса ndarray.reshape(), который, в общем-то удобней, так как позволяет задавать форму числами, а не кортежем чисел. 

Однако, если вам необходимо передавать форму в виде кортежа, то придется использовать numpy.reshape().

Параметры:
+ а - подобный массиву объект<br>
Массив, форму которого необходимо изменить.
+ newshape - целое число или кортеж целых чисел<br>
Определяет форму выходного массива. Указанный параметр должен быть совместим с формой исходного массива. <br>Целое число сжимает исходный массив до одной оси. <br>Одно из измерений может быть равно -1, что приводит к автоматическому вычислению длинны оси.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran; флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. По умолчанию флаг установлен в значение 'С'.

Возвращает:
+ ndarray - массив NumPy<br>
Массив с исходными данными, но новой формой. Возвращаемый массив, если это возможно, является представлением исходного массива, в противном случае, происходит полное копирование данных.

Смотрите так же: resize, ravel, ndarray.flat, ndarray.T

Замечание

Нет гарантии, того что макет массива в памяти будет сохранен, т.е. стиль 'C' может измениться на 'F' и наоборот. Дело в том, что по умолчанию параметр order установлен в значение C т.е. чтение данных исходного массива выполняется "построчно" (индекс первой оси меняется медленнее чем последней). Если исходный массив организован в памяти в стиле Fortran, при котором чтение данных массива выполняется "по столбцам" (индекс первой оси меняется быстрее чем последней), а order = 'С', то данные которые должны быть прочитаны "по столбцам" будут считаны "построчно", что приведет к транспонированию (транспозиционированию) элементов исходного массива.

    >>> a = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], order = 'C')
    >>> a
    array([[1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3]])
    >>>
    >>> np.reshape(a, (4, 3))    #  чтение по строкам
    array([[1, 1, 1],
        [1, 2, 2],
        [2, 2, 3],
        [3, 3, 3]])
    >>> 
    >>> np.reshape(a, (4, 3), order = 'F')    #  чтение по столбцам
    array([[1, 2, 3],
        [2, 3, 1],
        [3, 1, 2],
        [1, 2, 3]])
    >>>
    >>>
    >>> a = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], order = 'F')
    >>> a
    array([[1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3]])
    >>>
    >>> np.reshape(a, (4, 3), order = 'F')
    array([[1, 2, 3],
        [2, 3, 1],
        [3, 1, 2],
        [1, 2, 3]])
    >>>
    >>> np.reshape(a, (4, 3), order = 'C')
    array([[1, 1, 1],
        [1, 2, 2],
        [2, 2, 3],
        [3, 3, 3]])

Флаг 'A' автоматически установит порядок чтения исходя из того в каком порядке массив хранится в памяти. Если это Fortran-смежный массив, то чтение данных будет "по столбцам", если C-смежный, то чтение будет построчным.

[Содержание](#содержание)

### ndarray.reshape()
Изменяет форму массива без изменения его данных.

### ndarray.reshape()

Базовый класс ndarray обладает полностью аналогичным методом, который отличается от reshape тем, что позволяет передавать новые размеры в виде отдельных аргументов, а не кортежа:

    >>> a = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]])
    >>> 
    >>> np.reshape(a, (2, 6))
    array([[1, 1, 1, 1, 2, 2],
        [2, 2, 3, 3, 3, 3]])
    >>> 
    >>> a.reshape(2, 6)
    array([[1, 1, 1, 1, 2, 2],
        [2, 2, 3, 3, 3, 3]])
    >>> 
    >>> a.reshape(2, 6, order = 'F')
    array([[1, 3, 2, 1, 3, 2],
        [2, 1, 3, 2, 1, 3]])
    Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>> 
    >>> np.reshape(a, (3, 3))
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> 
    >>> b = np.reshape(a, (3, 3))
    >>> 
    >>> b     #  'b' это представление массива 'a'
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> 
    >>> a[0] = 99     #  Изменения в 'a'
    >>> a
    array([99,  2,  3,  4,  5,  6,  7,  8,  9])
    >>> 
    >>> b    # повлекут изменения в 'b'
    array([[99,  2,  3],
        [ 4,  5,  6],
        [ 7,  8,  9]])
    >>> 
    >>> 
    >>> a = np.ones((4, 4))
    >>> a
    array([[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]])
    >>> 
    >>> b = np.reshape(a, (2, -1))
    >>> b    #  Длинна второй оси вычислена автоматически
    array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])

[Содержание](#содержание)

### ravel(a[, order])
Возвращает сжатый до одной оси массив.

__numpy.ravel__

    numpy.ravel(a, order='C')

Функция ravel() возвращает сжатый до одной оси массив.

Параметры:
+ а - подобный массиву объект<br>
Массив любой формы и размерности, который будет сжат до одной оси. Элементы в a перебираются в порядке указанном в параметре order.
+ order - 'K', 'A', 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Если object - это массив NumPy, то флаг 'K' либо сохраняет порядок исходного массива либо устанавливает самый близкий по структуре; флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. По умолчанию флаг установлен в значение 'C'.

Возвращает:
+ array_like - подобный массиву объект<br>
Сжатый до одной оси массив a.

Смотрите так же: flat, flatten, reshape

Замечание

Параметр order по умолчанию установлен в значение C т.е. чтение данных исходного массива выполняется "построчно" (индекс первой оси меняется медленнее чем последней). Если исходный массив организован в памяти в стиле Fortran, при котором чтение данных массива выполняется "по столбцам" (индекс первой оси меняется быстрее чем последней), а order = 'С', то данные которые должны быть прочитаны "по столбцам" будут считаны "построчно", что приведет к другому расположению элементов в сжатом массиве.

Для сжатия массивов до одной оси можно воспользоваться a.reshape(-1) или numpy.reshape(a, -1).

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(9)
    >>> a
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> b = a.reshape(3, 3)
    >>> b
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> 
    >>> np.ravel(b)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> b.reshape(-1)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> np.ravel(b, order = 'C')
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> np.ravel(b, order = 'F')
    array([0, 3, 6, 1, 4, 7, 2, 5, 8])
    >>>
    >>>
    >>> b
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> 
    >>> c = b.T
    >>> c
    array([[0, 3, 6],
        [1, 4, 7],
        [2, 5, 8]])
    >>> 
    >>> np.ravel(c)
    array([0, 3, 6, 1, 4, 7, 2, 5, 8])
    >>> 
    >>> np.ravel(c, order = 'C')
    array([0, 3, 6, 1, 4, 7, 2, 5, 8])
    >>> 
    >>> np.ravel(c, order = 'F')
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> np.ravel(c, order = 'A')
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> 
    >>> a = np.arange(12).reshape(2, 3, 2)
    >>> a
    array([[[ 0,  1],
            [ 2,  3],
            [ 4,  5]],

        [[ 6,  7],
            [ 8,  9],
            [10, 11]]])
    >>> 
    >>> a.ravel()
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
    >>> 
    >>> a.ravel(order = 'F')
    array([ 0,  6,  2,  8,  4, 10,  1,  7,  3,  9,  5, 11])

[Содержание](#содержание)

### ndarray.flat
Одномерный итератор массива.

__ndarray.flat__

    ndarray.flat

Метод ndarray.flat одномерный итератор массива, т.е. перебирает элементы массива так, словно он сжат до одной оси.

Смотрите так же: flatten, ravel, reshape

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(10, 30, 2)
    >>> 
    >>> a
    array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28])
    >>> 
    >>> a.flat[5]
    20
    >>> 
    >>> a = a.reshape(2, 5)
    >>> a
    array([[10, 12, 14, 16, 18],
        [20, 22, 24, 26, 28]])
    >>> 
    >>> a.flat[5]
    20
    >>> 
    >>> a = a.reshape(5, 2)
    >>> a
    array([[10, 12],
        [14, 16],
        [18, 20],
        [22, 24],
        [26, 28]])
    >>> 
    >>> a.flat[5]
    20
    >>> 
    >>> a = a.T
    >>> a
    array([[10, 14, 18, 22, 26],
        [12, 16, 20, 24, 28]])
    >>> 
    >>> a.flat[5]
    12
    >>>
    >>> np.array(a.flat)
    array([10, 14, 18, 22, 26, 12, 16, 20, 24, 28])
    >>> 
    >>> for i in a.flat:
    ...     print(i)
    ... 
    10
    14
    18
    22
    26
    12
    16
    20
    24
    28
    >>>
    >>>
    >>> iter_a = a.flat
    >>> 
    >>> iter_a.coords
    (0, 0)
    >>> iter_a.__next__()
    10
    >>> iter_a.coords
    (0, 1)
    >>> iter_a.__next__()
    14
    >>> iter_a.coords
    (0, 2)

ndarray.flat является экземпляром класса numpy.flatiter.

    >>> type(a.flat)
    <class 'numpy.flatiter'>

[Содержание](#содержание)

### ndarray.flatten([order])
Возвращает копию массива сжатую до одного измерения.

__ndarray.flatten__

    ndarray.flatten(order='C')

Метод ndarray.flatten() возвращает копию массива сжатую до одного измерения.

Параметры:
+ order - , 'C', 'F', 'A' или 'K' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Если object - это массив NumPy, то флаг 'K' либо сохраняет порядок исходного массива либо устанавливает самый близкий по структуре; флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. По умолчанию флаг установлен в значение 'C'.

Возвращает:
+ ndarray - массив NumPy<br>
Копия входного массива, сжатая до одной оси.

Смотрите так же: flat, ravel, reshape

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(10, 30, 2).reshape(5, 2)
    >>> a
    array([[10, 12],
        [14, 16],
        [18, 20],
        [22, 24],
        [26, 28]])
    >>> 
    >>> a.flatten()
    array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28])
    >>> 
    >>> a.flatten(order = 'F')
    array([10, 14, 18, 22, 26, 12, 16, 20, 24, 28])

[Содержание](#содержание)

## 2.3. Транспозиционные операции

### moveaxis(a, source, destination)
Перемещает оси массива на указанные позиции.

__numpy.moveaxis__

    numpy.moveaxis(a, source, destination)[source]

Функция moveaxis() позволяет перемящать оси на новые позиции, при этом другие оси остаются на прежних местах.

Параметры:
+ a - массив NumPy<br>
Массив, оси которого должны быть перемещены.
+ source - целое число или последовательность целых чисел<br>
Определяет исходное положение тех осей, которые должны быть перемещены. Если это последовательность, то все целые числа должны быть уникальными.
+ destination - целое число или последовательность целых чисел<br>
Определяет конечные позиции перемещаемых осей. Если это последовательность, то все целые числа должны быть уникальными.
Возвращает:
+ ndarray - массив NumPy<br>
Массив с переставленными в указанном порядке осями.

Смотрите так же: rollaxis, swapaxes, transpose

Замечание

Выходной массив является представлением исходного массива.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(24).reshape(2, 3, 4)
    >>> a
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])
    >>> 
    >>> a.shape
    (2, 3, 4)
    >>> 
    >>>
    >>> b = np.moveaxis(a, 0, 1)
    >>> b
    array([[[ 0,  1,  2,  3],
            [12, 13, 14, 15]],

        [[ 4,  5,  6,  7],
            [16, 17, 18, 19]],

        [[ 8,  9, 10, 11],
            [20, 21, 22, 23]]])
    >>> 
    >>> b.shape
    (3, 2, 4)
    >>> 
    >>> 
    >>> c = np.moveaxis(a, 2, 0)
    >>> c
    array([[[ 0,  4,  8],
            [12, 16, 20]],

        [[ 1,  5,  9],
            [13, 17, 21]],

        [[ 2,  6, 10],
            [14, 18, 22]],

        [[ 3,  7, 11],
            [15, 19, 23]]])
    >>>
    >>> c.shape
    (4, 2, 3)
    >>> 
    >>> #  Наглядное представление перемещения осей
    ... a.shape
    (2, 3, 4)
    >>> 
    >>> np.moveaxis(a, 0, 1).shape
    (3, 2, 4)
    >>> 
    >>> np.moveaxis(a, 0, 2).shape
    (3, 4, 2)
    >>> 
    >>> #  Числа могут быть отрицательными
    ... a.shape
    (2, 3, 4)
    >>> 
    >>> np.moveaxis(a, 0, -1).shape
    (3, 4, 2)
    >>> 
    >>> np.moveaxis(a, 0,-2).shape
    (3, 2, 4)
    >>> 
    >>> np.moveaxis(a, -1, 0).shape
    (4, 2, 3)
    >>> 
    >>> np.moveaxis(a, -1, -3).shape
    (4, 2, 3)
    >>> 
    >>> 
    >>> #  Использование параметров-последовательностей:
    ... a.shape
    (2, 3, 4)
    >>> 
    >>> np.moveaxis(a, [0, 1, 2], [2, 1, 0]).shape
    (4, 3, 2)
    >>> 
    >>> np.moveaxis(a,[-1, -2, -3], [-3, -2, -1]).shape
    (4, 3, 2)
    >>> 
    >>> np.moveaxis(a, [0, -1], [-1, 0]).shape
    (4, 3, 2)
    >>> 
    >>> np.moveaxis(a, [0, 1], [1, 2]).shape
    (4, 2, 3)
    >>> 
    >>> np.moveaxis(a, [0, 1], [-3, -2]).shape
    (2, 3, 4)

[Содержание](#содержание)

### rollaxis(a, axis[, start])
Ставит указанную ось самой первой или в указанное положение.

__numpy.rollaxis__

    numpy.rollaxis(a, axis, start=0)

Функция rollaxis() перемещает указанную ось, пока она не окажется в заданном положении.

Параметры:
+ a - массив Numpy<br>
Массив ось которого должна быть перемещена.
+ axis - целое число
Определяет ось массива, которая должна быть перемещена назад.
+ start - целое число (необязательный)<br>
Этот параметр определяет место остановки оси, т.е. ось перемещается назад, пока не окажется перед указанным значением. По умолчанию start = 0, что приводит к остановке перемещения.

Возвращает:
+ ndarray - массив NumPy<br>
Массив, ось которого смещена в указанное место, при этом положение других осей относительно друг друга в нем не изменено.

Смотрите так же: moveaxis, swapaxes, transpose

Замечание

Данная функция поддерживается для обратной совместимости с более ранними версиями, поэтому предпочтительнее использовать функцию moveaxis, которая была введена в NumPy 1.11. С версии 1.10 всегда возвращается представление исходного массива, для более ранних версий представление возвращается только в том случае, если порядок осей изменяется, если нет (start = 0), то возвращается исходный массив.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(24).reshape(2, 3, 4)
    >>> a
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])
    >>> 
    >>> a.shape
    (2, 3, 4)
    >>> 
    >>> b = np.rollaxis(a, 2, 0)
    >>> b
    array([[[ 0,  4,  8],
            [12, 16, 20]],

        [[ 1,  5,  9],
            [13, 17, 21]],

        [[ 2,  6, 10],
            [14, 18, 22]],

        [[ 3,  7, 11],
            [15, 19, 23]]])
    >>> 
    >>> b.shape
    (4, 2, 3)
    >>> 
    >>> # Более наглядные примеры
    ... a.shape
    (2, 3, 4)
    >>> 
    >>> np.rollaxis(a, 2, 0).shape
    (4, 2, 3)
    >>> 
    >>> np.rollaxis(a, 2, 1).shape
    (2, 4, 3)
    >>>
    >>> np.rollaxis(a, 2, 2).shape    #  Не приведет к ошибке
    (2, 3, 4)
    >>> np.rollaxis(a, 2, 3).shape    #  Тоже не приведет к ошибке
    (2, 3, 4)
    >>> 
    >>> np.rollaxis(a, 2, 5).shape    #  Приведет к ошибке
    >>>
    >>>
    >>> a.shape
    (2, 3, 4)
    >>> 
    >>> np.rollaxis(a, 0, 1).shape
    (2, 3, 4)
    >>> np.rollaxis(a, 0, 2).shape
    (3, 2, 4)
    >>> np.rollaxis(a, 0, 3).shape
    (3, 4, 2)
    >>> np.rollaxis(a, 0, -1).shape
    (3, 2, 4)
    >>> np.rollaxis(a, 0, -2).shape
    (2, 3, 4)
    >>> np.rollaxis(a, 0, -3).shape
    (2, 3, 4)
    >>> np.rollaxis(a, 0, -4).shape    #  Приведет к ошибке
    >>>
    >>> a.shape
    (2, 3, 4)
    >>> np.rollaxis(a, 0).shape
    (2, 3, 4)
    >>> np.rollaxis(a, 1).shape
    (3, 2, 4)
    >>> np.rollaxis(a, 2).shape
    (4, 2, 3)

[Содержание](#содержание)

### swapaxes(a, axis1, axis2)
Меняет местами две указанные оси массива.

__numpy.swapaxes__

    numpy.swapaxes(a, axis1, axis2)

Функция swapaxes() меняет местами две оси массива.

Параметры:
+ a - массив Numpy<br>
Массив, оси которого должны быть перемещены.
+ axis1 - целое число<br>
Первая ось.
+ axis2 - целое число<br>
Вторая ось.
Возвращает:
+ ndarray - массив NumPy<br>
Массив у которого две оси поменялись позициями.

Смотрите так же: moveaxis, rollaxis, transpose

Замечание

С версии 1.10 возвращается представление, если на вход подается массив NumPy, в противном случае создается новый массив. Для более ранних версий представление возвращается только в том случае, если порядок осей изменяется, если нет, то возвращается исходный массив.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(24).reshape(2, 3, 4)
    >>> a
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])
    >>> 
    >>> a.shape
    (2, 3, 4)
    >>> 
    >>> b = np.swapaxes(a, 0, 2)
    >>> b
    array([[[ 0, 12],
            [ 4, 16],
            [ 8, 20]],

        [[ 1, 13],
            [ 5, 17],
            [ 9, 21]],

        [[ 2, 14],
            [ 6, 18],
            [10, 22]],

        [[ 3, 15],
            [ 7, 19],
            [11, 23]]])
    >>> 
    >>> b.shape
    (4, 3, 2)
    >>> 
    >>> 
    >>> a.shape
    (2, 3, 4)
    >>> 
    >>> np.swapaxes(a, 0, 1).shape
    (3, 2, 4)
    >>> 
    >>> np.swapaxes(a, 0, 2).shape
    (4, 3, 2)
    >>> 
    >>> np.swapaxes(a, 2, 0).shape
    (4, 3, 2)

[Содержание](#содержание)

### ndarray.T
Транспонирует массив.

__ndarray.T__

    ndarray.T

Метод ndarray.T транспонирует, т.е. меняет оси массива в обратном порядке или возвращает сам массив если он является одномерным.

Смотрите так же: transpose, moveaxis

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(9).reshape(3, 3)
    >>> a
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> 
    >>> a.T
    array([[0, 3, 6],
        [1, 4, 7],
        [2, 5, 8]])
    >>> 
    >>>
    >>> b = np.arange(9)
    >>> b
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> b.T
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>>
    >>> c = np.arange(8).reshape(2, 2, 2)
    >>> c
    array([[[0, 1],
            [2, 3]],

        [[4, 5],
            [6, 7]]])
    >>> 
    >>> c.T
    array([[[0, 4],
            [2, 6]],

        [[1, 5],
            [3, 7]]])
    >>>
    >>>
    >>> d = np.ones((2, 3, 4, 5))
    >>> 
    >>> d.shape
    (2, 3, 4, 5)
    >>> 
    >>> d.T.shape
    (5, 4, 3, 2)

[Содержание](#содержание)

### transpose(a[, axes])
Транспонирует или перемещает оси массива в указанные положения.

__numpy.transpose__

    numpy.transpose(a, axes=None)

Функция transpose() транспонирует (меняет оси в обратном порядке) или перемещает оси массива в указанные положения.

Параметры:
+ a - массив Numpy<br>
Массив ось которого должна быть перемещена.
+ axes - целое число или последовательность целых чисел (необязательный)<br>
По умолчанию axes=None, что соответствует простому транспонированию. Если указана последовательность целых чисел, то оси будут расставлены в указанном последовательностью порядке.

Возвращает:
+ ndarray - массив NumPy<br>
Массив оси которого переставлены в обратном (по умолчанию) или указанном порядке.

Смотрите так же: rollaxis, swapaxes, moveaxis.html

Замечание

Функция вернет сам входной массив, если он является одномерным. При этом функция не всегда возвращает представление исходного массива.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.arange(9).reshape(3, 3)
    >>> a
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> 
    >>> np.transpose(a)
    array([[0, 3, 6],
        [1, 4, 7],
        [2, 5, 8]])
    >>> 
    >>>
    >>> b = np.arange(9)
    >>> b
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>> np.transpose(b)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8])
    >>> 
    >>>
    >>> c = np.arange(8).reshape(2, 2, 2)
    >>> c
    array([[[0, 1],
            [2, 3]],

        [[4, 5],
            [6, 7]]])
    >>> 
    >>> np.transpose(c)
    array([[[0, 4],
            [2, 6]],

        [[1, 5],
            [3, 7]]])
    >>> 
    >>> d = np.ones((2, 3, 4, 5))
    >>> 
    >>> d.shape
    (2, 3, 4, 5)
    >>> 
    >>> np.transpose(d).shape
    (5, 4, 3, 2)
    >>> 
    >>> 
    >>> d = np.ones((2, 3, 4, 5))
    >>> 
    >>> np.transpose(d, (3, 2, 1, 0)).shape
    (5, 4, 3, 2)
    >>> 
    >>> np.transpose(d, (0, 2, 1, 3)).shape
    (2, 4, 3, 5)

[Содержание](#содержание)

## 2.4. Изменение количества измерений

### atleast_1d(*arys)
Преобразует входные данные в одномерный массив.

[Содержание](#содержание)

### atleast_2d(*arys)
Преобразует входные данные в двумерный массив.

[Содержание](#содержание)

### atleast_3d(*arys)
Преобразует входные данные в трехмерный массив.

[Содержание](#содержание)

### broadcast
Создает объект, который имитирует транслирование массивов.

[Содержание](#содержание)

### broadcast_to(array, shape[, subok])
Транслирует массив по указанной форме.

[Содержание](#содержание)

### broadcast_arrays(*args, **kwargs)
Транслирует указанные массивы относительно друг друга.

[Содержание](#содержание)

### expand_dims(a, axis)
Добавляет новую ось к массиву.

[Содержание](#содержание)

### squeeze(a[, axis])
Удаляет оси с одним элементом, но не сами элементы массива.

[Содержание](#содержание)

## 2.5. Изменение типа массива

### asarray(a[, dtype, order])
Интерпретирует входные данные как массив.

[Содержание](#содержание)

### asanyarray(a[, dtype, order])
Интерпретирует входные данные как массив, но пропускает подклассы ndarray.

[Содержание](#содержание)

### asmatrix(data[, dtype])
Интерпретирует входные данные как матрицу.

[Содержание](#содержание)

### asfarray(a[, dtype])
Интерпретирует входные данные как массив типа float.

[Содержание](#содержание)

### asfortranarray(a[, dtype])
Интерпретирует входные данные как массив, с организацией в памяти в стиле Fortran.

[Содержание](#содержание)

### ascontiguousarray(a[, dtype])
Интерпретирует входные данные как массив, с организацией в памяти в стиле C.

[Содержание](#содержание)

### asarray_chkfinite(a[, dtype, order])
Интерпретирует входные данные как массив, с предварительной их проверкой на наличие элементов Nan и inf.

[Содержание](#содержание)

### asscalar(a)
Преобразует массив с одним элементом в его скалярный эквивалент.

[Содержание](#содержание)

### require(a[, dtype, requirements])
Интерпретирует входные данные как массив, который соответствует указанному типу и флагам.

[Содержание](#содержание)

## 2.6. Соединение массивов

### concatenate((a1, a2, ...)[, axis, out])
Соединяет массивы вдоль указанной оси.

[Содержание](#содержание)

### stack(arrays[, axis, out])
Соединяет массивы вдоль новой оси.

[Содержание](#содержание)

### column_stack((a1, a2, ..., aN))
Соединяет массивы по вертикали, т.е. вдоль первой (не нулевой) оси.

[Содержание](#содержание)

### row_stack((a1, a2, ..., aN))
Соединяет массивы по горизонтали, т.е. вдоль нулевой оси.

[Содержание](#содержание)

### dstack((a1, a2, ..., aN))
Соединяет массивы вдоль третьей оси.

[Содержание](#содержание)

### hstack((a1, a2, ..., aN))
Соединяет массивы по горизонтали.

[Содержание](#содержание)

### vstack((a1, a2, ..., aN))
Соединяет массивы по вертикали.

[Содержание](#содержание)

### block([a1, a2, ..., aN])
Создает массив из указанной последовательности блоков.

[Содержание](#содержание)

## 2.7. Разбиение массивов

### split(a, indices_or_sections[, axis])
Разбивает массив на несколько подмассивов.

[Содержание](#содержание)

### array_split(a, indices_or_sections[, axis])
Разбивает массив на несколько подмассивов.

[Содержание](#содержание)

### dsplit(a, indices_or_sections)
Разбивает массив на несколько подмассивов вдоль третьей оси.

[Содержание](#содержание)

### hsplit(a, indices_or_sections)
Разбивает массив по горизонтали.

[Содержание](#содержание)

### vsplit(a, indices_or_sections)
Разбивает массив по вертикали.

[Содержание](#содержание)

## 2.8. Циклические массивы

### tile(A, reps)
Создает массив повторением указанного массива A заданным количеством раз.

[Содержание](#содержание)

### repeat(a, repeats[, axis])
Повторяет элементы массива.

[Содержание](#содержание)

## 2.9. Добавление и удаление элементов

### delete(a, obj[, axis])
Удаляет указанные элементы на указанной оси.

[Содержание](#содержание)

### insert(a, obj, values[, axis])
Вставляет указанные элементы перед указанными индексами на указанной оси.

[Содержание](#содержание)

### append(a, values[, axis])
Добавляет элементы в конец массива.

[Содержание](#содержание)

### resize(a, new_shape)
Возвращает новый массив с указанной формой.

[Содержание](#содержание)

### trim_zeros(filt[, trim])
Удаляет нули из начала или конца указанного одномерного массива или последовательности.

[Содержание](#содержание)

### unique(a, return_index=False, return_inverse=False, return_counts=False, axis=None)
Находит уникальные элементы массива.

[Содержание](#содержание)

## 2.10. Изменение порядка элементов

### flip(m, axis)
Располагает элементы в обратном порядке вдоль указанной оси.

[Содержание](#содержание)

### fliplr(m)
Отражает массив по горизонтали.

[Содержание](#содержание)

### flipud(m)
Отражает массив по вертикали.

[Содержание](#содержание)

### reshape(a, newshape[, order])
Изменяет форму массива без изменения его данных.

[Содержание](#содержание)

### roll(a, shift[, axis])
Циклическое смещение элементов массива вдоль указанной оси.

[Содержание](#содержание)

### rot90(m[, k, axes])
Поворачивает массив на 90 градусов в плоскости указанных осей.

