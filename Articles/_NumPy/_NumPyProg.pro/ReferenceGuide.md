# Reference Guide Справочное руководство

1. [Создание массивов](#1-создание-массивов)<br>
1.1. [Автозаполнение массивов](#11-автозаполнение-массивов)<br>
1.2. [Заполнение данными](#12-заполнение-данными)<br>
1.3. [Создание массивов записей](#12-заполнение-данными)<br>
1.4. [Создание массивов символов](#14-создание-массивов-символов)<br>
1.5. [Числовые диапазоны](#15-числовые-диапазоны) <br>
1.6. [Создание матриц](#16-создание-матриц) <br>
2. Операции над массивами <br>
2.1. Основные операции <br>
2.2. Изменение формы массива <br>
2.3. Транспозиционные операции <br>
2.4.Изменение количества измерений <br>
2.5.Изменение типа массива <br>
2.6.Соединение массивов <br>
2.7.Разбиение массивов <br>
2.8.Циклические массивы <br>
2.9.Добавление и удаление элементов <br>
2.10.Изменение порядка элементов <br>
3. Математические функции <br>
Тригонометрические функции <br>
Гиперболические функции <br>
Округление <br>
Суммы, разности, произведения <br>
Экспоненцирование и логарифмирование <br>
Другие специальные функции <br>
Операции с плавающей точкой <br>
Арифметические операции <br>
Операции с комплексными числами <br>
Прочие математические функции <br>
4. Генерация случайных данных <br>
Получение простых случайных данных <br>
Перестановки <br>
Генератор псевдо-случайных чисел <br>
5. Статистика <br>
Основные статистические характеристики <br>
Средние и отклонения <br>
Корреляции <br>
Гистограммы <br>
6. Линейная алгебра <br>
Произведение векторов и матриц <br>
Разложения матриц <br>
Нормы и прочие числовые характеристики матриц <br>
Собственные значения матриц <br>
Системы уравнений и обратные матрицы <br>
Исключения <br>
7. Ввод вывод данных <br>
Файлы NumPy (npy, npz) <br>
Текстовые файлы <br>
Необработанные бинарные файлы <br>
Строковое представление <br>
Параметры текстового представления <br>
Источники данных <br>
Системы счисления <br>
8. Работа с индексом <br>
Создание индексных массивов <br>
Индексоподобные операции <br>
Вставка данных в массив <br>
Итерирование массивов <br>
9.Сортировка, поиск, подсчет <br>
Сортировка <br>
Поиск <br>
Подсчет <br>

# 1. Создание массивов
## 1.1. Автозаполнение массивов

###  empty()

Возвращает новый массив заданной формы и типа без инициированных записей.

__numpy.empty__
    
    numpy.empty(shape, dtype=float, order='C')

Функция empty() возвращает новый массив заданной формы и типа без инициированных записей.

Параметры:
+ _shape_ - целое число, список или кортеж целых чисел  <br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ _dtype_ - тип данных NumPy (необязательный) <br>
Определяет тип данных выходного массива.
+ _order_ - 'C' или 'F' (необязательный) <br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.
Возвращает:
+ _результат_ - массив NumPy <br>
Массив неициированных (случайных) значений, указанной формы, типа и порядка.

Смотрите так же: empty_like, zeros, ones, full

Замечание<br>
Функция empty в отличие от таких функций как zeros или ones не устанавливает элементы массива в какое-то определенное значение и работает немного быстрее. 

В результате работы функции empty все элементы приобретают случайное значение, которое зависит от состояния памяти, однако, использовать эту функцию в качестве генератора псевдослучайных чисел настоятельно не рекомендуется.

Функция может оказаться крайне полезной, если в вашем коде приходится очень часто создавать временные массивы.

Примеры

    >>> import numpy as np
    

При первом вызове функции все элементы окажутся случайными:

    a = np.empty([2,3])
    >>> a
    array([[  2.45047495e-260,  -1.84746290e-072,  -5.75988362e-044],
        [  1.51671551e-314,   1.51662710e-314,   3.60739299e-313]])

При последующих вызовах функции с теми же параметрами

    >>> a = np.empty([2,3])
    >>> a                      

все элементы окажутся равны нулю (или прежними)

    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])

    >>> a = np.empty([3,3], dtype = int)
    >>> a
    array([[         0,    6553601,      25600],
        [1677722215,   40173569,   16876288],
        [1677722458,  693305346,         10]])
    >>> 
    >>> a = np.empty([2,2], dtype = np.int8)
    >>> a
    array([[ -1,  -1],
        [ -1, 127]], dtype=int8)
    >>>
    >>> a = np.empty(7, dtype = np.complex64)
    >>> a
    array([ -1.21864286e-05 -1.21864286e-05j,
            0.00000000e+00 +0.00000000e+00j,
            0.00000000e+00 +9.10844002e-44j,
            -1.21864286e-05 +4.55124964e-33j,
            0.00000000e+00 +0.00000000e+00j,
            0.00000000e+00 +5.74532370e-44j,
            -1.21864286e-05 -1.21864286e-05j], dtype=complex64)

### empty_like()
Возвращает новый массив с формой и типом данных указанного массива без инициированных записей.

__numpy.empty_like__

    numpy.empty_like(a, dtype=None, order='K', subok=True)

Функция empty_like() возвращает новый массив без инициированных записей с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив <br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива

+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
    Этот параметр определяет в каком порядке массивы должны храниться в памяти: 
    + строчном C-стиле или 
    + столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умолчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив неинициированных (случайных) значений с формой и типом данных указанного массива a.

Замечание

Функция empty_like (так же как и функция empty) не устанавливает элементы массива в какое-то определенное значение и работает немного быстрее чем такие функции как zeros_like или ones_like. <br>
В результате работы функции empty_like все элементы приобретают случайное значение, которое зависит от состояния памяти, однако, использовать эту функцию в качестве генератора псевдослучайных чисел настоятельно не рекомендуется.

    Примеры
    >>> a = np.array([[1,2],[2,1]])
    >>> 
    >>> b = np.empty_like(a)
    >>> b
    array([[0, 0],
        [0, 0]])
    >>> 
    >>> #  Размер и тип данных массивов 'a' и 'b' совпадают:
    ... b.shape == a.shape, b.dtype == a.dtype
    (True, True)
    >>>
    >>> a = np.array([[1,2,3,4],[5,6,7,8]], dtype = np.int8)
    >>> 
    >>> b = np.empty_like(a)
    >>> b
    array([[   0,    0,    0,    0],
        [-118, -114,  -23,   62]], dtype=int8)
    >>> 
    >>> b.shape == a.shape, b.dtype == a.dtype
    (True, True)

### eye()
Возвращает новый массив в котором диагональные элементы равны единице, а все остальные равны нулю.<br>
__numpy.eye__

    numpy.eye(N, M=None, k=0, dtype=<type 'float'>, order='C')

Функция eye() возвращает двумерный массив у которого все элементы по диагонали равны 1, а все остальные равны 0.

Параметры:
+ N - целое число<br>
Задает количество строк выходного массива.
+ M - целое число (необязательный)<br>
Задает количество столбцов выходного массива. Если этот параметр не задан то M = N.
+ k - индекс диагонали (необязательный)<br>
По умолчанию k = 0, что соответствует главной диагонали. Положительное значение k смещает диагональ вверх, отрицательное - вниз.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив размером (N, M) с единицами по указанной диагонали и остальными нулевыми элементами.

Смотрите так же: identity, diag, diagflat

Примеры

    >>> import numpy as np
    >>> 
    >>> np.eye(3)    #  Квадратный массив с 1 по главной диагонали
    array([[ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]])
    >>> 
    >>> np.eye(3, 5)    #  Прямоугольный массив с 1 по угловой диагонали
    array([[ 1.,  0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.,  0.],
        [ 0.,  0.,  1.,  0.,  0.]])
    >>> 
    >>> np.eye(3, 5, k=2)     #  Смещение диагонали вверх на две позиции
    array([[ 0.,  0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  0.,  1.]])
    >>> 
    >>> np.eye(5, 3, k=-2)     #  Смещение диагонали вниз на две позиции
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]])
    >>> 
    >>> np.eye(5, dtype = np.int8)    #  Указание типа элементов
    array([[1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1]], dtype=int8)

### identity()
Возвращает новый квадратный массив с единицами по главной диагонали.

__numpy.identity__

    numpy.identity(n, dtype=None)

Функция identity() возвращает квадратный массив с единицами по главной диагонали, при этом остальные элементы выходного массива равны 0. Эквивалентна eye(n, dtype=dtype).

Параметры:
+ n - целое число<br>
Задает размеры квадратного массива (n x n).
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
Возвращает:
+ результат - массив NumPy<br>
Квадратный массив с единицами по главной диагонали, остальные элементы которого равны 0.

Смотрите так же: [eye](#eye), diag, diagflat

Примеры

    >>> import numpy as np
    >>> 
    >>> np.identity(4)
    array([[ 1.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.],
        [ 0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  1.]])
    >>> 
    >>> np.identity(4, dtype = np.int8)
    array([[1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]], dtype=int8)

### ones()
Возвращает новый массив заданной формы и типа, заполненный единицами.

__numpy.ones__

    numpy.ones(shape, dtype=None, order='C')

Функция __ones()__ возвращает новый массив указанной формы и типа, заполненный единицами.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив из единиц, указанной формы, типа и порядка.

Смотрите так же: ones_like, zeros, empty, full

Примеры

    >>> import numpy as np
    >>> 
    >>> np.ones(10)
    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
    >>> 
    >>> np.ones(10, dtype = np.int8)
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int8)
    >>> 
    >>> np.ones((3, 5))
    array([[ 1.,  1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.,  1.]])
    >>> 
    >>> np.ones((3, 1))
    array([[ 1.],
        [ 1.],
        [ 1.]])
    >>>
    >>> m = (3, 2, 2)
    >>> 
    >>> np.ones(m)
    array([[[ 1.,  1.],
            [ 1.,  1.]],

        [[ 1.,  1.],
            [ 1.,  1.]],

        [[ 1.,  1.],
            [ 1.,  1.]]])


### ones_like()

Возвращает новый массив с формой и типом данных указанного массива, заполненный единицами.

__numpy.ones_like__

    numpy.ones_like(a, dtype=None, order='K', subok=True)

Функция ones_like() возвращает новый массив из единиц с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>

    Этот параметр определяет в каком порядке массивы должны храниться в памяти: 
    + строчном C-стиле или столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.

+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив из единиц, с формой и типом данных указанного массива a.

Смотрите так же: ones, zeros_like, empty_like, full_like

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[7, 7], [1, 1]])
    >>> a
    array([[7, 7],
        [1, 1]])
    >>> 
    >>> np.ones_like(a)
    array([[1, 1],
        [1, 1]])
    >>> 
    >>> np.ones_like(a, dtype = np.int8)
    array([[1, 1],
        [1, 1]], dtype=int8)
    >>> 
    >>> b = np.arange(8, dtype = np.float32)
    >>> b
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.], dtype=float32)
    >>> 
    >>> b = b.reshape(2, 4)
    >>> b
    array([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.]], dtype=float32)
    >>> 
    >>> np.ones_like(b)
    array([[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]], dtype=float32)

Смотрите так же: arange, reshape

### zeros()
Возвращает новый массив заданной формы и типа, заполненный нулями.

__numpy.zeros__
    
    numpy.zeros(shape, dtype=float, order='C')

Функция zeros() возвращает новый массив указанной формы и типа, заполненный нулями.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив из нулей, указанной формы, типа и порядка.

Смотрите так же: zeros_like, ones, empty, full

Примеры

    >>> import numpy as np
    >>> 
    >>> np.zeros(4)    #  Массив-строка из нулей
    array([ 0.,  0.,  0.,  0.])
    >>> 
    >>> np.zeros((4, 1))    #  Массив-столбец из нулей
    array([[ 0.],
        [ 0.],
        [ 0.],
        [ 0.]])
    >>> 
    >>> np.zeros((3, 3))    #  Массив из нулей указанных размеров
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])
    >>> 
    >>> np.zeros((3, 3), dtype = np.int8)    #  Указываем форму и тип данных
    array([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]], dtype=int8)
    >>>
    >>>
    >>> #  zeros может применяться для создания и 
    ... #  заполнения структурированных массивов:
    ... f = np.zeros((5), dtype=[('x', 'i2'), ('y', 'f4')])
    >>> 
    >>> f
    array([(0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0)], 
        dtype=[('x', '<i2'), ('y', '<f4')])
    >>>
    >>> f['x']
    array([0, 0, 0, 0, 0], dtype=int16)
    >>> 
    >>> f['y']
    array([ 0.,  0.,  0.,  0.,  0.], dtype=float32)

### zeros_like()
Возвращает новый массив с формой и типом данных указанного массива, заполненный нулями.

__numpy.zeros_like__
    
    numpy.zeros_like(a, dtype=None, order='K', subok=True)

Функция zeros_like() возвращает новый массив из нулей с формой и типом данных указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>

    Этот параметр определяет в каком порядке массивы должны храниться в памяти:
    + строчном C-стиле или столбчатом стиле Fortran. 
    + Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. 
    + Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив из нулей, с формой и типом данных указанного массива a.

Смотрите так же: zeros, empty_like, ones_like, full_like

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a
    array([1, 2, 3, 4, 5])
    >>> 
    >>> np.zeros_like(a)
    array([0, 0, 0, 0, 0])
    >>> 
    >>> b = np.arange(16, dtype = np.float64)
    >>> b = b.reshape((4, 4))
    >>> b
    array([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.],
        [ 12.,  13.,  14.,  15.]])
    >>> 
    >>> c = np.zeros_like(b)
    >>> c
    array([[ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.]])
    >>> 
    >>> c.dtype
    dtype('float64')

Смотрите так же: arange, reshape

### full()
Возвращает новый массив заданной формы и типа все элементы которого равны указанному значению.

__numpy.full__

    numpy.full(shape, fill_value, dtype=None, order='C')

Функция full() возвращает новый массив указанной формы и типа, заполненный указанным значением fill_value.

Параметры:
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ fill_value - число или любое допустимое значение NumPy<br>
Все элементы выходного массива будут равны fill_value.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив указанной формы, типа и порядка, все элементы которого равны указанному в fill_value значению.

Смотрите так же: full_like, empty, zeros, ones

Замечание

Если параметр dtype не указан то тип данных выходного массива будет таким же как у fill_value, который можно узнать, выполнив np.array(fill_value).dtype:

    >>> fill_value = 3.14
    >>>
    >>> np.array(fill_value).dtype
    dtype('float64')

Примеры

    >>> import numpy as np
    >>> 
    >>> np.full(4, 5)    #  Может появиться предупреждение
    /home/n1/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:301:
    FutureWarning: in the future, full((4,), 5)
    will return an array of dtype('int32')
    format(shape, fill_value, array(fill_value).dtype), FutureWarning)
    array([ 5.,  5.,  5.,  5.])
    >>> # т.е. в будущем  full((4,), 5) вернет массива типа 'int32'
    ... #  на вычислениях это никак не скажется
    ... 
    >>> np.full(4, 5) + 1
    array([ 6.,  6.,  6.,  6.])
    >>> 
    >>> np.full((3, 3), 5, dtype = int)
    array([[5, 5, 5],
        [5, 5, 5],
        [5, 5, 5]])
    >>>
    >>>
    >>> #  Можно заполнить массив значением inf или nan:
    ... np.full((3, 3),np.inf)
    array([[ inf,  inf,  inf],
        [ inf,  inf,  inf],
        [ inf,  inf,  inf]])
    >>> 
    >>> np.full((3, 3),np.nan)
    array([[ nan,  nan,  nan],
        [ nan,  nan,  nan],
        [ nan,  nan,  nan]])
    >>>
    >>>
    >>> #  Или строками:
    ... np.full((3, 3), 'a')
    array([['a', 'a', 'a'],
        ['a', 'a', 'a'],
        ['a', 'a', 'a']], dtype='<U1')


### full_like()
Возвращает новый массив с формой и типом данных указанного массива, все элементы которого равны указанному значению.

__numpy.full_like__

    numpy.full_like(a, fill_value, dtype=None, order='K', subok=True)

Функция full_like() возвращает новый массив все элементы которого равны указанному значению fill_value, а форма и тип данных такие же как у указанного массива a.

Параметры:
+ a- существующий массив<br>
Форма и тип данных массива a определяет форму и тип данных возвращаемого массива
+ fill_value - число или любое допустимое значение NumPy<br>
Все элементы выходного массива будут равны fill_value.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию), то выходной массив будет использовать тип подкласса массива a, если False то тип массива базового класса.

Возвращает:
+ результат - массив NumPy<br>
Массив все элементы, кторого равны fill_value, с формой и типом данных указанного массива a

Смотрите так же: full, zeros_like, ones_like empty_like

Замечание

Если параметр dtype не указан то тип данных выходного массива будет таким же как у fill_value, который можно узнать, выполнив np.array(fill_value).dtype:

    >>> fill_value = 3.14
    >>>
    >>> np.array(fill_value).dtype
    dtype('float64')

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a
    array([1, 2, 3, 4, 5])
    >>> 
    >>> np.full_like(a, 77)
    array([77, 77, 77, 77, 77])
    >>> 
    >>> b = np.arange(16, dtype = np.float64)
    >>> b = b.reshape((4,4))
    >>> b
    array([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.],
        [ 12.,  13.,  14.,  15.]])
    >>> 
    >>> c = np.full_like(b, 77)
    >>> c
    array([[ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.],
        [ 77.,  77.,  77.,  77.]])
    >>> 
    >>> c.dtype
    dtype('float64')
    >>>
    >>> a = np.array([1,2,3,4,5])    #  Если тип исходного массива int
    >>>                              #  а fill_value типа float,
    >>> np.full_like(a, 0.1)         #  то данные из дробной части потеряются.
    array([0, 0, 0, 0, 0])
    >>> 
    >>> np.full_like(a, 0 + 5j)      #  Это же касается и комплексных чисел
    /home/n1/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:361:
    ComplexWarning: Casting complex values to real discards the imaginary part
    multiarray.copyto(res, fill_value, casting='unsafe')
    array([0, 0, 0, 0, 0])
    >>>
    >>> #  Можно заполнить массив значением inf или nan
    ... 
    >>> c = np.full_like(b, np.inf)
    >>> c
    array([[ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf],
        [ inf,  inf,  inf,  inf]])
    >>> 
    >>> c = np.full_like(b, np.nan)
    >>> c
    array([[ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan],
        [ nan,  nan,  nan,  nan]])
    >>>
    >>> #  Для заполнения массива строками
    ... #  необходимо указать тип данных np.unicode
    ... 
    >>> c = np.full_like(b, 'a', dtype = np.unicode)
    >>> c
    array([['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a'],
        ['a', 'a', 'a', 'a']], 
        dtype='<U1')

Смотрите так же: arange, reshape

## 1.2. Заполнение данными

### array()
Создает массив NumPy.

__numpy.array__

    numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Функция array() создает массив NumPy.

Параметры:
+ object - подобный массиву объект<br>
Список или кортеж, а так же лбая функция или объект с методом, возвращаеющие список или кортеж.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если: метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (dtype, order и т.д.)
+ order - 'K', 'A', 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Если object - это массив NumPy, то флаг 'K' либо сохраняет порядок исходного массива либо устанавливает самый близкий по структуре; флаг 'A' установит макет памяти выходного массива в 'F' если массив object является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. По умолчанию флаг установлен в значение 'K'.
+ subok- True или False (необязательный)<br>
Если параметр установлен в значение True (установлено по умодчанию в False), то выходной массив будет использовать тип подкласса массива object, если False то тип массива базового класса.
+ ndmin- целое число (необязательный)<br>
Определяет минимальное количество измерений результирующего массива, которое, по мере необходимости, будет прикреплено к его форме для удовлетворения этого требования.

Возвращает:
+ результат - массив NumPy<br>
Массив удовлетворяющий всем указанным требованиям.

Смотрите так же: empty, empty_like, zeros, zeros_like, ones, ones_like, full, full_like

Замечание

Довольно большое значение имеет параметр order, который отвечает за порядок хранения массива в памяти. В некоторых ситуациях этот порядок может изменяться, что в редких случаях может приводить к ошибкам. Например при выполении транспонирования массива порядок 'C' может измениться на порядок 'F':

    >>> a = np.array([[1, 2], [1, 2]])
    >>> a
    array([[1, 2],
        [1, 2]])
    >>> 
    >>> b = a.T    #  Присвоим массиву 'b' транспонированную матрицу 'a' 
    >>> b
    array([[1, 1],
        [2, 2]])
    >>> 
    >>> #  Теперь проверим порядок хранения в памяти
    ... 
    >>> a.flags
    C_CONTIGUOUS : True
    F_CONTIGUOUS : False
    OWNDATA : True
    WRITEABLE : True
    ALIGNED : True
    UPDATEIFCOPY : False
    >>> 
    >>> b.flags
    C_CONTIGUOUS : False
    F_CONTIGUOUS : True
    OWNDATA : False
    WRITEABLE : True
    ALIGNED : True
    UPDATEIFCOPY : False

Как видно, массив a до транспонирования имел C_CONTIGUOUS : True и F_CONTIGUOUS : False т.е. был организован в C-стиле, после транспонирования он сменился на стиль Fortran: C_CONTIGUOUS : False и F_CONTIGUOUS : True.

Если параметр order установлен в значение 'A' и в качестве object указан массив с порядком отличным от 'F' или 'C', то результирующий массив не всегда будет иметь ожидаемый флаг 'C'. В редких случаях это так же может приводить к ошибкам.

Примеры

    >>> import numpy as np
    >>> 
    >>> np.array([1, 2, 3, 4, 5, 6, 7])
    array([1, 2, 3, 4, 5, 6, 7])
    >>> 
    >>>
    >>> #  Если элементы разного типа, то все они приводятся к наиболее общему:
    ... np.array([1, 1, 2, 2, 3.14, 3.14])
    array([ 1.  ,  1.  ,  2.  ,  2.  ,  3.14,  3.14])
    >>> 
    >>> np.array([1+1j, 1+1j, 2, 2, 3.14, 3.14])
    array([ 1.00+1.j,  1.00+1.j,  2.00+0.j,  2.00+0.j,  3.14+0.j,  3.14+0.j])
    >>> 
    >>>
    >>> np.array([[1, 2], [3, 4]])    #  Двумерный массив
    array([[1, 2],
        [3, 4]])
    >>> #  Создание трехмерного массива
    >>> np.array([[[1, 1], [2, 2]],    
    ...           [[3, 3], [4, 4]],
    ...           [[5, 5], [6, 6]]])
    array([[[1, 1],
            [2, 2]],

        [[3, 3],
            [4, 4]],

        [[5, 5],
            [6, 6]]])
    >>>
    >>>
    >>> #  Создание массива у которого минимум 2 измерения:
    ... a = np.array([1, 3, 5], ndmin = 2)
    >>> a
    array([[1, 3, 5]])
    >>>
    >>>
    >>> #  Указание типа данных массива:
    ... np.array([[1, 2], [3, 4]], dtype = complex)
    array([[ 1.+0.j,  2.+0.j],
        [ 3.+0.j,  4.+0.j]])
    >>> 
    >>>
    >>> #  Создание структурированного массива:
    ... y = np.array([(1, 1), (2, 4), (3, 9), (4, 16)], dtype = [('x','i2'),('f_x','f4')])
    >>> y['x']
    array([1, 2, 3, 4], dtype=int16)
    >>> y['f_x']
    array([  1.,   4.,   9.,  16.], dtype=float32)
    >>> 
    >>> 
    >>> #  Создание массивов с использованием подклассов:
    ... np.array(np.mat('1 1 1; 2 2 2; 3 3 3'))
    array([[1, 1, 1],
        [2, 2, 2],
        [3, 3, 3]])
    >>> 
    >>> np.array(np.mat('1 1 1; 2 2 2; 3 3 3'), subok = True)
    matrix([[1, 1, 1],
            [2, 2, 2],
            [3, 3, 3]])

### asarray()
Преобразует последовательность в массив NumPy.

__numpy.asarray__

    numpy.asarray(a, dtype=None, order=None)
Функция asarray() преобразует последовательность в массив NumPy.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. По умолчанию установлен в 'C'.

Возвращает:
+ результат - массив NumPy<br>
Интерпретация входных данных a, как массива NumPy. Если входные данные являются массивом NumPy, то никакое копирование данных не выполняется (эквивалентно array(a, dtype, copy=False, order=order)). Если входные данные являются подклассом ndarray, то возвращается базовый класс ndarray.

Смотрите так же: array, asanyarray, ascontiguousarray, asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> np.asarray(a)
    array([1, 2, 3])
    >>> 
    >>> b = [[1, 2], [3, 4]]
    >>> np.asarray(b)
    array([[1, 2],
        [3, 4]])
    >>> 
    >>> 
    >>> #  Массивы NumPy не копируются
    ... 
    >>> a = np.array([1, 2, 3])
    >>> b = np.asarray(a)
    >>> 
    >>> b is a    #  Данные в 'b' физически те же что и в 'a'
    True
    >>> a[0] = 77    #  Изменения в массиве 'a'
    >>> a
    array([77,  2,  3])
    >>>
    >>> b    #  Повлекут за собой изменения в массиве 'b'
    array([77,  2,  3])
    >>> 
    >>> 
    >>> #  Копирование происходит только
    ... #  при несоответствии типов данных массивов
    ... a = np.array([1,2,3], dtype = np.int8)    #  одинаковые типы данных
    >>> b = np.asarray(a, dtype = np.int8)
    >>> b is a
    True
    >>> 
    >>> b = np.asarray(a, dtype = np.float32)    #  разные типы данных
    >>> b is a
    False
    >>> 
    >>> 
    >>> #  Вместо подкласса будет возвращен базовый класс:
    ... a = np.mat('1 1; 2 2')
    >>> a
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> b = np.asarray(a)
    >>> b
    array([[1, 1],
        [2, 2]])
    >>> 
    >>> 
    >>> #  Список массивов преобразуется в массив:
    ... a = np.array([1, 1])
    >>> b = np.array([2, 2])
    >>> 
    >>> c = [a, b]
    >>> 
    >>> d = np.asarray(c)
    >>> d
    array([[1, 1],
        [2, 2]])

### asanyarray()
Преобразует последовательность в массив NumPy, пропуская подклассы ndarray.

__numpy.asanyarray__

    numpy.asanyarray(a, dtype=None, order=None)

Функция asanyarray() преобразует последовательность в массив NumPy, не приводя подклассы ndarray к базовому классу.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. По умолчанию установлен в 'C'.

Возвращает:
+ результат - массив NumPy<br>
Интерпретация входных данных a, как массива NumPy. Если a является объектом ndarray или его подклассом, то он не копируется и возвращается в неизменном виде (эквивалентно array(a, dtype, copy=False, order=order, subok=True)).

Смотрите так же: array, asarray, ascontiguousarray, asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> np.asanyarray(a)
    array([1, 2, 3])
    >>> 
    >>> 
    >>> #  Массивы NumPy не копируются:
    ... a = np.array([1, 2, 3])
    >>> b = np.asanyarray(a)
    >>> 
    >>> b is a    #  Данные в 'b' физически те же что и в 'a'
    True
    >>> a[0] = 77    #  Изменения в массиве 'a'
    >>> a
    array([77,  2,  3])
    >>> 
    >>> b    #  Повлекут за собой изменения в массиве 'b'
    array([77,  2,  3])
    >>>
    >>>
    >>> #  Копирование происходит только
    ... #  при несоответствии типов данных массивов
    ... 
    >>> a = np.array([1,2,3], dtype = np.int8)
    >>> b = np.asanyarray(a, dtype = np.int8)
    >>> b is a
    True
    >>> 
    >>> b = np.asanyarray(a, dtype = np.float32)
    >>> b is a
    False
    >>> 
    >>> 
    >>> #  Подкласс будет возвращен как есть:
    ... a = np.mat('1 1; 2 2')
    >>> a
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> b = np.asanyarray(a)
    >>> b
    matrix([[1, 1],
            [2, 2]])
    >>> 
    >>> 
    >>> #  Список массивов преобразуется в массив
    ... a = np.array([1, 1])
    >>> b = np.array([2, 2])
    >>> c = [a, b]
    >>> 
    >>> d = np.asanyarray(c)
    >>> d
    array([[1, 1],
        [2, 2]])

### ascontiguousarray()

Возвращает непрерывный массив в памяти с организацией порядка элементов в С-стиле.

__numpy.ascontiguousarray__

    numpy.ascontiguousarray(a, dtype=None)

Функция ascontiguousarray() возвращает непрерывный массив в памяти с организацией порядка элементов в С-стиле.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

Возвращает:
+ результат - массив NumPy<br>
Интерпретирует входные данные a как массив NumPy, с порядком организации в памяти в С-стиле (эквивалентно array(a, dtype, copy=False, order='C', ndmin=1)). Если в качестве a передан существующий массив NumPy, с порядком организации в памяти отличным от C-стиля, то он будет к нему приведен. Если указать параметр dtype, то он изменит тип данных выходного массива.

Смотрите так же: asfortranarray

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательностей в массив NumPy:
    ... a = [1, 2, 3]
    >>> 
    >>>np.ascontiguousarray(a)
    array([1, 2, 3])
    >>>
    >>> 
    >>> #  Создаваемые массивы имеют порядок в С-стиле:
    ... a = np.array([[1, 2], [3, 4]])
    >>> a
    array([[1, 2],
        [3, 4]])
    >>>
    >>> a.flags['C_CONTIGUOUS']
    True
    >>> 
    >>> b = a.T    #  Транспонирование меняет порядок с 'C' на 'F':
    >>> b
    array([[1, 3],
        [2, 4]])
    >>> 
    >>> b.flags['C_CONTIGUOUS']
    False
    >>> 
    >>>  #  Мы можем изменить порядок на 'C':
    ... b = np.ascontiguousarray(b)
    >>> b.flags['C_CONTIGUOUS']
    True
    >>> b    #  Не изменяя форму и содержимое самого массива
    array([[1, 3],
        [2, 4]])


### asmatrix()
Интерпретирует входные данные как матрицу.

__numpy.asmatrix__

    numpy.asmatrix(a, dtype=None)

Функция asmatrix() интерпретирует входные данные как матрицу.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ dtype - тип данных NumPy (необязательный)

Возвращает:
+ результат - матрица NumPy<br>
Интерпретация входных данных a, как матрицы NumPy.

Смотрите так же: mat, bmat

Замечание

В отличие от функции matrix, функция asmatrix не выполняет копирования объектов ясли они уже являются матрицами или объектами ndarray, т.е. функция asmatrix эквивалентна matrix(a, copy = False).

Примеры

    >>> import numpy as np
    >>> 
    >>> #  Преобразование последовательности в матрицу:
    >>> a = [1, 2]
    >>> 
    >>> np.asmatrix(a)
    matrix([[1, 2]])
    >>> 
    >>>
    >>> b = np.array([[1, 2], [3, 4]])
    >>> 
    >>> #  Преобразование массива в матрицу не выполняет копирования:
    >>> c = np.asmatrix(b)
    >>> c
    matrix([[1, 2],
            [3, 4]])
    >>> 
    >>> c is b
    False
    >>> 
    >>> b[0,0] = 77    #  Изменение в 'b'
    >>> b
    array([[77,  2],
        [ 3,  4]])
    >>> 
    >>> c    #  Приведет к изменениям в 'c'
    matrix([[77,  2],
            [ 3,  4]])

### copy()
Возвращает копию массива.

__numpy.copy__

    numpy.copy(a, order='K')

Функция copy() возвращает массив-копию указанного объекта.

Параметры:
+ a - некоторая последовательность<br>
Входные данные которые могут быть преобразованы в массив: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ order - 'C', 'F', 'A' или 'K' (необязательный)<br>
Этот параметр определяет в каком порядке копия массива должна храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'. Флаг 'K', используемый по умолчанию, устанавливает макет памяти выходного массива аналогичный массиву a.
Возвращает:
+ результат - массив NumPy<br>
Интерпретирует входные данные a как массив NumPy и делает их полную копию

Смотрите так же: array, copyto

Замечание

Функции numpy.copy(a, order='K') и ndarray.copy(order='C') очень похожи, но имеют разные, установленные по умолчанию, параметры order. Функция numpy.copy(a, order='K') так же эквивалентна np.array(a, copy=True).

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1, 2, 3, 4, 5])
    >>> 
    >>> b = a    #  'b' - это указатель на данные из 'a'
    >>> 
    >>> a
    array([1, 2, 3, 4, 5])
    >>> b
    array([1, 2, 3, 4, 5])
    >>> 
    >>> b is a    #  Это один и тот же объект
    True
    >>>
    >>> a[0] = 111     #  Изменения в 'a'
    >>> a
    array([111,   2,   3,   4,   5])
    >>>
    >>> b    #  Повлекут изменения в 'b'
    array([111,   2,   3,   4,   5])
    >>> 
    >>> c = np.copy(a)    #  'c' - это копия 'a'
    >>> 
    >>> a
    array([111,   2,   3,   4,   5])
    >>> c
    array([111,   2,   3,   4,   5])
    >>> 
    >>> c is a    #  Это два разных объекта
    False
    >>> 
    >>> a[0] = 999     #  Изменения в 'a'
    >>> a
    array([999,   2,   3,   4,   5])
    >>>
    >>> c     #  Никак не отразятся в 'с'
    array([111,   2,   3,   4,   5])

### frombuffer()
Преобразует буфер в одномерный массив.

__numpy.frombuffer__

    numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)

Функция frombuffer() интерпретирует буфер как одномерный массив.

Параметры:
+ buffer - буфер-подобный объект<br>
Объект, который имеет интерфейс буфера.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. По умолчанию float.
+ count - целое число (необязательный)<br>
Количество считываемых элементов из буфера. По умолчанию count=-1, что означает чтение всех данных из буфера.
+ offset - целое число (необязательный)<br>
Задает позицию начала чтения из буфера. По умолчанию offset=0

Возвращает:
+ результат - массив NumPy<br>
Интерпретация данных из буфера, как одномерного массива NumPy.

Смотрите так же: fromfile, fromfunction, fromstring, fromiter

Замечание

Если данные в буфере находятся не в машинном байтовом порядке, то это должно быть указано в типе данных:

    >>> dt = np.dtype(np.unicode)
    >>> dt = dt.newbyteorder('<')
    >>> np.frombuffer(buffer, dtype=dt)

Данные результирующего массива не будут разбиты на байты, но будут правильно интерпретироваться.

Примеры

    >>> import numpy as np
    >>> s1 = b'abcdefg'
    >>> 
    >>> np.frombuffer(s1, dtype = 'S1')
    array([b'a', b'b', b'c', b'd', b'e', b'f', b'g'], 
        dtype='|S1')
    >>> 
    >>> s2 = b'\x01\x02\x03\x04\x05\x06\x07'
    >>>
    >>> np.frombuffer(s2, dtype=np.int8)
    array([1, 2, 3, 4, 5, 6, 7], dtype=int8)
    >>>
    >>> np.frombuffer(s2, dtype=np.int8, count = 3, offset = 2)
    array([3, 4, 5], dtype=int8)

### fromfile()
Создает массив из текстового или двоичного файла.

__numpy.fromfile__

    numpy.fromfile(file, dtype=float, count=-1, sep='')

Функция fromfile() создает массив из данных в текстовом или двоичном файле.<br> Является очень эффективным методом чтения двоичных данных с известным типом данных, а так же чтения текстовых файлов с простым форматированием.<br> Данные, написанные с использованием метода tofile, так же могут быть прочитаны с использованием этой функции.

Параметры:
+ file - файл или строка с именем файла<br>
Файл или файловый объект.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Для двоичных файлов он используется что бы определить размер и порядок байтов элементов в файле.
+ count - целое число (необязательный)<br>
Определяет количество считываемых элементов из файла. По умолчанию count=-1 что означает все элементы, т.е. весь файл целиком.
+ sep - строка-разделитель<br>
Разделитель между элементами в текстовом файле. Если sep = '' указывает на то что файл следует рассматривать как двоичный.

Возвращает:
+ результат - массив NumPy<br>
Массив, созданный из данных, находящихся в текстовом или двоичном файле.

Смотрите так же: frombuffer, fromfunction, fromstring, fromiter

Замечание

При использовании двоичных файлов на разных платформах следует помнить, что хранение данных в двоичных файлах зависит от используемой платформы, и ко всему прочему информация о порядке байтов и типе данных в них не сохраняется. Данные удобно хранить в независимом от платформы формате .npy, с использованием функций save и load.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([1,2,3], dtype = int)
    >>>
    >>> #  Создание двоичного файла:
    ... a.tofile('file_name')
    >>> 
    >>> #  Создание массива из данных в двоичном файле:
    ... b = np.fromfile('a', dtype = int )
    >>> b
    array([1, 2, 3])
    >>> 
    >>> 
    >>> #  Создание текстового файла:
    ... np.savetxt('file_name', a, newline=',')
    >>>
    >>> #  Создание массива из данных в текстовом файле:
    ... c = np.fromfile('file_name', sep = ',')
    >>> c
    array([ 1.,  2.,  3.])

### fromfunction()
Создает массив с выполнением указанной функции над каждым элементом.

__numpy.fromfunction__

    numpy.fromfunction(function, shape, **kwargs)

Функция fromfunction() создает массив, выполняя функцию над каждым элементом.

Параметры:
+ function - подлежащая выполнению функция<br>

Функция может содержать N параметров, при этом количество параметров определяет размерность выходного массива.<br> Каждый из N параметров перебирает элементы вдоль определенной оси.<br> Например, если мы используем два параметра, и указываем размеры массива (3, 3), то один из параметров пробегал бы значения массива

    array([[0,0,0],[1,1,1],[2,2,2]]),

а другой значения массива
    
    array([[0,1,2],[0,1,2],[0,1,2],])

+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.

Возвращает:
+ результат - массив NumPy<br>
Массив все элементы которого представляют собой результат работы указанной функции.

Смотрите так же: frombuffer, fromfile, fromstring, fromiter

Примеры

    >>> import numpy as np
    >>> 
    >>> np.fromfunction(lambda x, y: x == y, (4,4), dtype = int)
    array([[ True, False, False, False],
        [False,  True, False, False],
        [False, False,  True, False],
        [False, False, False,  True]], dtype=bool)
    >>> 
    >>> np.fromfunction(lambda x, y: x + 0*y, (4,4), dtype = int)
    array([[0, 0, 0, 0],
        [1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3]])
    >>> 
    >>> np.fromfunction(lambda x, y: 0*x + y, (4,4), dtype = int)
    array([[0, 1, 2, 3],
        [0, 1, 2, 3],
        [0, 1, 2, 3],
        [0, 1, 2, 3]])
    >>> 
    >>> np.fromfunction(lambda x, y: x + y, (4,4), dtype = int)
    array([[0, 1, 2, 3],
        [1, 2, 3, 4],
        [2, 3, 4, 5],
        [3, 4, 5, 6]])
    >>> 
    >>> np.fromfunction(lambda x, y: x**2 + y**2, (4,4), dtype = int)
    array([[ 0,  1,  4,  9],
        [ 1,  2,  5, 10],
        [ 4,  5,  8, 13],
        [ 9, 10, 13, 18]])

### fromiter()
Создает одномерный массив из итерируемого объекта.

__numpy.fromiter__

    numpy.fromiter(iterable, dtype, count=-1)

Функция fromiter() создает одномерный массив из итерируемого объекта.

Параметры:
+ iterable - итерируемый объект.<br>
Объект, который поддерживает интерфейс итераций.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ count - целое число (необязательный)<br>
Количество считываемых элементов из объекта. По умолчанию count=-1, что означает чтение всех элементов.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив значений из указанного итерируемого объекта.

Смотрите так же: frombuffer, fromfile, fromstring, fromfunction

Замечание

Если количество элементов в итерируемом объекте известно, то указав его в параметре count, можно немного повысить производительность функции fromiter. данный параметр позволяет сразу создать выходной массив и затем заполнять его, а не изменять его каждый раз с добавлением нового элемента.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = range(10)
    >>> 
    >>> np.fromiter(a, dtype = int)
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>> 
    >>> 
    >>> b = [2*x + 1 for x in range(10)]
    >>> b
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    >>> 
    >>> np.fromiter(b, dtype = int)
    array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19])

### fromstring()
Создает одномерный массив из строки.

__numpy.fromstring__

    numpy.fromstring(string, dtype=float, count=-1, sep='')

Функция fromstring() создает новый одномерный массив, который заполнен данными из указанной строки.

Параметры:
+ string - строка<br>
Строка с данными, например '1, 2, 3, 4,'
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. По умолчанию float. Для двоичных данных должен быть указан обязательно.
+ count - целое число (необязательный)<br>
Указывает количество считываемых элементов указанного типа из строки. По умолчанию count=-1, что означает считываение всех данных из строки.
+ sep - строка-разделитель (необязательный)<br>
Разделитель между элементами в строке. Если sep = '' указывает на то, что данные в строке следует рассматривать как двоичные.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив заполненный данными из указанной строки.

Смотрите так же: frombuffer, fromfile, fromiter, fromfunction

Примеры

    >>> import numpy as np
    >>> 
    >>> np.fromstring('1 2 3 4 5', dtype = int, sep = ' ')
    array([1, 2, 3, 4, 5])
    >>> 
    >>> a = '1, 2, 3, 4, 5, 6, 7'
    >>> 
    >>> np.fromstring(a, dtype = int, sep = ', ')
    array([1, 2, 3, 4, 5, 6, 7])
    >>> 
    >>> np.fromstring(a, dtype = int, count = 3, sep = ', ')
    array([1, 2, 3])

### loadtxt()
Создает массив из данных в текстовом файле.

__numpy.loadtxt__

    numpy.loadtxt(fname, dtype='float', comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes')

Функция loadtxt() создает новый массив из данных в текстовом файле.

Параметры:
+ fname - файл или строка с именем файла<br>
Файл, файловый объект.<br> Если расширение имени файла - .gz или .bz2, то файл сначала распаковывается.<br> Для Python3.X файловые объекты должны возвращать строки байтов.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.<br> По умолчанию float. <br>Если в файле находятся структурированные данные, т.е. структурированный тип данных, то результирующий массив будет одномерным, а каждая строка файла станет его отдельным элементом. <br>В этом случае, необходимо определить структурированный тип данных, количество полей в котором должно соответствовать количеству колонок в текстовом файле.
+ comments - строка или последовательность строк (необязательный)<br>
Символы или список символов, используемых для указания начала строк-комментариев.<br> Байтовые строки декодируются как Latin-1.<br> По умолчанию используется символ '#'.
+ delimiter - строка (необязательный)<br>
Строка-разделитель между значениями в текстовом файле. Байтовые строки декодируются как Latin-1. По умолчанию используется пробел.
+ converters - словарь (необязательный)<br>
Словарь, в качестве ключей которого используются целые числа соответствующие столбцам данных в файле. <br>Значение ключа сопоставляет соответствующий ключу столбец с соответствующей ключу функцией конвертирования. 
Например:

    converters = {3: lambda x: float(x.lstrip('$') or 0)}.

+ skiprows - целое число (необязательный)<br>
Указывает количество строк, которые необходимо пропустить. По умолчанию равно 0.
+ usecols - целое число или кортеж целых чисел (необязательный)<br>
Указывает какие столбцы будут считаны. <br>Первый столбец имеет номер 0. <br>По умолчанию usecols=None что соответствует чтению всех столбцов в файле. <br>Целое число, например usecols=1 так же как и кортеж с одним значением usecols=(1,) приведет к считыванию единственного из всех столбца в файле, т.е. будет прочитан только второй столбец.
+ unpack - True или False (необязательный)<br>
Если этот параметр равен True, то все столбцы текстового файла могут быть разделены и распакованы с помощью a, b, c = loadtxt(...). <br>Использование структурированного типа данных приводит к тому, что для каждого отдельного поля будет возвращен отдельный массив. <br>По умолчанию unpack=False
+ ndmin - целое число (необязательный)<br>
Определяет минимальную размерность возвращаемого массива. По умолчанию ndmin=0 что соответствует сжатию всех осей длинной 1, до одной оси.

Возвращает:
+ результат - массив NumPy<br>
Массив неициированных (случайных) значений, указанной формы, типа и порядка.

Смотрите так же: fromfile

Замечание

Данная функция предназначена для быстрого чтения данных в простом текстовом формате. Все строки в текстовом файле должны иметь одинаковое количество значений. Функция genfromtxt может обеспечить чтение данных из текстовых файлов с более сложным форматом.

Примеры

Для примера создадим небольшой текстовый файл loadtxt_example.txt из 6 колонок: "Атомный номер", "Обозначение элемента", "Группа", "Период", "Атомная масса", "Радиус атома".

    #  Некоторые данные о 15 химических элементах.
    #  Сдесь представлены: "Атомный номер", 
    #  "Обозначение элемента", "Группа", "Период", 
    #  "Атомный масса", "Радиус атома (pm)"


    1 H 7 1 1.00797 25
    2 He 8 1 4.0026 30
    3 Li 1 2 6.939 145
    4 Be 2 2 9.0122 105
    5 B 3 2 10.811 85
    6 C 4 2 12.01115 70
    7 N 5 2 14.0067 65
    8 O 6 2 - 60
    9 F 7 2 18.9984 50
    10 Ne 8 2 20.179 40
    11 Na 1 3 22.9898 180
    12 Mg 2 3 24.305 150
    13 Al 3 3 26.9815 125
    14 Si 4 3 28.086 110
    15 P 5 3 - 100

В данном примере текстовый файл находится в той же директории, в которой происходит выполнение скрипта Python.

    >>> import numpy as np
    >>> 
    >>> fname = 'loadtxt_example.txt'
    >>> 
    >>> dt_1 = np.dtype([('№','i2'),('symbol','|S2'),('radius','i2'),])
    >>> 
    >>> a = np.loadtxt(fname, dtype=dt_1, skiprows=6, usecols=(0,1,5))
    >>> 
    >>> a
    array([(1, b'H', 25), (2, b'He', 30), (3, b'Li', 145), (4, b'Be', 105),
        (5, b'B', 85), (6, b'C', 70), (7, b'N', 65), (8, b'O', 60),
        (9, b'F', 50), (10, b'Ne', 40), (11, b'Na', 180), (12, b'Mg', 150),
        (13, b'Al', 125), (14, b'Si', 110), (15, b'P', 100)], 
        dtype=[('№', '<i2'), ('symbol', 'S2'), ('radius', '<i2')])
    >>> 
    >>> 
    >>> 
    >>> def parse_mas(s):
            try:
                return float(s)
            except ValueError:
                return np.nan
    >>> 
    >>> dt_2 = np.dtype([('№','i2'),('symbol','|S2'),('mass','f4'),])
    >>> 
    >>> b = np.loadtxt(fname, dtype=dt_2, skiprows=6, usecols=(0,1,4), converters={4: parse_mas})
    >>> 
    >>> b
    array([(1, b'H', 1.0079699754714966), (2, b'He', 4.002600193023682),
        (3, b'Li', 6.939000129699707), (4, b'Be', 9.012200355529785),
        (5, b'B', 10.810999870300293), (6, b'C', 12.011150360107422),
        (7, b'N', 14.006699562072754), (8, b'O', nan),
        (9, b'F', 18.99839973449707), (10, b'Ne', 20.179000854492188),
        (11, b'Na', 22.98979949951172), (12, b'Mg', 24.30500030517578),
        (13, b'Al', 26.98150062561035), (14, b'Si', 28.086000442504883),
        (15, b'P', nan)], 
        dtype=[('№', '<i2'), ('symbol', 'S2'), ('mass', '<f4')])
    >>> 
    >>> 
    >>> dt_3 = np.dtype([('symbol','|S2'),('radius','i2'),])
    >>> 
    >>> a, b = np.loadtxt(fname, dtype=dt_3, skiprows=6, usecols=(1,5), unpack = True)
    >>> 
    >>> a
    array([b'H', b'He', b'Li', b'Be', b'B', b'C', b'N', b'O', b'F', b'Ne',
        b'Na', b'Mg', b'Al', b'Si', b'P'], 
        dtype='|S2')
    >>> 
    >>> b
    array([ 25,  30, 145, 105,  85,  70,  65,  60,  50,  40, 180, 150, 125,
        110, 100], dtype=int16)


## 1.3. Создание массивов записей

### core.records.array()
Создает массив записей из указанного объекта.

__numpy.core.records.array__

    numpy.core.records.array(object, dtype=None, shape=None, offset=0, strides=None, formats=None, names=None, titles=None, aligned=False, byteorder=None, copy=True)

Функция core.records.array() создает массив записей из массивов и других массиво-подобных объектов.

Параметры:
+ object - подобный массиву объект<br>
Список или кортеж, а так же любая функция или объект с методом, возвращаеющие список или кортеж.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ strides - кортеж целых чисел (необязательный)<br>
Целые числа определяют сколько байтов в памяти занимает каждый элемент массива.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например:

    ['U2','i2','f4','f2']. 

Указание типов данных напрямую, например:

    [int, complex, int, int, float]

не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. <br>При этом имена и псевдонимы эквивалентны, например, если имя полей массива
    a ['p', 'q'], 

а псевдонимы полей 

    ['p_prime', 'q-prime'],

то a['p'] эквивалентно a['p_prime'].

+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (dtype, order и т.д.)

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей, созданный из указанного объекта.

Смотрите так же: core.records.fromarrays, core.records.fromfile, core.records.fromrecords, core.records.fromstring

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> 
    >>> np.core.records.array(a)
    rec.array([[1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]], 
            dtype=int32)
    >>> 
    >>> b = [(1, 1), (2, 4), (3, 9)]
    >>> c = np.core.records.array(b, formats = ['i2', 'f2'], names = ('x', 'y'))
    >>> 
    >>> c
    rec.array([(1, 1.0), (2, 4.0), (3, 9.0)], 
            dtype=[('x', '<i2'), ('y', '<f2')])
    >>> 
    >>> c['x']
    array([1, 2, 3], dtype=int16)
    >>> 
    >>> c['y']
    array([ 1.,  4.,  9.], dtype=float16)

### core.records.fromarrays()
Создает массив записей из одномерных массивов.

__numpy.core.records.fromarrays__

    numpy.core.records.fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromarrays() создает массив записей из списка массивов.

Параметры:
+ arrayList - список массивов<br>
Список одномерных массивов с одинаковым количество элементов .
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей свормированный из списка массивов.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromrecords, core.records.fromstring

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array(['x1', 'x2', 'x3', 'x4'])
    >>> b = np.array([1, 2, 3, 4])
    >>> c = np.array(['y1', 'y2', 'y3', 'y4'])
    >>> d = np.array([1, 4, 9, 16])
    >>> 
    >>> rec = np.core.records.fromarrays([a,b,c,d],formats = ['U2','i2','U2','f2',], names='a,b,c,d')
    >>> 
    >>> 
    >>> rec
    rec.array([('x1', 1, 'y1', 1.0), ('x2', 2, 'y2', 4.0), ('x3', 3, 'y3', 9.0),
    ('x4', 4, 'y4', 16.0)], 
            dtype=[('a', '<U2'), ('b', '<i2'), ('c', '<U2'), ('d', '<f2')])
    >>> 
    >>> rec[1]
    ('x2', 2, 'y2', 4.0)
    >>> 
    >>> rec[2]
    ('x3', 3, 'y3', 9.0)
    >>> 
    >>> 
    >>> rec.a
    array(['x1', 'x2', 'x3', 'x4'], 
        dtype='<U2')
    >>> 
    >>> rec.b
    array([1, 2, 3, 4], dtype=int16)

### core.records.fromrecords()
Создает массив записей из списка записей в текстовой форме.

__numpy.core.records.fromrecords__

    numpy.core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromrecords() создает массив записей из списка записей.

Параметры:
+ recList - список записей<br>
Список записей с одинаковым количество элементов.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается.<br> Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Массив записей сформированный из списка записей.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromarrays, core.records.fromstring

Замечание

Данные одного и того же поля могут быть абсолютно разными (гетерогенными), им будет присвоен наиболее общий тип данных. Данная функция удобна для создания небольших массивов записей. Если она используется для создания больших массивов записей, еще и без определения параметра formats (может определяться автоматически), то это может занять довольно много времени. Использование списка кортежей немного ускоряет процесс создания.

Примеры

    >>> import numpy as np
    >>> 
    >>> rec = np.core.records.fromrecords([('x1', 1, 'y1' ,1),
                                        ('x2', 2, 'y2', 4),
                                        ('x3', 3, 'y3', 9),
                                        ('x4', 4, 'y4', 16)],
                                        formats = ['U2', 'i2', 'U2', 'f2'],
                                        names='a, b, c, d')
    >>> 
    >>> rec
    rec.array([('x1', 1, 'y1', 1.0), ('x2', 2, 'y2', 4.0), ('x3', 3, 'y3', 9.0),
    ('x4', 4, 'y4', 16.0)], 
            dtype=[('a', '<U2'), ('b', '<i2'), ('c', '<U2'), ('d', '<f2')])
    >>> 
    >>> rec[1]
    ('x2', 2, 'y2', 4.0)
    >>> 
    >>> rec[2]
    ('x3', 3, 'y3', 9.0)
    >>> 
    >>> rec.a
    array(['x1', 'x2', 'x3', 'x4'], 
        dtype='<U2')
    >>> 
    >>> rec.b
    array([1, 2, 3, 4], dtype=int16)
    >>> 
    >>> rec.col1
    array([ 1.,  2.,  3.])
    >>> 
    >>> rec.col2
    array(['3.14', '-', '(5+2j)'], 
        dtype='<U32')


### core.records.fromstring()
Создает (только для чтения) массив записей из двоичных данных, находящихся в строке.

__numpy.core.records.fromstring__

    numpy.core.records.fromstring(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromstring() создает массив записей из двоичных данных, находящихся в строке.

Параметры:
+ datastring - строка<br>
Строка с двоичными данными.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается. Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Интерпретация двоичных данных в строке как массива записей.

Смотрите так же: core.records.array, core.records.fromfile, core.records.fromarrays, core.records.fromrecords

Замечание

Двоичные данные в строке разделяются на поля в соответствии с количеством байтов отведенным под каждое поле, т.е. если формат записи определен как formats = ['i2', 'i2'], то каждые 4 байта в строке будут интерпретироваться как одна запись массива.

Примеры

    >>> a = b'\x01\x00\x02\x00'
    >>> np.core.records.fromstring(a, formats = ['i2', 'i2'], names = 'x, y')
    rec.array([(1, 2)], 
            dtype=[('x', '<i2'), ('y', '<i2')])
    >>> 
    >>> a = b'\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00'
    >>> 
    >>> rec1 = np.core.records.fromstring(a, formats = ['i2', 'i2'], names = 'x, y')
    >>> 
    >>> rec1
    rec.array([(1, 2), (3, 4), (5, 6)], 
            dtype=[('x', '<i2'), ('y', '<i2')])
    >>> 
    >>> rec2 = np.core.records.fromstring(a, formats = ['i2', 'i4'], names = 'x, y')
    >>> rec2
    rec.array([(1, 196610), (4, 393221)], 
            dtype=[('x', '<i2'), ('y', '<i4')])
    >>>
    >>> rec1.x
    array([1, 3, 5], dtype=int16)
    >>> 
    >>> rec2.y
    array([196610, 393221])

### core.records.fromfile()
Создает массив записей из файла с двоичными данными.

__numpy.core.records.fromfile__

    numpy.core.records.fromfile(fd, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)

Функция core.records.fromfile() создает массив записей из двоичных данных, находящихся в файле.

Параметры:
+ fd - файловый объект<br>
Объект файла, который поддерживает произвольный доступ.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива.
+ shape - целое число, список или кортеж целых чисел<br>
Задает размеры необходимого массива - целое число или кортеж целых чисел.
+ offset - целое число (необязательный)<br>
Задает смещение с которого начинается чтение буфера.
+ formats - список типов данных (необязательный)<br>
Список (не кортеж) типов данных для каждого поля (столбца), например, ['U2','i2','f4','f2']. Указание типов данных напрямую, например [int, complex, int, int, float] не поддерживается. Учитывая, что символьные форматы типов данных несколько ограничены, рекомендуется использовать определение типов через класс dtype.
+ names - кортеж строк (необязательный)<br>
Определяет имя каждого поля массива записей.
+ titles - кортеж строк (необязательный)<br>
Псевдонимы имен столбцов, которые могут использоваться для уточнения имен столбцов или их назначения. При этом имена и псевдонимы эквивалентны, например, если имя полей массива a ['p', 'q'], а псевдонимы полей ['p_prime', 'q-prime'], то a['p'] эквивалентно a['p_prime'].
+ aligned - True или False (необязательный)<br>
Выравнивает поля в памяти так же как это делает С-компилятор. По умолчанию aligned=False.
+ byteorder - {‘<’, ‘>’, ‘=’} (необязательный)<br>
Определяет порядок байтов для всех полей.

Возвращает:
+ результат - массив записей NumPy<br>
Интерпретация двоичных данных в файле как массива записей.

Смотрите так же: core.records.array, core.records.fromstring, core.records.fromarrays, core.records.fromrecords

Примеры

    >>> import numpy as np
    >>> 
    >>> a = np.array([('x1', 1), ('x2', 2), ('x3', 3),], dtype = 'U2,f4')
    >>> 
    >>> a
    array([('x1', 1.0), ('x2', 2.0), ('x3', 3.0)], 
        dtype=[('f0', '<U2'), ('f1', '<f4')])
    >>> 
    >>> a.tofile('file_name')    #  Помещаем 'a' в двоичный файл
    >>> 
    >>>
    >>> #  Создание массива записей из данных в двоичном файле
    ... rec = np.core.records.fromfile('file_name', formats='U2,f4', names = 'x, n')
    >>> rec
    rec.array([('x1', 1.0), ('x2', 2.0), ('x3', 3.0)], 
            dtype=[('x', '<U2'), ('n', '<f4')])
    >>> 
    >>> rec.x
    array(['x1', 'x2', 'x3'], 
        dtype='<U2')
    >>> rec.n
    array([ 1.,  2.,  3.], dtype=float32)

## 1.4. Создание массивов символов

### core.defchararray.array()
Создает массив символов chararray.

__numpy.core.defchararray.array__

    numpy.core.defchararray.array(obj, itemsize=None, copy=True, unicode=None, order=None)

Функция core.defchararray.array() создает массив символов.

Параметры:
+ obj - последовательность строк<br>
Любая последовательность, которая может быть интерпретирована как массив или сам массив NumPy значениями которого являются строки, в том числе и строки символов юникода.
+ itemsize - целое число (необязательный)<br>
Определяет количество символов на элемент результирующего массива. Определяется автоматически если itemsize=None и obj - массив или последовательность Python. Если параметр itemsize указан и obj является строкой, то obj будет разбит на указанное в itemsize количество частей.
+ copy - False или True (необязательный)<br>
Если этот параметр установлен в True (по умолчанию), то объект копируется. В противном случае копирование происходит только если метод __array__ объекта возвращает копию, если object является вложенной последовательностью, если треуется доступ к определенным параметрам массива (itemsize, unicode и т.д.)
+ unicode - False или True (необязательный)<br>
Если unicode = True, то результирующий массив может содержать символы юникода, если unicode = False, то только 8-битные символы. Если unicode = None то этот параметр, в зависимости от obj, будет определен автоматически.
+ order - 'C', 'F' или 'A' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran. Если object не является массивом NumPy, то созданный массив будет находиться в памяти в строковом С порядке, если указать флаг 'F', то будет храниться в столбчатом порядке 'Fortran'. Флаг 'A' установит макет памяти выходного массива в 'F' если массив a является смежным со столбчатым стилем Fortran, в противном случае макет памяти будет установлен в 'C'.

Возвращает:
+ результат - массив символов NumPy<br>
Массив символов, созданный из указанного объекта.

Смотрите так же: core.defchararray.asarray

Замечание

Эта функция предназначена для обратной совместимости со старыми версиями Numarray. Для быстрых векторных строков операций лучше использовать numpy.char.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = 'abcdef'
    >>> np.core.defchararray.array(a)
    chararray(['abcdef'], 
        dtype='<U6')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 1)
    chararray(['a', 'a', 'a', 'a', 'a', 'a'], 
        dtype='<U1')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 2)
    chararray(['ab', 'ab', 'ab'], 
        dtype='<U2')
    >>>
    >>> np.core.defchararray.array(a, itemsize = 3)
    chararray(['abc', 'abc'], 
        dtype='<U3')
    >>> 
    >>> 
    >>> a = ['a', 'b', 'c']
    >>> np.core.defchararray.array(a)
    chararray(['a', 'b', 'c'], 
        dtype='<U1')
    >>> 
    >>> 
    >>> d = [['a', 'b'], ['c', 'd']]
    >>> np.core.defchararray.array(d)
    chararray([['a', 'b'],
        ['c', 'd']], 
        dtype='<U1')
    >>>
    >>> # Пробелы с конца строки убираются автоматически
    ... d = [[' a ', ' b '], [' c ', ' d ']]
    >>> np.core.defchararray.array(d)
    chararray([[' a', ' b'],
        [' c', ' d']], 
        dtype='<U3')

### core.defchararray.asarray()
Преобразует последовательность в массив символов chararray.

__numpy.core.defchararray.asarray__

    numpy.core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)

Функция core.defchararray.asarray() преобразует входные данные в массив символов, при этом данные копируются только если эти входные данные уже не являются массивом символов.

Параметры:
+ obj - некоторая последовательность строк<br>
Входные данные которые могут быть преобразованы в массив символов: списки и кортежи, списки списков и кортежи кортежей, списки кортежей и кортежи списков, а так же кортежи или списки других массивов NumPy.
+ itemsize - целое число (необязательный)<br>
Определяет количество символов на элемент результирующего массива. Определяется автоматически если itemsize=None и obj - массив или последовательность Python. Если параметр itemsize указан и obj является строкой, то obj будет разбит на указанное в itemsize количество частей.
+ unicode - False или True (необязательный)<br>
Если unicode = True, то результирующий массив может содержать символы юникода, если unicode = False, то только 8-битные символы. Если unicode = None то этот параметр, в зависимости от obj, будет определен автоматически.
+ order - 'C' или 'F' (необязательный)<br>
Этот параметр определяет в каком порядке массивы должны храниться в памяти: строчном C-стиле или столбчатом стиле Fortran.

Возвращает:
+ результат - массив NumPy<br>
Массив символов, созданный из указанного объекта.

Смотрите так же: core.defchararray.array

Замечание

Эта функция предназначена для обратной совместимости со старыми версиями Numarray. Для быстрых векторных строков операций лучше использовать numpy.char.

Примеры

    >>> import numpy as np
    >>> 
    >>> a = ['a', 'b', 'c']
    >>>
    >>> np.core.defchararray.asarray(a)
    chararray(['a', 'b', 'c'], 
        dtype='<U1')
    >>> 
    >>> a = [(['a', 'b'], ['c', 'd']), (['d', 'c'], ['b', 'a'])]
    >>> 
    >>> np.core.defchararray.asarray(a)
    chararray([[['a', 'b'],
            ['c', 'd']],

        [['d', 'c'],
            ['b', 'a']]], 
        dtype='<U1')

## 1.5. Числовые диапазоны

### arange()
Возвращает одномерный массив с равномерно распределенными значениями внутри указанного интервала.

__numpy.arange__

    numpy.arange([start, ]stop, [step, ]dtype=None)

Функция arange() возвращает одномерный массив с равномерно разнесенными значениями внутри заданного интервала.

Параметры:
+ start - число (необязательный)<br>
Число, которое является началом интервала. По умолчанию равно 0.
+ stop - число<br>
Определяет конец интервала, при этом сам интервал это значение не включает. Если шаг (step) не является целым числом, то в некоторых случаях, из-за округление вещественных чисел указанное значение stop может оказаться включенным в интервал.
+ step - число (необязательный)<br>
Определяет интервал между значениями. По умолчанию равен 1. Если данный параметр указан, то значение start так же необходимо указать.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Массив равномерно разнесенных значений.

Смотрите так же: linspace, logspace, geomspace

Замечание

Интервал является полуоткрытым [start, stop), т.е. включает в себя значение start, но не включает значение stop. Если в качестве аргументов указаны вещественные числа, то длинна результата будет равна ceil((stop - start)/step). Из-за округления вещественных чисел, последний элемент выходного массива может оказаться больше значения stop.

Примеры

    >>> import numpy as np
    >>> 
    >>> np.arange(7)
    array([0, 1, 2, 3, 4, 5, 6])
    >>> 
    >>> np.arange(7.)
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.])
    >>> 
    >>> np.arange(15,22)
    array([15, 16, 17, 18, 19, 20, 21])
    >>> 
    >>> np.arange(10,30,2)
    array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28])
    >>> 
    >>> np.arange(0.1, 2.2, 0.3)
    array([ 0.1,  0.4,  0.7,  1. ,  1.3,  1.6,  1.9,  2.2])

### linspace()
Возвращает одномерный массив с равномерно распределенными значениями внутри указанного интервала.

__numpy.linspace__

    numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

Функция linspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны внутри заданного интервала.

Параметры:
+ start - число<br>
Число, которое является началом последовательности.
+ stop - число<br>
Число, которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение stop включается в интервал и является последним. В противном случае stop не входит в интервал. По умолчанию endpoint = True
+ retstep - True или False (необязательный)<br>
Если retstep = True, то будет возвращено значение шага между элементами.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра endpoint равномерно распределенны внутри закрытого ([start, stop]) или полуоткрытого ([start, stop)) интервала.
+ шаг - вещественное число (необязательно)<br>
Значение шага между элементами. Возвращается только в том случае, если retstep = True.

Смотрите так же: arange, logspace, geomspace

Примеры

    >>> np.linspace(0, 1)
    array([0.        , 0.02040816, 0.04081633, ..., 0.95918367, 0.97959184,
        1.        ])
    >>> 
    >>> np.linspace(0, 1, num = 5)
    array([0.  , 0.25, 0.5 , 0.75, 1.  ])
    >>> 
    >>> np.linspace(0, 1, num = 5, endpoint = False)
    array([0. , 0.2, 0.4, 0.6, 0.8])
    >>> 
    >>> np.linspace(0, 1, num = 5, endpoint = False, retstep = True)
    (array([0. , 0.2, 0.4, 0.6, 0.8]), 0.2)
    >>>
    >>>
    >>> #  На равные промежутки можно разбивать
    >>> #  интервалы комплексных чисел:
    >>> x = np.linspace(0+0j, 4+4j, 5)
    >>> x
    array([0.+0.j, 1.+1.j, 2.+2.j, 3.+3.j, 4.+4.j])

### logspace()
Возвращает одномерный массив значений, равномерно распределенных по логарифмической шкале.

__numpy.logspace__

    numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)

Функция logspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны по логарифмической шкале внутри заданного интервала.

Параметры:
+ start - вещественное число<br>
Число, которое является началом последовательности, которое равно base ** start (base в степени start).
+ stop - вещественное число<br>
Число (base ** stop), которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение base ** stop включается в интервал и является последним. В противном случае base ** stop не входит в интервал. По умолчанию endpoint = True
+ base - вещественное число (необязательный)<br>
Основание логарифмической шкалы. По умолчанию base = 10.
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра ndpoint равномерно распределенны по логарифмической шкале внутри закрытого ([base ** start, base ** stop]) или полуоткрытого ([base ** start, base ** stop)) интервала.

Смотрите так же: arange, linspace, geomspace

Примеры

    >>> np.logspace(0, 3)
    array([   1.        ,    1.1513954 ,    1.32571137, ...,  754.31200634,
            868.51137375, 1000.        ])
    >>> 
    >>> np.logspace(0, 3, num = 10)
    array([   1.        ,    2.15443469,    4.64158883,   10.        ,
            21.5443469 ,   46.41588834,  100.        ,  215.443469  ,
            464.15888336, 1000.        ])
    >>> 
    >>> np.logspace(0, 3, num = 10, endpoint = False)
    array([  1.        ,   1.99526231,   3.98107171,   7.94328235,
            15.84893192,  31.6227766 ,  63.09573445, 125.89254118,
        251.18864315, 501.18723363])
    >>> 
    >>> np.logspace(0, 10, num = 10, base = 2)
    array([1.00000000e+00, 2.16011948e+00, 4.66611616e+00, 1.00793684e+01,
        2.17726400e+01, 4.70315038e+01, 1.01593667e+02, 2.19454460e+02,
        4.74047853e+02, 1.02400000e+03])
    >>> 
    >>> np.logspace(0, 10, num = 10, base = np.e)
    array([1.00000000e+00, 3.03773178e+00, 9.22781435e+00, 2.80316249e+01,
        8.51525577e+01, 2.58670631e+02, 7.85771994e+02, 2.38696456e+03,
        7.25095809e+03, 2.20264658e+04])

### geomspace()
Возвращает одномерный массив значений, которые представляют собой геометрическую прогрессию.

__numpy.geomspace__
    
    numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None)

Функция geomspace() возвращает одномерный массив из указанного количества элементов, значения которых равномерно распределенны по шкале геометрической прогрессии внутри заданного интервала.

Параметры:
+ start - число<br>
Число, которое является началом последовательности.
+ stop - число<br>
Число, которое является концом последовательности, если endpoint=True. Если endpoint=False то данное число не включается в интервал, при этом значение шага между элементами последовательности изменяется.
+ num - целое положительное число (необязательный)<br>
Определяет количество элементов последовательности. По умолчанию num = 50.
+ endpoint - True или False (необязательный)<br>
Если endpoint = True, то значение stop включается в интервал и является последним. В противном случае stop не входит в интервал. По умолчанию endpoint = True
+ dtype - тип данных NumPy (необязательный)<br>
Определяет тип данных выходного массива. Если этот параметр не указан, то он будет определен автоматически на основе других параметров.

Возвращает:
+ результат - массив NumPy<br>
Одномерный массив из указанного количества элементов, значения которых, в зависимости от значения параметра ndpoint равномерно распределенны по шкале геометрической прогрессии внутри закрытого ([start, stop]) или полуоткрытого ([start, stop)) интервала.

Смотрите так же: arange, linspace, logspace

Замечание

Если входные параметры или параметр dtype являются комплексными числами, то значения элементов выходного массива будут расположены на логарифмической спирали в комплексной плоскости. Через две точки может проходить бесконечное количество спиралей, но значения будут расположены на той спирали, которая соединяет точки кратчайшим образом.

Примеры

    >>> np.geomspace(1, 32)
    array([ 1.        ,  1.07329065,  1.15195282, ..., 27.77891541,
        29.81485021, 32.        ])
    >>> 
    >>> np.geomspace(1, 32, num = 6)
    array([ 1.,  2.,  4.,  8., 16., 32.])
    >>> 
    >>> np.geomspace(1, 32, num = 6, endpoint = False)
    array([ 1.        ,  1.78179744,  3.1748021 ,  5.65685425, 10.0793684 ,
        17.95939277])

### meshgrid()
Создает список массивов координатных сеток.

__numpy.meshgrid__
    
    numpy.meshgrid(x1, x2,..., xn, **kwargs)

Функция meshgrid() создает список массивов координатных сеток N-мерного координатного пространства для указанных одномерных массивов координатных векторов. Координатное пространство - это пространство N-мерных точек-координат, причем каждой точке в таком пространстве соответствует комбинация одного значения из каждого координатного массива.

Параметры:
+ x1, x2,..., xn - последовательность<br>
Одномерные массивы, которые определяют координатную сетку.
+ indexing - ‘xy’, ‘ij’ (необязательный)<br>
Определяет декартово ‘xy’ (по умолчанию) или матричное ‘ij’ индексирование выходного массива.
+ sparse - True или False (необязательный)<br>
Если True, то для экономии памяти выводятся сжатые до одной оси массивы координатных сеток. По умолчанию sparse = False.
+ copy - True или False (необязательный)<br>
Если False, то для экономии памяти возвращается представление исходных координатных массивов. По умолчанию copy = True.

Возвращает:
+ [X1, X2, X3, ... , Xn] - список массивов NumPy<br>
Для N входных одномерных координатных векторов возвращается список массивов координатных cеток. <br>Если длинна координатных массивов len(x1) = L1; len(x2) = L2; len(xN) = LN, то при indexing = 'ij' размеры массивов координатных сеток будут равны (L1, L2, L3, ... , LN). <br>В случае, если параметр indexing = 'xy', то размеры массивов координатных сеток будут (L2, L1, L3, ... , LN), при этом повторение элементов так же окажется несколько инным.

В двумерном случае, когда длинна массива x1 равна M, а длинна вектора x2 равна N, то при indexing = 'xy' размеры массивов координатных сеток будут равны (N, M), а при indexing = 'ij' (M, N).

Допускаются случаи 0-мерного и 1-мерного пространства.

Смотрите так же: mgrid, ogrid

Замечание

Важно помнить, что если параметры sparse и copy равны False, то скорее всего будут возвращеные несмежные массивы. Кроме того, к одной ячейке памяти могут относиться несколько элементов транслируемого массива.

Примеры

    >>> import numpy as np
    >>> 
    >>> x = [1, 2, 3, 4, 5]
    >>> 
    >>> y = [0, 5, 10, 15, 20, 25, 30]
    >>> 
    >>> #  Список координатных сеток:
    ... XY = np.meshgrid(x, y)
    >>> XY
    [array([[1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5]]),
    array([[ 0,  0,  0,  0,  0],
        [ 5,  5,  5,  5,  5],
        [10, 10, 10, 10, 10],
        [15, 15, 15, 15, 15],
        [20, 20, 20, 20, 20],
        [25, 25, 25, 25, 25],
        [30, 30, 30, 30, 30]])]
    >>>
    >>> # Распаковка координатных сеток в отдельные массивы
    ... xy_grid, yx_grid = np.meshgrid(x, y)
    >>> 
    >>> xy_grid
    array([[1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5]])
    >>> 
    >>> xy_grid.shape, len(x), len(y)
    ((7, 5), 5, 7)
    >>> 
    >>> yx_grid
    array([[ 0,  0,  0,  0,  0],
        [ 5,  5,  5,  5,  5],
        [10, 10, 10, 10, 10],
        [15, 15, 15, 15, 15],
        [20, 20, 20, 20, 20],
        [25, 25, 25, 25, 25],
        [30, 30, 30, 30, 30]])
    >>> 
    >>> yx_grid.shape, len(x), len(y)
    ((7, 5), 5, 7)

Установка параметра indexing в значение 'ij', приводит к тому, что размеры массивов координатных сеток меняются, при этом несколько меняется и порядок повторения элементов:

    >>> x = [1, 2]
    >>> y = [0, 5, 10]
    >>> z = [0, 0.1, 0.2, 0.3]
    >>> 
    >>> XYZ_indexingXY = np.meshgrid(x, y, z)
    >>> XYZ_indexingXY
    [array([[[1, 1, 1, 1],
            [2, 2, 2, 2]],

            [[1, 1, 1, 1],
            [2, 2, 2, 2]],

            [[1, 1, 1, 1],
            [2, 2, 2, 2]]]), 

    array([[[ 0,  0,  0,  0],
            [ 0,  0,  0,  0]],

        [[ 5,  5,  5,  5],
            [ 5,  5,  5,  5]],

        [[10, 10, 10, 10],
            [10, 10, 10, 10]]]), 
            
    array([[[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]]])]
    >>> 
    >>>
    >>> XYZ_indexingIJ = np.meshgrid(x, y, z, indexing = 'ij')
    >>> XYZ_indexingIJ
    [array([[[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]],

            [[2, 2, 2, 2],
            [2, 2, 2, 2],
            [2, 2, 2, 2]]]), 
            
    array([[[ 0,  0,  0,  0],
            [ 5,  5,  5,  5],
            [10, 10, 10, 10]],

        [[ 0,  0,  0,  0],
            [ 5,  5,  5,  5],
            [10, 10, 10, 10]]]), 

    array([[[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]],

        [[ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3],
            [ 0. ,  0.1,  0.2,  0.3]]])]
    >>> 
    >>> XYZ_indexingXY[0].shape, XYZ_indexingXY[1].shape, XYZ_indexingXY[2].shape
    ((3, 2, 4), (3, 2, 4), (3, 2, 4))
    >>> 
    >>> XYZ_indexingIJ[0].shape, XYZ_indexingIJ[1].shape, XYZ_indexingIJ[2].shape
    ((2, 3, 4), (2, 3, 4), (2, 3, 4))

В случае большого количества длинных координатных векторов, результирующий массив координатного пространства будет иметь огромное количество элементов и, соответственно, занимать много памяти. В этом легко убедиться даже на трех небольших массивах:

    >>> x = [1, 2, 3]
    >>> y = [0, 5, 10, 15]
    >>> z = [0, 0.1, 0.2, 0.3, 0.4]
    >>> 
    >>> XYZ = np.meshgrid(x, y, z)
    >>> XYZ
    [array([[[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]],

        [[1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2],
            [3, 3, 3, 3, 3]]]),
    array([[[ 0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0]],

        [[ 5,  5,  5,  5,  5],
            [ 5,  5,  5,  5,  5],
            [ 5,  5,  5,  5,  5]],

        [[10, 10, 10, 10, 10],
            [10, 10, 10, 10, 10],
            [10, 10, 10, 10, 10]],

        [[15, 15, 15, 15, 15],
            [15, 15, 15, 15, 15],
            [15, 15, 15, 15, 15]]]),
    array([[[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]],

        [[ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4],
            [ 0. ,  0.1,  0.2,  0.3,  0.4]]])]

Установка параметра sparse в значение True может значительно снизить затраты памяти. В результате мы получим массивы сеток сжатые до одной оси, т.е. лишь одна ось в таком массиве имеет длинну большую 1. При этом, сами массивы могут быть легко транслированы относительно друг друга:

    >>> x = [1, 2, 3, 4, 5]
    >>> y = [0, 5, 10, 15, 20, 25, 30, 35, 40]
    >>> z = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.]
    >>> 
    >>> XYZ = np.meshgrid(x, y, z, sparse = True)
    >>> XYZ
    [array([[[1],
            [2],
            [3],
            [4],
            [5]]]),

    array([[[ 0]],

        [[ 5]],

        [[10]],

        [[15]],

        [[20]],

        [[25]],

        [[30]],

        [[35]],

        [[40]]]),

    array([[[ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ]]])]
    >>>
    >>> 
    >>> XYZ[0].shape, XYZ[1].shape, XYZ[2].shape
    ((1, 5, 1), (9, 1, 1), (1, 1, 11))
    >>> 

### mgrid[]
Возвращает массив плотных координатных сеток

__numpy.mgrid__

    numpy.mgrid[index object] = <numpy.lib.index_tricks.nd_grid object>

Функция mgrid() возвращает массив плотных координатных сеток N-мерного координатного пространства для указанных в виде диапазонов одномерных массивов координатных векторов.

Параметры:
+ index object - объект индексации<br>
Под объектом индексации понимается список из двух или трех элементов, например [0:5] или [0:5:10j]. Если элементов в списке всего два, то это интерпретируется как полуоткрытый интервал [start, ... , stop), в котором все элементы отличаются на 1, а значение stop в сам интервал не входит. В качестве третьего элемента указывается мнимая часть комплексного числа, которое указывает на количество равномерно разнесенных элементов внутри закрытого интервала [start, ... , stop], при этом значение stop попадает в интервал.

Возвращает:
+ результат - массив NumPy<br>
Массив плотных координатных сеток N-мерного координатного пространства, количество и размеры которых зависят от указанных диапазонов.

Смотрите так же: meshgrid, ogrid

Примеры

    >>> import numpy as np
    >>> 
    >>> np.mgrid[0:4, 4:8]
    array([[[0, 0, 0, 0],
            [1, 1, 1, 1],
            [2, 2, 2, 2],
            [3, 3, 3, 3]],

        [[4, 5, 6, 7],
            [4, 5, 6, 7],
            [4, 5, 6, 7],
            [4, 5, 6, 7]]])
    >>> 
    >>> np.mgrid[0:0.9:10j]
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
    >>>
    >>> np.mgrid[0:15:6j]
    array([  0.,   3.,   6.,   9.,  12.,  15.])
    >>> 
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])
    >>>
    >>>
    >>> x, y = np.mgrid[0:0.8:5j, 0:15:4j]
    >>> x
    array([[ 0. ,  0. ,  0. ,  0. ],
        [ 0.2,  0.2,  0.2,  0.2],
        [ 0.4,  0.4,  0.4,  0.4],
        [ 0.6,  0.6,  0.6,  0.6],
        [ 0.8,  0.8,  0.8,  0.8]])
    >>> y
    array([[  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.],
        [  0.,   5.,  10.,  15.]])

Замечание

Функции meshgrid, mgrid и ogrid очень похожи друг на друга. meshgrid является самой гибкой, mgrid выдает только плотные массивы координатных сеток, а ogrid только сжатые до одной оси. При этом функция mgrid может быть легко переопределена в функцию ogrid:

    >>> np.mgrid = np.lib.index_tricks.nd_grid(sparse=True)
    >>>
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]
    >>>
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]

### ogrid[]
Возвращает открытую сетку значений.

__numpy.ogrid__

    numpy.ogrid[index object] = <numpy.lib.index_tricks.nd_grid object>

Функция ogrid() возвращает массив сжатых координатных сеток N-мерного координатного пространства для указанных в виде диапазонов одномерных массивов координатных векторов.

Параметры:
+ index object - объект индексации<br>
Под объектом индексации понимается список из двух или трех элементов, например [0:5] или [0:5:10j]. Если элементов в списке всего два, то это интерпретируется как полуоткрытый интервал [start, ... , stop), в котором все элементы отличаются на 1, а значение stop в сам интервал не входит. В качестве третьего элемента указывается мнимая часть комплексного числа, которое указывает на количество равномерно разнесенных элементов внутри закрытого интервала [start, ... , stop], при этом значение stop попадает в интервал.

Возвращает:
+ результат - массив NumPy<br>
Массив сжатых до одной оси координатных сеток N-мерного координатного пространства, таких что только одна ось (размерность) содержит количество элементов большее 1.

Смотрите так же: meshgrid, mgrid

Примеры

    >>> import numpy as np
    >>> 
    >>> np.ogrid[0:4, 4:8]
    [array([[0],
        [1],
        [2],
        [3]]), array([[4, 5, 6, 7]])]
    >>> 
    >>> np.ogrid[0:0.9:10j]
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
    >>> 
    >>> np.ogrid[0:15:6j]
    array([  0.,   3.,   6.,   9.,  12.,  15.])
    >>> 
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    [array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]]), array([[  0.,   5.,  10.,  15.]])]
    >>> 
    >>> x, y = np.ogrid[0:0.8:5j, 0:15:4j]
    >>> 
    >>> x
    array([[ 0. ],
        [ 0.2],
        [ 0.4],
        [ 0.6],
        [ 0.8]])
    >>>
    >>> y
    array([[  0.,   5.,  10.,  15.]])
    >>> 
    >>> x.shape, y.shape
    ((5, 1), (1, 4))

Замечание

Функции meshgrid, mgrid и ogrid очень похожи друг на друга. meshgrid является самой гибкой, mgrid выдает только плотные массивы координатных сеток, а ogrid только сжатые до одной оси. Если диапазонов много и сами они очень велики, то результат функции mgrid может потребовать очень много памяти, чего нельзя сказать о функции ogrid, массивы которой сжаты и могут быть легко транслированы относительно друг друга. Однако, сама функция ogrid может быть легко переопределена в функцию mgrid:

    >>> np.ogrid = np.lib.index_tricks.nd_grid(sparse=False)
    >>> 
    >>> np.ogrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])
    >>> 
    >>> np.mgrid[0:0.8:5j, 0:15:4j]
    array([[[  0. ,   0. ,   0. ,   0. ],
            [  0.2,   0.2,   0.2,   0.2],
            [  0.4,   0.4,   0.4,   0.4],
            [  0.6,   0.6,   0.6,   0.6],
            [  0.8,   0.8,   0.8,   0.8]],

        [[  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ],
            [  0. ,   5. ,  10. ,  15. ]]])

## 1.6. Создание матриц

### mat()
Преобразует входную последовательность в матрицу.

### bmat()
Создает матрицу из строки, вложенной последовательности или массива.

### diag()
Извлекает диагональ из массива, а так же позволяет строить диагональные массивы.

### diagflat()
Создает диагональный массив из элементов указанного массива.

### tri()
Создает массив у которого все элементы ниже указанной диагонали равны 1, а все остальные равны 0.

### tril()
Заменяет на 0 все элементы массива, которые оказались выше указанной диагонали.

### triu()
Заменяет на 0 все элементы массива, которые оказались ниже указанной диагонали.

### vander()
Создает матрицу Вандермонда.