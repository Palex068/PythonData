# Краткое руководство

# 1. NumPy

NumPy - это фундаментальный пакет для научных вычислений на языке Python, который активно используется обширным сообществом исследователей, ученых и преподавателей во всем мире, а так же является важным компонентом для других прикладных библиотек.

Причин такого широкого распространения NumPy довльно много:
+ пакет является бесплатным, а его код открытым;
+ удобный и хорошо продуманный синтаксис;
+ дополнительная функциональность для работы с многомерными массивами;
+ быстрые вычисления на языках C и Fortran, выполняемые "под капотом";
+ легкая интеграция с другими библиотеками.

Отдельного внимания заслуживают функции, которые предоставляет NumPy:
+ функции создания массивов;
+ функции для выполнения операций над массивами;
+ функции ввода и вывода данных;
+ базовые математические функции;
+ линейная алгебра;
+ работа с полиномами;
+ статистика;
+ генерация случайных чисел и распределений;
+ дискретное преобразование Фурье;
+ базовые финансовые функции;
+ функции для работы с датой и временем;
+ логические функции;
+ функции для работы со строками;
+ функции для работы с множествами;
+ функции поиска, сортировки и подсчета элементов;
+ оконные функции.

Хорошее знание Numpy позволяет писать оптимизированный и лаконичный код, а его многомерные массивы являются базовой структурой для библиотеки [SciPy](https://scipy.org/), которая значительно расширяет его математическую функциональность и область решаемых задач.

# 2. Установка NumPy
## 2.1. NumPy в составе научных дистрибутивов Python
### 2.1.1. [Anaconda](https://www.anaconda.com/)

Пожалуй, самый лучший способ установки и использования стека пакетов SciPy, (в том числе и NumPy) является установка дистрибутива Anaconda. 

Устанавливая данный дистрибутив, вы устанавливаете несколько сотен (порядка 400, в зависимости от используемой вами платформы) самых разных пакетов. 

Может показаться избыточным, но на деле это оказывается очень удобным - практически все, что может вам понадобится, находится у вас под рукой. 

Так же вы получаете интерактивную оболочку IPython в привлекательной web-обертке Jupyter. В такой среде очень удобно работать. Например на картинке ниже показано, как выглядит создание матрицы из случайных чисел размером 10х10 и оформлен ее удобный для восприятия вывод с помощью библиотеки SymPy.

![Jupyter](/Articles/_NumPy/_NumPyProg.pro/pictures/001_001.png)

Чтобы установить дистрибутив Anaconda, сначала его нужно скачать с [официального сайта](https://www.anaconda.com/download). Прежде чем нажимать кнопку "download", уточните параметры своей платформы (допустим, у меня это Linux-x86 32 bit). Пока идет скачивание и [установка](https://docs.anaconda.com/anaconda/install/), вы можете изучить доступные в вашем дистрибутиве [пакеты](https://docs.anaconda.com/anaconda/packages/pkg-docs) и документацию к ним. Думаю, даже после беглого просмотра, вы убедитесь, что вы действительно имеете под рукой очень и очень много самых разнообразных инструментов.

Не смотря на то, что Anaconda сейчас является лидирующим по популярности дистрибутивом Python, не стоит забывать о других дистрибутивах. Все они предоставляют возможность работы со стеком SciPy и NumPy в частности. Помимо прочего, так же как и Anaconda они включают множество научных и вспомогательных библиотек. Однако, все они имеют значительные отличия от Anaconda#.

### 2.1.2. [ActivePython](https://www.activestate.com/activepython)
Коммерческий (бесплатный период 30 дней) дистрибутив Python, предназначенный для быстрого внедрения и сопровождения серьезных проектов на базе Python. Содержит предварительно скомпилированные и настроенные решения практически для всех ключевых отраслей, что позволяет значительно сократить время на установку и настройку. Может быть установлен на целый ряд операционных систем. Содержит удобные инструменты для работы в Windows.

ActivePython полностью защищает от всех рисков, связанных с использованием ПО под лицензией GNU/GPL. Все пакеты доступные в собственном репозитории проверяются на безопасность и являются защищенными. Данный дистрибутив всегда включает только последнюю версию OpenSSL. Содержит обширную документацию, но при этом сама организация-разработчик обеспечивает техническую поддержку и всегда дает ответы даже на самые сложные вопросы#.

### 2.1.3. [Enthought Canopy](https://www.enthought.com/product/canopy/)
Данный дистрибутив предоставляет, как интерактивную среду, так и собственную среду разработки, причем вы не ограничены какой-то одной версией Python, а можете сами выбирать с какой именно версией Python вы будете работать к примеру 2.7 или 3.5. При этом вы так же имеете доступ к более чем 450 пакетам.

Весьма интересной особенностью Enthought Canopy является работа с научными и аналитическими пакетами. В вашем распоряжении появляется графический менеджер пакетов, который позволяет гибко манипулировать всеми пакетами и их зависимостями. При этом гарантируется что вы имеете доступ к самым стабильным (проверенным) версиям пакетов. Это не означает, что в других дистрибутивах не следят за включаемыми в них пакетами, но Enthought подчеркнуто гарантирует это.

Enthought Canopy включает в себя редактор кода, интегрированное окно IPython в оболочке Jupyter, интерактивный графический отладчик и встроенные инструменты импорта данных. Нельзя не упомянуть о MayaVi - визуализаторе научных данных и BlockCanvasи - визуализаторе для создания имитационных экспериментов. При этом вы имеете мгновенный доступ к пакетной документации, что весьма и весьма удобно.

Enthought Canopy способен работать с Eхcel и LabVIEW, имеет собственный сервер для совместной работы в рамках частных сетей, и имеет много других способов для интеграции в существующую инфраструктуру. Конечно за дополнительные возможности наверняка придется заплатить, но бесплатная версия прекрасно подойдет для научных и инженерных расчетов#.

### 2.1.4. [Intel® Distribution for Python](https://software.intel.com/en-us/distribution-for-python)
Данный дистрибутив является бесплатным и предоставляет собой высокоскоростную реализацию Python и большого количества научных пакетов. Например, в зависимости от испльзуемого процессора, производительность NumPy, SciPy и numexpr благодаря библиотеке Intel® Math Kernel Library может превосходить производительность тех же библиотек на тех же процессорах от 1,3 до нескольких тысяч раз.

Данный дистрибутив не так прост в установке и настройке, как другие и содержит не так много научных пакетов в своем составе. Но он очень хорошо задокументирован и недостающие пакеты могут быть легко установленны с помощью менеджера пакетов Conda. Помимо прочего, вместе с данным дистрибутивом можно легко использовать другие специализированные библиотеки от Intel®, например Intel® [pyDAAL](https://software.intel.com/en-us/articles/intel-distribution-for-python-pydaal-module) - хорошая альтернатива scikit-learn#.

### 2.1.5. [Python(x,y)](https://python-xy.github.io/)
Этот дистрибутив больше всего подойдет приверженцам Windows. Абсолютно бесплатен, включает в себя множество научных пакетов и NumPy само-собой разумеется. При этом вы можете создавать научные проекты с Qt-интерфейсом, и работать в Spyder - научно-ориентированной среде разработки. В принципе, это и является ключевой особенностью Python(x,y). Вы действительно можете создавать как маленькие так и большие научные проекты.

Устанавливая Python(x,y), вы получаете очень много инструментов для создания серьезных научных приложений: от компиляторов С/С++/Fortran до средств документирования. Нельзя сказать, что данный дистрибутив является чем-то уникальным, но он определенно заслуживает внимания, особенно, пользователей Windows#.

### 2.1.6. [WinPython](http://winpython.sourceforge.net/)
Это бесплатный портативный дистрибутив Python - который является просто спасением для пользователей Windows. Слово "портативный" означает, что все необходимое находится в пределах одной папки и может копироваться куда угодно без предварительной установки. При этом на одной машине может запускаться несколько версий Python, причем для разных архитектур. Вы можете хранить весь свой проект на флэшке и работать с ним на любой Windows машине.

Наверное, стоит особо отметить, что данный дистрибутив, все же предназначен для продвинутых научных разработчиков и одновременно продвинутых пользователей Windows. Т. е. это означает, что вы не только создаете, но и сопровождаете научное программное обеспечение и точно знаете что делаете#.

### 2.1.7. [Pyzo](http://www.pyzo.org/)
Бесплатный кросплатформенный дистрибутив, о котором, весьма лестно отзываются пользователи, особенно OSX. На самом деле, на данный момент, Pyzo представляет собой не дистрибутив, а IDE, которая нацелена на интерактивность и простоту, подходящую не только ученым, но даже школьникам.

Pyzo позволяет выбрать используемый интерпретатор Python и обычно используется с miniconda или anaconda, для упрощения установки научных пакетов. Эту IDE легко установить и легко начать с ней работать. На официальном сайте, достаточно информации для новичков-разработчиков. Поэтому, в отличии от WinPython, Pyzo с увереностью можно порекомендовать тем кто только начинает создавать научное программное обеспечение#.

### 2.1.8. Какой дистрибутив выбрать?
Если вы являетесь новичком в науке или если в вашей работе исследования очень значительно преобладают над разработкой, то я порекомендовал бы дистрибутив Anaconda. Такая рекомендация связана стем, что в образовании и исследованиях IPython, Jupyter и установленных по умолчанию пакетов более чем достаточно. Конечно, рано или поздно, вы столкнетесь с тем, что вам потребуется писать не просто скрипты, но и код, который будет использоваться повторно и очень много раз. Поэтому, здесь обязательно пригодится IDE Spyder и всевозможные инструменты для построения графических инструментов.

Отдельного внимания заслуживает Intel® Distribution for Python, который окажется очень полезен для тех, кто уже перешел в рабочую фазу и ежедневно имеет дело с задачами анлиза данных, машинного обучения или любыми другими, если вы их решаете с помощью стека пакетов SciPy. Даже небольшой прирост в скорости вычислений - это большой плюс. Конечно прирост в 1,3 раза ничего не даст, но если вы готовы приобрести более мощные процессоры, то Intel® Distribution for Python позволит вам использовать весь их потенциал. Причем для этого не требуется знание С и Fortran. Хотя в тоже время знание С и Fortran с инструментами от Intel® может увеличить скорость вычислений на целые порядки.

Ну а все остальное я бы порекомендовал тем кто имеет склонность к разработке научного софта или имеет потребность в ее создании. Причем, новичкам на этом поприще, наверняка стоит начать с Pyzo, думаю, и обучение разработке с данной IDE окажется довольно успешным. Что касается Enthought Canopy, то данный дистрибутив, наверняка больше всего подойдет, как будующим так и состоявшимся инженерам. ActivePython окажется незаменим в коммерческих организациях. А вот Python(x,y) и WinPython больше всего подойдут, как неискушенным так и профессиональным пользователям Windows.

И на последок, данный короткий обзор содержит лишь крайне поверхностный обзор дистрибутивов Python. Я не знаю, какие именно цели вы преследуете и поэтому, прежде чем выбирать, ознакомьтесь с каждым дистрибутивом самостоятельно на его официальном сайте. Если вы преследуете только одну цель - научиться работать с пакетом NumPy (или другими научными пакетами), то повторюсь, лучше всего установить Anaconda. Если изучение NumPy - лишь шаг к более высокой цели, в достижении которой дистрибутив должен послужить основным инструментом, то к выбору дистрибутива нужно подходить более тщательно#.

### 2.1.9. Использование в коммерческих целях
В подавляющем большинстве случаев, пакеты Python относятся к ПО с открытым исходным кодом, но если вы собираетесь использовать какие-то пакеты для извлечения коммерческой выгоды, то обязательно ознакомьтесь с их лицензией. Пользователям ActivePython и платных версий дистрибутивов Anaconda и Enthought Canopy в случае возникновения проблем, связанных с лицензиями на пакеты, предоставляются разнообразные компенсации.

## 2.2. Установка с помощью pip
Если по некоторым причинам вам необходим только пакет NumPy и больше ничего, то его можно установить с помощью стандартного менеджера пакетов Python - pip. Практически все пакеты разрабатываемые крупными проектами выгружаются в каталог пакетов Python ([PyPI](https://pypi.org/)) и NumPy - не исключение. менеджер пакетов pip, как раз и нужен для того что бы устанавливать пакеты из этого каталога.

Если в вашей системе установлен Python и [pip](https://pip.pypa.io/en/stable/), то установить NumPy можно с помощью команды:

    python -m pip install --user numpy

С помощью этой же команды можно установить любой пакет из стека SciPy:

    python -m pip install --user matplotlib

Или сразу весь стек SciPy:

    python -m pip install --user numpy scipy matplotlib pandas sympy ipython jupyter nose

В данных примерах используется флаг __--user__ для того что бы пакеты не записывались в системные папки и были доступны только локальному пользователю. Если для вас это не принципиально, просто не используйте этот флаг.

## 2.3. Установка через менеджер пакетов Linux
### Ubuntu и Debian
Пользователи Linux могут установить NumPy и весь стек пакетов SciPy из репозиториев. Однако, может оказаться, что установленный пакет окажется более старой или вовсе не подходящей версией. К тому же установка окажется общесистемной.

    sudo apt-get install python-numpy

Или весь стек целиком

    sudo apt-get install python-numpy python-scipy python-pandas python-sympy python-matplotlib ipython ipython-notebook python-nos#e

### Fedora 22 и выше
    
    sudo dnf install numpy scipy python-matplotlib python-pandas sympy ipython python-nose atlas-devel

## 2.4. Установка через менеджер пакетов MAC
У MAC нет предустановленного менеджера пакетов и если в вашей системе он отсутствует, то рекомендуется установить [Macports](https://www.macports.org/). Для установки NumPy и всего стека пакетов SciPy выполните следующую команду:

    sudo port install py34-numpy py34-scipy py34-matplotlib py34-ipython +notebook py34-pandas py34-sympy py34-nose

В данном примере производится установка для Python версии 3.4. Если вы используете другую версию Python, допустим 3.5 то просто замените py34 на py35.

Если вы используете мнеджер Homebrew, то просто выполните:

    brew tap homebrew/science && brew install python numpy

## 2.5. Windows
Если по некоторым причинам в Windows вам не подходит установка с помощью pip, то ознакомьтесь с [проектом Christoph Gohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/), который предоставляет возможность использовать двоичные файлы (32 и 64 бит) созданных для официального дистрибутива Python на языке CPython. Однако, лучшим вариантом все-таки остается pip.

## 2.6. Сборка NumPy из исходных компонентов
Создавать Пакеты из исходных текстов кода Python относительно легко, но NumPy требует подключения компилятора Fortran и компиляции кода C. Поэтому, если возникла такая необходимость, то лучше обратиться к [официальной документации](https://docs.scipy.org/doc/numpy-1.14.0/user/building.html).

# 3. Массивы NumPy
## 3.1. Прежде чем читать
Нужно немного знать Python. Причем "немного" означает действительно немного и вовсе не означает, что перед чтением данного руководства вам нужно досконально изучить этот язык. Открытой вкладки с официальным руководством окажется вполне достаточно.

Все примеры выполнены в консоли IDE Spyder дистрибутива Anaconda на Python версии 3.5. и NumPy версии 1.14.0. Приводимые примеры так же будут работать в любом другом дистрибутиве Python 3.х версии и последней версией пакета NumPy. Но если некоторые примеры все же не работают, то ознакомьтесь с официальной документацией вашего дистрибутива, возможно причина связана с его особенностями.

Например, если в своем дистрибутиве вы обнаружили последнюю версию IDE Spyder, то в ней нет Python консоли, к которой привыкают многие новички, учившиеся экспериментировать с кодом в IDLE. При этом новичкам может так же показаться, что и все примеры, представленные здесь, тоже лучше выполнять в Python консоли. Но нет, Python консоль использовалась автором лишь по техническим причинам, которые связаны с редактурой, версткой и дизайном кода. Консоль IPython имеет гораздо больше преимуществ.

## 3.2. Основы
Главный объект NumPy - это однородный многомерный массив. Чаще всего это одномерная последовательность или двумерная таблица, заполненные элементами одного типа, как правило числами, которые проиндексированы кортежем положительных целых чисел. В NumPy, элементы этого кортежа называются осями, а число осей рангом.

Что бы перейти к примерам, сначала выполним импорт пакета:

    >>> import numpy as np

Импортирование numpy под псевдонимом np уже стало общепринятой, негласной, договоренностью, можно сказать, традицией.

Теперь мы можем приступить к примерам. Способов создания массивов NumPy довольно много, но мы начнем с самого тривиального - создание массива из заполненного вручную списка Python:

    >>> a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
    >>> 
    >>> a
    array([11, 22, 33, 44, 55, 66, 77, 88, 99])

Теперь у нас есть одномерный массив (словосочетание "ранг массива" вряд ли приживется в русском языке), т.е. у него всего одна ось вдоль которой происходит индексирование его элементов.

![Массив](/Articles/_NumPy/_NumPyProg.pro/pictures/001_002.jpg)

Получить доступ к числу 33 можно привычным способом:

    >>> a[2]
    33

В общем-то, можно подумать, что ничего интересного и нет в этих массивах, но на самом деле это только начало кроличьей норы. Оцените:

    >>> a[[7, 0, 3, 3, 3, 0, 7]]
    array([88, 11, 44, 44, 44, 11, 88])

Вместо одного индекса, указан целый список индексов. А вот еще любопытный пример, теперь вместо индекса укажем логическое выражение:

    >>> a[a > 50]
    array([55, 66, 77, 88, 99])

Цель этих двух примеров - не устраивать головоломку, а продемонстрировать расширенные возможности индексирования массивов NumPy. С тем как устроена индексация мы разберемся в другой главе. Что еще интересного можно продемонстрировать? Векторизованные вычисления:

    >>> 2*a + 10
    array([ 32,  54,  76,  98, 120, 142, 164, 186, 208])
    >>> 
    >>> np.sin(a)**2 + np.cos(a)**2
    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])

Векторизованные - означает, что все арифметические операции и математические функции выполняются сразу над всеми элементами массивов. А это в свою очередь означает, что нет никакой необходимости выполнять вычисления в цикле. В случае одномерного массива, можно подумать, что это не такой уж бонус, ведь есть генераторы. Но давайте перейдем к двумерным массивам:

    >>> a = np.arange(12)
    >>> a
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
    >>> 
    >>> a = a.reshape(3, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])

Сейчас мы создали массив с помощью функции np.arange(), которая во многом аналогична функции range() языка Python. Затем, мы изменили форму массива с помощью метода reshape(), т.е. на самом деле создать этот массив мы могли бы и одной командой:

    >>> a = np.arange(12).reshape(3, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])

Визуально, данный массив выглядит следующим образом:

![Матрица](/Articles/_NumPy/_NumPyProg.pro/pictures/001_003.jpg)

Глядя на картинку, становится понятно, что первая ось (и индекс соответственно) - это строки, вторая ось - это столбцы. Т.е. получить элемент 9 можно простой командой:

    >>> a[2][1]    #  равносильно команде a[2, 1]
    9

Снова можно подумать, что ничего нового - все как в Python. Да, так и есть, и, это круто! Еще круто, то что NumPy добавляет к удобному и привычному синтаксису Python, весьма удобные трюки, например - транслирование массивов:

    >>> b = [2, 3, 4, 5]
    >>> 
    >>> a*b
    array([[ 0,  3,  8, 15],
        [ 8, 15, 24, 35],
        [16, 27, 40, 55]])

В данном примере, без всяких циклов (и генераторов), мы умножили каждый столбец из массива a на соответствующий элемент из массива b. Т.е. мы как бы транслировали (в какой-то степени можно сказать - растянули) массив b по массиву a.

То же самое мы можем проделать с каждой строкой массива a:

    >>> c = [[10], [20], [30]]
    >>> 
    >>> a + c
    array([[10, 11, 12, 13],
        [24, 25, 26, 27],
        [38, 39, 40, 41]])

В данном случае мы просто прибавили к массиву a массив-столбец c. И получили, то что хотели. Сейчас мы не будем подробно рассматривать механизм транслирования - это тема другой главы. Вместо этого я хочу отметить, что при работе с двумерными или трехмерными массивами, особенно с массивами большей размерности, становится очень важным удобство работы с элементами массива, которые расположены вдоль отдельных измерений - его осей.

Например, у нас есть двумерный массив и мы хотим узнать его минимальные элементы по строкам и столбцам. Для начала создадим массив из случайных чисел и пусть, для нашего удобства, эти числа будут целыми:

    >>> a = np.random.randint(0, 15, size = (4, 6))
    >>> a
    array([[ 9, 12,  5,  3,  1,  7],
        [ 2, 12, 10, 11, 14,  9],
        [ 4,  4,  9, 11,  5,  2],
        [12,  8,  6,  8,  9,  3]])

Минимальный элемент в данном массиве это:

    >>> a.min()
    1

А вот минимальные элементы по столбцам и строкам:

    >>> a.min(axis = 0)    #  минимальные элементы по столбцам
    array([2, 4, 5, 3, 1, 2])
    >>> 
    >>> a.min(axis = 1)    #  минимальные элементы по строкам
    array([1, 2, 2, 3])

Такое поведение заложено практически во все функции и методы NumPy:

    >>> a.mean(axis = 0)    #  среднее по столбцам
    array([6.75, 9.  , 7.5 , 8.25, 7.25, 5.25])
    >>> 
    >>> np.std(a, axis = 1)    #  стандартное отклонение по строкам
    array([3.67045259, 3.77123617, 3.13138237, 2.74873708])

Что ж, мы рассмотрели одномерные и двумерные массивы, а так же некоторые трюки NumPy. Но данный пакет позиционируется прежде всего как научный инструмент. Что насчет вычислений, их скорости и занимаемой памяти?

Для примера, создадим трехмерный массив:

    >>> a = np.arange(48).reshape(4, 3, 4)
    >>> a
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]],

        [[24, 25, 26, 27],
            [28, 29, 30, 31],
            [32, 33, 34, 35]],

        [[36, 37, 38, 39],
            [40, 41, 42, 43],
            [44, 45, 46, 47]]])

Почему именно трехмерный? На самом деле реальный мир вовсе не ограничивается таблицами, векторами и матрицами. 

Еще существуют тензоры, кватернионы, октавы. А некоторые данные, гораздо удобнее представлять именно в трехмерном и четырехмерном представлении, например, биржевые торги по всем инструментам, лучше всего представлять в трехмерном виде, а торги нескольких бирж в четырехмерном. 

Конечно, такими сложными вычислениями занимается очень небольшое количество людей, но надо отметить, что именно эти люди двигают науку и индустрию вперед. Да и слово "сложное" можно считать синонимом "интересное. Поэтому... что-то мы отвлеклись... вот наш трехмерный массив:

![трехмерный массив](/Articles/_NumPy/_NumPyProg.pro/pictures/001_004.jpg)

Визуализация (и хорошее воображение) позволяет сразу догадаться, как устроена индексация трехмерных массивов. Например, если нам нужно вытащить из данного массива число 31, то достаточно выполнить:

    >>> a[2][1][3]    #  или a[2, 1, 3]
    31

# ndim
Но, что если мы хотим узнать побольше об этом массиве. В самом деле, у массивов есть целый ряд важных атрибутов. Например, количество осей массива (его размерность), которую при работе с очень большими массивами, не всегда легко увидеть:

    >>> a.ndim
    3

# shape
Массив a действительно трехмерный. Но иногда становится интересно, а на сколько же большой массив перед нами. Например, какой он формы, т.е. сколько элементов расположено вдоль каждой оси? Ответить позволяет метод ndarray.shape:

    >>> a.shape
    (4, 3, 4)

# size
Метод ndarray.size просто возвращает общее количество элементов массива:

    >>> a.size
    48

# itemsize
Еще может встать такой вопрос - сколько памяти занимает наш массив? Иногда даже возникает такой вопрос - влезет ли результирующий массив после всех вычислений в оперативную память? Что бы на него ответить надо знать, сколько "весит" один элемент массива:

    >>> a.itemsize    #  эквивалентно ndarray.dtype.itemsize
    4

ndarray.itemsize возвращает размер элемента в байтах. Теперь мы можем узнать сколько "весит" наш массив:

    >>> a.size*a.itemsize
    192

Итого - 192 байта. 

На самом деле, размер занимаемой массивом памяти, зависит не только от количества элементов в нем, но и от испльзуемого типа данных:

    >>> a.dtype
    dtype('int32')

# dtype
dtype('int32') - означает, что используется целочисленный тип данных, в котором для хранения одного числа выделяется 32 бита памяти. Но если мы выполним какие-нибудь вычисления с массивом, то тип данных может измениться:

    >>> b = a/3.14
    >>> 
    >>> b
    array([[[ 0.        ,  0.31847134,  0.63694268,  0.95541401],
            [ 1.27388535,  1.59235669,  1.91082803,  2.22929936],
            [ 2.5477707 ,  2.86624204,  3.18471338,  3.50318471]],

        [[ 3.82165605,  4.14012739,  4.45859873,  4.77707006],
            [ 5.0955414 ,  5.41401274,  5.73248408,  6.05095541],
            [ 6.36942675,  6.68789809,  7.00636943,  7.32484076]],

        [[ 7.6433121 ,  7.96178344,  8.28025478,  8.59872611],
            [ 8.91719745,  9.23566879,  9.55414013,  9.87261146],
            [10.1910828 , 10.50955414, 10.82802548, 11.14649682]],

        [[11.46496815, 11.78343949, 12.10191083, 12.42038217],
            [12.7388535 , 13.05732484, 13.37579618, 13.69426752],
            [14.01273885, 14.33121019, 14.64968153, 14.96815287]]])
    >>> 
    >>> 
    >>> b.dtype
    dtype('float64')

Теперь у нас есть еще один массив - массив b и его тип данных 'float64' - вещественные числа (числа с плавающей точкой) длинной 64 бита. А его размер:

    >>> b.size*b.itemsize
    384

Тогда массив a - 192 байта, массив b - 384 байта. А в общем, получается, 576 байт - что очень мало для современных объемов оперативной памяти, но и реальные объемы данных, которые сейчас приходится обрабатывать совсем немаленькие.

Мы с вами собирались ответить на вопросы производительности вычислений в NumPy, но это тоже тема отдельной главы. 

Могу лишь сказать, что на самом деле скорость вычислений, очень сильно зависит от того кода, который вы пишите. Например, частое копирование и присваивание массивов, приводит к бесполезному потреблению памяти, а работа универсальных функций NumPy без дополнительных настроек, особенно в циклах, так же может выполняться несколько медленнее. В общем задача по использованию всего вычислительного потенциала программного обеспечения и железа, не такая уж и простая, но определенно решаемая задача.

# 3.3. Напоследок
Если вы новичок, то очень скоро поймете, что в использовании NumPy так же прост как и Python. Но, рано или поздно, дело дойдет до сложных задач и вот тогда начнется самое интересное: документации не хватает, ничего не гуглится, а бесчисленные "почти" подходящие советы приводят к необъяснимым сверхъестественным последствиям. Что делать в такой ситуации?
+ гуглить упорнее и спускаться к самому дну поисковой выдачи;
+ гуглить на английском языке, потому что, на английском информации на порядки больше чем на русском;
+ если не помог пункт 2, то это означает, что вы просто маньяк какой-то, и что бы решить свою маниакальную задачу, вам придется гуглить на китайском языке, потому что на китайском информации на порядки больше чем на английском.

Это шутка и серьезная рекомендация одновременно. 

Но, если говорить абсолютно серьезно, то просто придерживайтесь здравого смысла. Где этот здравый смысл начинается, а где заканчивается в конкретной задаче сказать очень трудно. import this вам в помощь:

    >>> import this
    The Zen of Python, by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

Если вы раньше пользовались R или matlab, то вас тоже ожидает много приятных сюрпризов, по крайней мере один - придется меньше стучать по клавиатуре.

# 4. Создание массивов
Данная глава является лишь кратким обзором, поскольку способов создания массивов очень много, их описание и примеры использования вы найдете в разделе ["Создание массивов"](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#1-создание-массивов) справочного руководства.

# array()
И так, массив может быть создан из обычного списка или кортежа Python с использованием функции array(). Причем тип полученного массива зависит от типа элементов последовательности:

    >>> import numpy as np
    >>>
    >>> a = np.array([1, 2, 3])
    >>> a
    array([1, 2, 3])
    >>> a.dtype
    dtype('int32')
    >>>
    >>> a = np.array([1.1, 2.2, 3.3])
    >>> a
    array([ 1.1,  2.2,  3.3])
    >>> a.dtype
    dtype('float64')
    >>>
    >>> a = np.array([1 + 2j, 2 + 3j])
    >>> a.dtype
    dtype('complex128')

Необходимо помнить о том, что аргументом функции array() должна быть именно последовательность, а не несколько аргументов.

    >>> a = np.array(1, 2, 3)      #  Неправильно!!!
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: only 2 non-keyword arguments accepted
    >>>
    >>> a = np.array([1, 2, 3])    #  Правильно
    >>> a
    array([1, 2, 3])
    >>>
    >>> a = np.array((1, 2, 3))    #  И так тоже правильно
    >>> a
    array([1, 2, 3])

Функция array() преобразует последовательности последовательностей в двумерные массивы, а последовательности последовательностей, которые тоже состоят из последовательностей в трехмерные массивы. То есть уровень вложенности исходной последовательности определяет размерность получаемого массива:

    >>> a = np.array([[2, 4], [6, 8], [10, 12]])
    >>> a
    array([[ 2,  4],
        [ 6,  8],
        [10, 12]])
    >>>
    >>> b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
    >>> b
    array([[[ 1,  2],
            [ 3,  4]],

        [[ 5,  6],
            [ 7,  8]],

        [[ 9, 10],
            [11, 12]]])
    >>>
    >>> a.ndim    #  Количество осей массива
    2
    >>> b.ndim
    3

Функция array() так же позволяет определить тип данных массива.

    >>> a = np.array([[2, 4], [6, 8], [10, 12]], dtype = complex )
    >>> a
    array([[  2.+0.j,   4.+0.j],
        [  6.+0.j,   8.+0.j],
        [ 10.+0.j,  12.+0.j]])
    >>>
    >>> a = np.array([[2, 4], [6, 8], [10, 12]], dtype = float )
    >>> a
    array([[  2.,   4.],
        [  6.,   8.],
        [ 10.,  12.]])

Очень часто возникает задача создания массива определенного размера, причем чем заполнен массив абсолютно неважно. В этом случае можно воспользоваться циклами или генераторами списков (кортежей), но NumPy для таких случаев предлагает более быстрые и менее затратные функции-заполнители.

# [zeros()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#zeros), [ones()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#ones), [empty()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#empty)
Функция zeros заполняет массив нулями, функция ones - единицами, а функция empty - случайными числами, которые зависят от состояния памяти. По умолчанию, тип создаваемого массива - float64.

    >>> np.zeros((3,3))
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])
    >>>
    >>> np.ones((3,3))
    array([[ 1.,  1.,  1.],
        [ 1.,  1.,  1.],
        [ 1.,  1.,  1.]])
    >>>
    >>> np.ones((3,3), dtype = complex)  #  Можно изменить тип массива
    array([[ 1.+0.j,  1.+0.j,  1.+0.j],
        [ 1.+0.j,  1.+0.j,  1.+0.j],
        [ 1.+0.j,  1.+0.j,  1.+0.j]])
    >>>
    >>> np.empty([3, 3])
    array([[ -2.56357799e-042,   1.00079160e-313,  -5.41541116e-070],
        [  1.51668796e-314,   0.00000000e+000,   1.48219694e-320],
        [  2.61270984e-262,   0.00000000e+000,   8.36469502e-316]])

# arange()
Для создания последовательностей чисел NumPy предоставляет функцию arange, которая возвращает одномерные массивы:

    >>> np.arange(10)    #  От 0 до указанного числа
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>>
    >>> np.arange(10, 20)    #  Диапазон
    array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    >>>
    >>> np.arange(20, 100, 10)    #  Диапазон с заданным шагом
    array([20, 30, 40, 50, 60, 70, 80, 90])
    >>>
    >>> np.arange(0, 1, 0.1)    #  Аргументы могут иметь тип float
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])

Если функция arange используется с аргументами типа float, то предсказать количество элементов в возвращаемом массиве не так-то просто. Гораздо чаще возникает необходимость указания не шага изменения чисел в диапазоне, а количества чисел в заданном диапазоне. 

# linspace()

Функция linspace, так же как и arange принимает три аргумента, но третий аргумент, как раз и указывает количество чисел в диапазоне.

    >>> np.linspace(0, 1, 5)
    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
    >>>
    >>> np.linspace(0, 1, 7)
    array([ 0.        ,  0.16666667,  0.33333333,  0.5       ,  0.66666667,
            0.83333333,  1.        ])
    >>>
    >>> np.linspace(10, 100, 5)
    array([  10. ,   32.5,   55. ,   77.5,  100. ])

Функция linspace удобна еще и тем, что может быть использована для вычисления значений функций на заданном множестве точек:

    >>> x = np.linspace( 0, 2*np.pi, 10 )
    >>> x
    array([ 0.        ,  0.6981317 ,  1.3962634 ,  2.0943951 ,  2.7925268 ,
            3.4906585 ,  4.1887902 ,  4.88692191,  5.58505361,  6.28318531])
    >>>
    >>> y1 = np.sin(x)
    >>> y1
    array([  0.00000000e+00,   6.42787610e-01,   9.84807753e-01,
            8.66025404e-01,   3.42020143e-01,  -3.42020143e-01,
            -8.66025404e-01,  -9.84807753e-01,  -6.42787610e-01,
            -2.44929360e-16])
    >>>
    >>> y2 = np.cos(x)
    >>> y2
    array([ 1.        ,  0.76604444,  0.17364818, -0.5       , -0.93969262,
        -0.93969262, -0.5       ,  0.17364818,  0.76604444,  1.        ])

