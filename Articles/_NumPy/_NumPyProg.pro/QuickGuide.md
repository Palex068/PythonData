# Краткое руководство

# Содержание

1. [NumPy](#1-numpy)<br>
2. [Установка](#2-установка-numpy)<br>
2.1. [NumPy в составе научных дистрибутивов Python](#21-numpy-в-составе-научных-дистрибутивов-python)<br>
2.2. [Установка с помощью pip](#22-установка-с-помощью-pip)<br>
2.3. [Установка через менеджер пакетов Linux](#23-установка-через-менеджер-пакетов-linux)<br>
2.4. [Установка через менеджер пакетов MAC](#24-установка-через-менеджер-пакетов-mac)<br>
2.5. [Windows](#25-windows)<br>
2.6. [Сборка NumPy из исходных компонентов](#26-сборка-numpy-из-исходных-компонентов)<br>
3. [Массивы NumPy](#3-массивы-numpy)<br>
3.1. [Прежде чем читать](#31-прежде-чем-читать)<br>
3.2. [Основы](#32-основы)<br>
3.3. [Напоследок](#33-напоследок)<br>
4. [Создание массивов](#4-создание-массивов)<br>
5. [Вывод массивов на экран](#5-вывод-массивов-на-экран)<br>
6. Файловый ввод и вывод массивов<br>
Двоичные файлы NumPy (.npy, .npz)<br>
Текстовые файлы (.txt)<br>
Бинарные файлы<br>
7. Математика в NumPy<br>
Базовые математические операции<br>
Линейная алгебра<br>
Статистика<br>
Генерация случайных значений<br>
Дискретное преобразование Фурье<br>
Прочие математические разделы<br>
8. Индексация, срезы, итерирование<br>
Дополнительные возможности индексирования<br>
9. Манипулирование формой массивов<br>
Объединение массивов<br>
Разделение массивов<br>
10. Копии и представления массивов<br>
Присваиванием массивы не копируются<br>
Копирование массивов<br>
Представления массивов<br>
11. Транслирование массивов<br>
Правила транслирования<br>
Функция ix_()<br>
12. Типы данных<br>
Символьные коды типов данных<br>
13. Структурированные массивы<br>
Введение<br>
Структурированный тип данных<br>
Присвоение значений структурированному массиву<br>
Индексация структурированных массивов<br>

[Содержание](#содержание)

# 1. NumPy

NumPy - это фундаментальный пакет для научных вычислений на языке Python, который активно используется обширным сообществом исследователей, ученых и преподавателей во всем мире, а так же является важным компонентом для других прикладных библиотек.

Причин такого широкого распространения NumPy довльно много:
+ пакет является бесплатным, а его код открытым;
+ удобный и хорошо продуманный синтаксис;
+ дополнительная функциональность для работы с многомерными массивами;
+ быстрые вычисления на языках C и Fortran, выполняемые "под капотом";
+ легкая интеграция с другими библиотеками.

Отдельного внимания заслуживают функции, которые предоставляет NumPy:
+ функции создания массивов;
+ функции для выполнения операций над массивами;
+ функции ввода и вывода данных;
+ базовые математические функции;
+ линейная алгебра;
+ работа с полиномами;
+ статистика;
+ генерация случайных чисел и распределений;
+ дискретное преобразование Фурье;
+ базовые финансовые функции;
+ функции для работы с датой и временем;
+ логические функции;
+ функции для работы со строками;
+ функции для работы с множествами;
+ функции поиска, сортировки и подсчета элементов;
+ оконные функции.

Хорошее знание Numpy позволяет писать оптимизированный и лаконичный код, а его многомерные массивы являются базовой структурой для библиотеки [SciPy](https://scipy.org/), которая значительно расширяет его математическую функциональность и область решаемых задач.

[Содержание](#содержание)

# 2. Установка NumPy
## 2.1. NumPy в составе научных дистрибутивов Python
### 2.1.1. [Anaconda](https://www.anaconda.com/)

Пожалуй, самый лучший способ установки и использования стека пакетов SciPy, (в том числе и NumPy) является установка дистрибутива Anaconda. 

Устанавливая данный дистрибутив, вы устанавливаете несколько сотен (порядка 400, в зависимости от используемой вами платформы) самых разных пакетов. 

Может показаться избыточным, но на деле это оказывается очень удобным - практически все, что может вам понадобится, находится у вас под рукой. 

Так же вы получаете интерактивную оболочку IPython в привлекательной web-обертке Jupyter. В такой среде очень удобно работать. Например на картинке ниже показано, как выглядит создание матрицы из случайных чисел размером 10х10 и оформлен ее удобный для восприятия вывод с помощью библиотеки SymPy.

![Jupyter](/Articles/_NumPy/_NumPyProg.pro/pictures/001_001.png)

Чтобы установить дистрибутив Anaconda, сначала его нужно скачать с [официального сайта](https://www.anaconda.com/download). Прежде чем нажимать кнопку "download", уточните параметры своей платформы (допустим, у меня это Linux-x86 32 bit). Пока идет скачивание и [установка](https://docs.anaconda.com/anaconda/install/), вы можете изучить доступные в вашем дистрибутиве [пакеты](https://docs.anaconda.com/anaconda/packages/pkg-docs) и документацию к ним. Думаю, даже после беглого просмотра, вы убедитесь, что вы действительно имеете под рукой очень и очень много самых разнообразных инструментов.

Не смотря на то, что Anaconda сейчас является лидирующим по популярности дистрибутивом Python, не стоит забывать о других дистрибутивах. Все они предоставляют возможность работы со стеком SciPy и NumPy в частности. Помимо прочего, так же как и Anaconda они включают множество научных и вспомогательных библиотек. Однако, все они имеют значительные отличия от Anaconda#.

### 2.1.2. [ActivePython](https://www.activestate.com/activepython)
Коммерческий (бесплатный период 30 дней) дистрибутив Python, предназначенный для быстрого внедрения и сопровождения серьезных проектов на базе Python. Содержит предварительно скомпилированные и настроенные решения практически для всех ключевых отраслей, что позволяет значительно сократить время на установку и настройку. Может быть установлен на целый ряд операционных систем. Содержит удобные инструменты для работы в Windows.

ActivePython полностью защищает от всех рисков, связанных с использованием ПО под лицензией GNU/GPL. Все пакеты доступные в собственном репозитории проверяются на безопасность и являются защищенными. Данный дистрибутив всегда включает только последнюю версию OpenSSL. Содержит обширную документацию, но при этом сама организация-разработчик обеспечивает техническую поддержку и всегда дает ответы даже на самые сложные вопросы#.

### 2.1.3. [Enthought Canopy](https://www.enthought.com/product/canopy/)
Данный дистрибутив предоставляет, как интерактивную среду, так и собственную среду разработки, причем вы не ограничены какой-то одной версией Python, а можете сами выбирать с какой именно версией Python вы будете работать к примеру 2.7 или 3.5. При этом вы так же имеете доступ к более чем 450 пакетам.

Весьма интересной особенностью Enthought Canopy является работа с научными и аналитическими пакетами. В вашем распоряжении появляется графический менеджер пакетов, который позволяет гибко манипулировать всеми пакетами и их зависимостями. При этом гарантируется что вы имеете доступ к самым стабильным (проверенным) версиям пакетов. Это не означает, что в других дистрибутивах не следят за включаемыми в них пакетами, но Enthought подчеркнуто гарантирует это.

Enthought Canopy включает в себя редактор кода, интегрированное окно IPython в оболочке Jupyter, интерактивный графический отладчик и встроенные инструменты импорта данных. Нельзя не упомянуть о MayaVi - визуализаторе научных данных и BlockCanvasи - визуализаторе для создания имитационных экспериментов. При этом вы имеете мгновенный доступ к пакетной документации, что весьма и весьма удобно.

Enthought Canopy способен работать с Eхcel и LabVIEW, имеет собственный сервер для совместной работы в рамках частных сетей, и имеет много других способов для интеграции в существующую инфраструктуру. Конечно за дополнительные возможности наверняка придется заплатить, но бесплатная версия прекрасно подойдет для научных и инженерных расчетов#.

### 2.1.4. [Intel® Distribution for Python](https://software.intel.com/en-us/distribution-for-python)
Данный дистрибутив является бесплатным и предоставляет собой высокоскоростную реализацию Python и большого количества научных пакетов. Например, в зависимости от испльзуемого процессора, производительность NumPy, SciPy и numexpr благодаря библиотеке Intel® Math Kernel Library может превосходить производительность тех же библиотек на тех же процессорах от 1,3 до нескольких тысяч раз.

Данный дистрибутив не так прост в установке и настройке, как другие и содержит не так много научных пакетов в своем составе. Но он очень хорошо задокументирован и недостающие пакеты могут быть легко установленны с помощью менеджера пакетов Conda. Помимо прочего, вместе с данным дистрибутивом можно легко использовать другие специализированные библиотеки от Intel®, например Intel® [pyDAAL](https://software.intel.com/en-us/articles/intel-distribution-for-python-pydaal-module) - хорошая альтернатива scikit-learn#.

### 2.1.5. [Python(x,y)](https://python-xy.github.io/)
Этот дистрибутив больше всего подойдет приверженцам Windows. Абсолютно бесплатен, включает в себя множество научных пакетов и NumPy само-собой разумеется. При этом вы можете создавать научные проекты с Qt-интерфейсом, и работать в Spyder - научно-ориентированной среде разработки. В принципе, это и является ключевой особенностью Python(x,y). Вы действительно можете создавать как маленькие так и большие научные проекты.

Устанавливая Python(x,y), вы получаете очень много инструментов для создания серьезных научных приложений: от компиляторов С/С++/Fortran до средств документирования. Нельзя сказать, что данный дистрибутив является чем-то уникальным, но он определенно заслуживает внимания, особенно, пользователей Windows#.

### 2.1.6. [WinPython](http://winpython.sourceforge.net/)
Это бесплатный портативный дистрибутив Python - который является просто спасением для пользователей Windows. Слово "портативный" означает, что все необходимое находится в пределах одной папки и может копироваться куда угодно без предварительной установки. При этом на одной машине может запускаться несколько версий Python, причем для разных архитектур. Вы можете хранить весь свой проект на флэшке и работать с ним на любой Windows машине.

Наверное, стоит особо отметить, что данный дистрибутив, все же предназначен для продвинутых научных разработчиков и одновременно продвинутых пользователей Windows. Т. е. это означает, что вы не только создаете, но и сопровождаете научное программное обеспечение и точно знаете что делаете#.

### 2.1.7. [Pyzo](http://www.pyzo.org/)
Бесплатный кросплатформенный дистрибутив, о котором, весьма лестно отзываются пользователи, особенно OSX. На самом деле, на данный момент, Pyzo представляет собой не дистрибутив, а IDE, которая нацелена на интерактивность и простоту, подходящую не только ученым, но даже школьникам.

Pyzo позволяет выбрать используемый интерпретатор Python и обычно используется с miniconda или anaconda, для упрощения установки научных пакетов. Эту IDE легко установить и легко начать с ней работать. На официальном сайте, достаточно информации для новичков-разработчиков. Поэтому, в отличии от WinPython, Pyzo с увереностью можно порекомендовать тем кто только начинает создавать научное программное обеспечение#.

### 2.1.8. Какой дистрибутив выбрать?
Если вы являетесь новичком в науке или если в вашей работе исследования очень значительно преобладают над разработкой, то я порекомендовал бы дистрибутив Anaconda. Такая рекомендация связана стем, что в образовании и исследованиях IPython, Jupyter и установленных по умолчанию пакетов более чем достаточно. Конечно, рано или поздно, вы столкнетесь с тем, что вам потребуется писать не просто скрипты, но и код, который будет использоваться повторно и очень много раз. Поэтому, здесь обязательно пригодится IDE Spyder и всевозможные инструменты для построения графических инструментов.

Отдельного внимания заслуживает Intel® Distribution for Python, который окажется очень полезен для тех, кто уже перешел в рабочую фазу и ежедневно имеет дело с задачами анлиза данных, машинного обучения или любыми другими, если вы их решаете с помощью стека пакетов SciPy. Даже небольшой прирост в скорости вычислений - это большой плюс. Конечно прирост в 1,3 раза ничего не даст, но если вы готовы приобрести более мощные процессоры, то Intel® Distribution for Python позволит вам использовать весь их потенциал. Причем для этого не требуется знание С и Fortran. Хотя в тоже время знание С и Fortran с инструментами от Intel® может увеличить скорость вычислений на целые порядки.

Ну а все остальное я бы порекомендовал тем кто имеет склонность к разработке научного софта или имеет потребность в ее создании. Причем, новичкам на этом поприще, наверняка стоит начать с Pyzo, думаю, и обучение разработке с данной IDE окажется довольно успешным. Что касается Enthought Canopy, то данный дистрибутив, наверняка больше всего подойдет, как будующим так и состоявшимся инженерам. ActivePython окажется незаменим в коммерческих организациях. А вот Python(x,y) и WinPython больше всего подойдут, как неискушенным так и профессиональным пользователям Windows.

И на последок, данный короткий обзор содержит лишь крайне поверхностный обзор дистрибутивов Python. Я не знаю, какие именно цели вы преследуете и поэтому, прежде чем выбирать, ознакомьтесь с каждым дистрибутивом самостоятельно на его официальном сайте. Если вы преследуете только одну цель - научиться работать с пакетом NumPy (или другими научными пакетами), то повторюсь, лучше всего установить Anaconda. Если изучение NumPy - лишь шаг к более высокой цели, в достижении которой дистрибутив должен послужить основным инструментом, то к выбору дистрибутива нужно подходить более тщательно#.

### 2.1.9. Использование в коммерческих целях
В подавляющем большинстве случаев, пакеты Python относятся к ПО с открытым исходным кодом, но если вы собираетесь использовать какие-то пакеты для извлечения коммерческой выгоды, то обязательно ознакомьтесь с их лицензией. Пользователям ActivePython и платных версий дистрибутивов Anaconda и Enthought Canopy в случае возникновения проблем, связанных с лицензиями на пакеты, предоставляются разнообразные компенсации.

## 2.2. Установка с помощью pip
Если по некоторым причинам вам необходим только пакет NumPy и больше ничего, то его можно установить с помощью стандартного менеджера пакетов Python - pip. Практически все пакеты разрабатываемые крупными проектами выгружаются в каталог пакетов Python ([PyPI](https://pypi.org/)) и NumPy - не исключение. менеджер пакетов pip, как раз и нужен для того что бы устанавливать пакеты из этого каталога.

Если в вашей системе установлен Python и [pip](https://pip.pypa.io/en/stable/), то установить NumPy можно с помощью команды:

    python -m pip install --user numpy

С помощью этой же команды можно установить любой пакет из стека SciPy:

    python -m pip install --user matplotlib

Или сразу весь стек SciPy:

    python -m pip install --user numpy scipy matplotlib pandas sympy ipython jupyter nose

В данных примерах используется флаг __--user__ для того что бы пакеты не записывались в системные папки и были доступны только локальному пользователю. Если для вас это не принципиально, просто не используйте этот флаг.

## 2.3. Установка через менеджер пакетов Linux
### Ubuntu и Debian
Пользователи Linux могут установить NumPy и весь стек пакетов SciPy из репозиториев. Однако, может оказаться, что установленный пакет окажется более старой или вовсе не подходящей версией. К тому же установка окажется общесистемной.

    sudo apt-get install python-numpy

Или весь стек целиком

    sudo apt-get install python-numpy python-scipy python-pandas python-sympy python-matplotlib ipython ipython-notebook python-nos#e

### Fedora 22 и выше
    
    sudo dnf install numpy scipy python-matplotlib python-pandas sympy ipython python-nose atlas-devel

## 2.4. Установка через менеджер пакетов MAC
У MAC нет предустановленного менеджера пакетов и если в вашей системе он отсутствует, то рекомендуется установить [Macports](https://www.macports.org/). Для установки NumPy и всего стека пакетов SciPy выполните следующую команду:

    sudo port install py34-numpy py34-scipy py34-matplotlib py34-ipython +notebook py34-pandas py34-sympy py34-nose

В данном примере производится установка для Python версии 3.4. Если вы используете другую версию Python, допустим 3.5 то просто замените py34 на py35.

Если вы используете мнеджер Homebrew, то просто выполните:

    brew tap homebrew/science && brew install python numpy

## 2.5. Windows
Если по некоторым причинам в Windows вам не подходит установка с помощью pip, то ознакомьтесь с [проектом Christoph Gohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/), который предоставляет возможность использовать двоичные файлы (32 и 64 бит) созданных для официального дистрибутива Python на языке CPython. Однако, лучшим вариантом все-таки остается pip.

## 2.6. Сборка NumPy из исходных компонентов
Создавать Пакеты из исходных текстов кода Python относительно легко, но NumPy требует подключения компилятора Fortran и компиляции кода C. Поэтому, если возникла такая необходимость, то лучше обратиться к [официальной документации](https://docs.scipy.org/doc/numpy-1.14.0/user/building.html).

[Содержание](#содержание)

# 3. Массивы NumPy
## 3.1. Прежде чем читать
Нужно немного знать Python. Причем "немного" означает действительно немного и вовсе не означает, что перед чтением данного руководства вам нужно досконально изучить этот язык. Открытой вкладки с официальным руководством окажется вполне достаточно.

Все примеры выполнены в консоли IDE Spyder дистрибутива Anaconda на Python версии 3.5. и NumPy версии 1.14.0. Приводимые примеры так же будут работать в любом другом дистрибутиве Python 3.х версии и последней версией пакета NumPy. Но если некоторые примеры все же не работают, то ознакомьтесь с официальной документацией вашего дистрибутива, возможно причина связана с его особенностями.

Например, если в своем дистрибутиве вы обнаружили последнюю версию IDE Spyder, то в ней нет Python консоли, к которой привыкают многие новички, учившиеся экспериментировать с кодом в IDLE. При этом новичкам может так же показаться, что и все примеры, представленные здесь, тоже лучше выполнять в Python консоли. Но нет, Python консоль использовалась автором лишь по техническим причинам, которые связаны с редактурой, версткой и дизайном кода. Консоль IPython имеет гораздо больше преимуществ.

[Содержание](#содержание)

## 3.2. Основы
Главный объект NumPy - это однородный многомерный массив. Чаще всего это одномерная последовательность или двумерная таблица, заполненные элементами одного типа, как правило числами, которые проиндексированы кортежем положительных целых чисел. В NumPy, элементы этого кортежа называются осями, а число осей рангом.

Что бы перейти к примерам, сначала выполним импорт пакета:

    >>> import numpy as np

Импортирование numpy под псевдонимом np уже стало общепринятой, негласной, договоренностью, можно сказать, традицией.

Теперь мы можем приступить к примерам. Способов создания массивов NumPy довольно много, но мы начнем с самого тривиального - создание массива из заполненного вручную списка Python:

    >>> a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
    >>> 
    >>> a
    array([11, 22, 33, 44, 55, 66, 77, 88, 99])

Теперь у нас есть одномерный массив (словосочетание "ранг массива" вряд ли приживется в русском языке), т.е. у него всего одна ось вдоль которой происходит индексирование его элементов.

![Массив](/Articles/_NumPy/_NumPyProg.pro/pictures/001_002.jpg)

Получить доступ к числу 33 можно привычным способом:

    >>> a[2]
    33

В общем-то, можно подумать, что ничего интересного и нет в этих массивах, но на самом деле это только начало кроличьей норы. Оцените:

    >>> a[[7, 0, 3, 3, 3, 0, 7]]
    array([88, 11, 44, 44, 44, 11, 88])

Вместо одного индекса, указан целый список индексов. А вот еще любопытный пример, теперь вместо индекса укажем логическое выражение:

    >>> a[a > 50]
    array([55, 66, 77, 88, 99])

Цель этих двух примеров - не устраивать головоломку, а продемонстрировать расширенные возможности индексирования массивов NumPy. С тем как устроена индексация мы разберемся в другой главе. Что еще интересного можно продемонстрировать? Векторизованные вычисления:

    >>> 2*a + 10
    array([ 32,  54,  76,  98, 120, 142, 164, 186, 208])
    >>> 
    >>> np.sin(a)**2 + np.cos(a)**2
    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])

Векторизованные - означает, что все арифметические операции и математические функции выполняются сразу над всеми элементами массивов. А это в свою очередь означает, что нет никакой необходимости выполнять вычисления в цикле. В случае одномерного массива, можно подумать, что это не такой уж бонус, ведь есть генераторы. Но давайте перейдем к двумерным массивам:

    >>> a = np.arange(12)
    >>> a
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
    >>> 
    >>> a = a.reshape(3, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])

Сейчас мы создали массив с помощью функции np.arange(), которая во многом аналогична функции range() языка Python. Затем, мы изменили форму массива с помощью метода reshape(), т.е. на самом деле создать этот массив мы могли бы и одной командой:

    >>> a = np.arange(12).reshape(3, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])

Визуально, данный массив выглядит следующим образом:

![Матрица](/Articles/_NumPy/_NumPyProg.pro/pictures/001_003.jpg)

Глядя на картинку, становится понятно, что первая ось (и индекс соответственно) - это строки, вторая ось - это столбцы. Т.е. получить элемент 9 можно простой командой:

    >>> a[2][1]    #  равносильно команде a[2, 1]
    9

Снова можно подумать, что ничего нового - все как в Python. Да, так и есть, и, это круто! Еще круто, то что NumPy добавляет к удобному и привычному синтаксису Python, весьма удобные трюки, например - транслирование массивов:

    >>> b = [2, 3, 4, 5]
    >>> 
    >>> a*b
    array([[ 0,  3,  8, 15],
        [ 8, 15, 24, 35],
        [16, 27, 40, 55]])

В данном примере, без всяких циклов (и генераторов), мы умножили каждый столбец из массива a на соответствующий элемент из массива b. Т.е. мы как бы транслировали (в какой-то степени можно сказать - растянули) массив b по массиву a.

То же самое мы можем проделать с каждой строкой массива a:

    >>> c = [[10], [20], [30]]
    >>> 
    >>> a + c
    array([[10, 11, 12, 13],
        [24, 25, 26, 27],
        [38, 39, 40, 41]])

В данном случае мы просто прибавили к массиву a массив-столбец c. И получили, то что хотели. Сейчас мы не будем подробно рассматривать механизм транслирования - это тема другой главы. Вместо этого я хочу отметить, что при работе с двумерными или трехмерными массивами, особенно с массивами большей размерности, становится очень важным удобство работы с элементами массива, которые расположены вдоль отдельных измерений - его осей.

Например, у нас есть двумерный массив и мы хотим узнать его минимальные элементы по строкам и столбцам. Для начала создадим массив из случайных чисел и пусть, для нашего удобства, эти числа будут целыми:

    >>> a = np.random.randint(0, 15, size = (4, 6))
    >>> a
    array([[ 9, 12,  5,  3,  1,  7],
        [ 2, 12, 10, 11, 14,  9],
        [ 4,  4,  9, 11,  5,  2],
        [12,  8,  6,  8,  9,  3]])

Минимальный элемент в данном массиве это:

    >>> a.min()
    1

А вот минимальные элементы по столбцам и строкам:

    >>> a.min(axis = 0)    #  минимальные элементы по столбцам
    array([2, 4, 5, 3, 1, 2])
    >>> 
    >>> a.min(axis = 1)    #  минимальные элементы по строкам
    array([1, 2, 2, 3])

Такое поведение заложено практически во все функции и методы NumPy:

    >>> a.mean(axis = 0)    #  среднее по столбцам
    array([6.75, 9.  , 7.5 , 8.25, 7.25, 5.25])
    >>> 
    >>> np.std(a, axis = 1)    #  стандартное отклонение по строкам
    array([3.67045259, 3.77123617, 3.13138237, 2.74873708])

Что ж, мы рассмотрели одномерные и двумерные массивы, а так же некоторые трюки NumPy. Но данный пакет позиционируется прежде всего как научный инструмент. Что насчет вычислений, их скорости и занимаемой памяти?

Для примера, создадим трехмерный массив:

    >>> a = np.arange(48).reshape(4, 3, 4)
    >>> a
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]],

        [[24, 25, 26, 27],
            [28, 29, 30, 31],
            [32, 33, 34, 35]],

        [[36, 37, 38, 39],
            [40, 41, 42, 43],
            [44, 45, 46, 47]]])

Почему именно трехмерный? На самом деле реальный мир вовсе не ограничивается таблицами, векторами и матрицами. 

Еще существуют тензоры, кватернионы, октавы. А некоторые данные, гораздо удобнее представлять именно в трехмерном и четырехмерном представлении, например, биржевые торги по всем инструментам, лучше всего представлять в трехмерном виде, а торги нескольких бирж в четырехмерном. 

Конечно, такими сложными вычислениями занимается очень небольшое количество людей, но надо отметить, что именно эти люди двигают науку и индустрию вперед. Да и слово "сложное" можно считать синонимом "интересное. Поэтому... что-то мы отвлеклись... вот наш трехмерный массив:

![трехмерный массив](/Articles/_NumPy/_NumPyProg.pro/pictures/001_004.jpg)

Визуализация (и хорошее воображение) позволяет сразу догадаться, как устроена индексация трехмерных массивов. Например, если нам нужно вытащить из данного массива число 31, то достаточно выполнить:

    >>> a[2][1][3]    #  или a[2, 1, 3]
    31

### ndim
Но, что если мы хотим узнать побольше об этом массиве. В самом деле, у массивов есть целый ряд важных атрибутов. Например, количество осей массива (его размерность), которую при работе с очень большими массивами, не всегда легко увидеть:

    >>> a.ndim
    3

### shape
Массив a действительно трехмерный. Но иногда становится интересно, а на сколько же большой массив перед нами. Например, какой он формы, т.е. сколько элементов расположено вдоль каждой оси? Ответить позволяет метод ndarray.shape:

    >>> a.shape
    (4, 3, 4)

### size
Метод ndarray.size просто возвращает общее количество элементов массива:

    >>> a.size
    48

### itemsize
Еще может встать такой вопрос - сколько памяти занимает наш массив? Иногда даже возникает такой вопрос - влезет ли результирующий массив после всех вычислений в оперативную память? Что бы на него ответить надо знать, сколько "весит" один элемент массива:

    >>> a.itemsize    #  эквивалентно ndarray.dtype.itemsize
    4

ndarray.itemsize возвращает размер элемента в байтах. Теперь мы можем узнать сколько "весит" наш массив:

    >>> a.size*a.itemsize
    192

Итого - 192 байта. 

На самом деле, размер занимаемой массивом памяти, зависит не только от количества элементов в нем, но и от испльзуемого типа данных:

    >>> a.dtype
    dtype('int32')

### dtype
dtype('int32') - означает, что используется целочисленный тип данных, в котором для хранения одного числа выделяется 32 бита памяти. Но если мы выполним какие-нибудь вычисления с массивом, то тип данных может измениться:

    >>> b = a/3.14
    >>> 
    >>> b
    array([[[ 0.        ,  0.31847134,  0.63694268,  0.95541401],
            [ 1.27388535,  1.59235669,  1.91082803,  2.22929936],
            [ 2.5477707 ,  2.86624204,  3.18471338,  3.50318471]],

        [[ 3.82165605,  4.14012739,  4.45859873,  4.77707006],
            [ 5.0955414 ,  5.41401274,  5.73248408,  6.05095541],
            [ 6.36942675,  6.68789809,  7.00636943,  7.32484076]],

        [[ 7.6433121 ,  7.96178344,  8.28025478,  8.59872611],
            [ 8.91719745,  9.23566879,  9.55414013,  9.87261146],
            [10.1910828 , 10.50955414, 10.82802548, 11.14649682]],

        [[11.46496815, 11.78343949, 12.10191083, 12.42038217],
            [12.7388535 , 13.05732484, 13.37579618, 13.69426752],
            [14.01273885, 14.33121019, 14.64968153, 14.96815287]]])
    >>> 
    >>> 
    >>> b.dtype
    dtype('float64')

Теперь у нас есть еще один массив - массив b и его тип данных 'float64' - вещественные числа (числа с плавающей точкой) длинной 64 бита. А его размер:

    >>> b.size*b.itemsize
    384

Тогда массив a - 192 байта, массив b - 384 байта. А в общем, получается, 576 байт - что очень мало для современных объемов оперативной памяти, но и реальные объемы данных, которые сейчас приходится обрабатывать совсем немаленькие.

Мы с вами собирались ответить на вопросы производительности вычислений в NumPy, но это тоже тема отдельной главы. 

Могу лишь сказать, что на самом деле скорость вычислений, очень сильно зависит от того кода, который вы пишите. Например, частое копирование и присваивание массивов, приводит к бесполезному потреблению памяти, а работа универсальных функций NumPy без дополнительных настроек, особенно в циклах, так же может выполняться несколько медленнее. В общем задача по использованию всего вычислительного потенциала программного обеспечения и железа, не такая уж и простая, но определенно решаемая задача.

[Содержание](#содержание)

# 3.3. Напоследок
Если вы новичок, то очень скоро поймете, что в использовании NumPy так же прост как и Python. Но, рано или поздно, дело дойдет до сложных задач и вот тогда начнется самое интересное: документации не хватает, ничего не гуглится, а бесчисленные "почти" подходящие советы приводят к необъяснимым сверхъестественным последствиям. Что делать в такой ситуации?
+ гуглить упорнее и спускаться к самому дну поисковой выдачи;
+ гуглить на английском языке, потому что, на английском информации на порядки больше чем на русском;
+ если не помог пункт 2, то это означает, что вы просто маньяк какой-то, и что бы решить свою маниакальную задачу, вам придется гуглить на китайском языке, потому что на китайском информации на порядки больше чем на английском.

Это шутка и серьезная рекомендация одновременно. 

Но, если говорить абсолютно серьезно, то просто придерживайтесь здравого смысла. Где этот здравый смысл начинается, а где заканчивается в конкретной задаче сказать очень трудно. import this вам в помощь:

    >>> import this
    The Zen of Python, by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

Если вы раньше пользовались R или matlab, то вас тоже ожидает много приятных сюрпризов, по крайней мере один - придется меньше стучать по клавиатуре.

[Содержание](#содержание)

# 4. Создание массивов
Данная глава является лишь кратким обзором, поскольку способов создания массивов очень много, их описание и примеры использования вы найдете в разделе ["Создание массивов"](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#1-создание-массивов) справочного руководства.

### [array()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#array)
И так, массив может быть создан из обычного списка или кортежа Python с использованием функции array(). Причем тип полученного массива зависит от типа элементов последовательности:

    >>> import numpy as np
    >>>
    >>> a = np.array([1, 2, 3])
    >>> a
    array([1, 2, 3])
    >>> a.dtype
    dtype('int32')
    >>>
    >>> a = np.array([1.1, 2.2, 3.3])
    >>> a
    array([ 1.1,  2.2,  3.3])
    >>> a.dtype
    dtype('float64')
    >>>
    >>> a = np.array([1 + 2j, 2 + 3j])
    >>> a.dtype
    dtype('complex128')

Необходимо помнить о том, что аргументом функции array() должна быть именно последовательность, а не несколько аргументов.

    >>> a = np.array(1, 2, 3)      #  Неправильно!!!
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: only 2 non-keyword arguments accepted
    >>>
    >>> a = np.array([1, 2, 3])    #  Правильно
    >>> a
    array([1, 2, 3])
    >>>
    >>> a = np.array((1, 2, 3))    #  И так тоже правильно
    >>> a
    array([1, 2, 3])

Функция array() преобразует последовательности последовательностей в двумерные массивы, а последовательности последовательностей, которые тоже состоят из последовательностей в трехмерные массивы. То есть уровень вложенности исходной последовательности определяет размерность получаемого массива:

    >>> a = np.array([[2, 4], [6, 8], [10, 12]])
    >>> a
    array([[ 2,  4],
        [ 6,  8],
        [10, 12]])
    >>>
    >>> b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
    >>> b
    array([[[ 1,  2],
            [ 3,  4]],

        [[ 5,  6],
            [ 7,  8]],

        [[ 9, 10],
            [11, 12]]])
    >>>
    >>> a.ndim    #  Количество осей массива
    2
    >>> b.ndim
    3

Функция array() так же позволяет определить тип данных массива.

    >>> a = np.array([[2, 4], [6, 8], [10, 12]], dtype = complex )
    >>> a
    array([[  2.+0.j,   4.+0.j],
        [  6.+0.j,   8.+0.j],
        [ 10.+0.j,  12.+0.j]])
    >>>
    >>> a = np.array([[2, 4], [6, 8], [10, 12]], dtype = float )
    >>> a
    array([[  2.,   4.],
        [  6.,   8.],
        [ 10.,  12.]])

Очень часто возникает задача создания массива определенного размера, причем чем заполнен массив абсолютно неважно. В этом случае можно воспользоваться циклами или генераторами списков (кортежей), но NumPy для таких случаев предлагает более быстрые и менее затратные функции-заполнители.

### [zeros()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#zeros), [ones()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#ones), [empty()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#empty)
Функция zeros заполняет массив нулями, функция ones - единицами, а функция empty - случайными числами, которые зависят от состояния памяти. По умолчанию, тип создаваемого массива - float64.

    >>> np.zeros((3,3))
    array([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])
    >>>
    >>> np.ones((3,3))
    array([[ 1.,  1.,  1.],
        [ 1.,  1.,  1.],
        [ 1.,  1.,  1.]])
    >>>
    >>> np.ones((3,3), dtype = complex)  #  Можно изменить тип массива
    array([[ 1.+0.j,  1.+0.j,  1.+0.j],
        [ 1.+0.j,  1.+0.j,  1.+0.j],
        [ 1.+0.j,  1.+0.j,  1.+0.j]])
    >>>
    >>> np.empty([3, 3])
    array([[ -2.56357799e-042,   1.00079160e-313,  -5.41541116e-070],
        [  1.51668796e-314,   0.00000000e+000,   1.48219694e-320],
        [  2.61270984e-262,   0.00000000e+000,   8.36469502e-316]])

### [arange()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#arange)
Для создания последовательностей чисел NumPy предоставляет функцию arange, которая возвращает одномерные массивы:

    >>> np.arange(10)    #  От 0 до указанного числа
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>>
    >>> np.arange(10, 20)    #  Диапазон
    array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    >>>
    >>> np.arange(20, 100, 10)    #  Диапазон с заданным шагом
    array([20, 30, 40, 50, 60, 70, 80, 90])
    >>>
    >>> np.arange(0, 1, 0.1)    #  Аргументы могут иметь тип float
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])

Если функция arange используется с аргументами типа float, то предсказать количество элементов в возвращаемом массиве не так-то просто. Гораздо чаще возникает необходимость указания не шага изменения чисел в диапазоне, а количества чисел в заданном диапазоне. 

### [linspace()](/Articles/_NumPy/_NumPyProg.pro/ReferenceGuide.md#linspace)

Функция linspace, так же как и arange принимает три аргумента, но третий аргумент, как раз и указывает количество чисел в диапазоне.

    >>> np.linspace(0, 1, 5)
    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
    >>>
    >>> np.linspace(0, 1, 7)
    array([ 0.        ,  0.16666667,  0.33333333,  0.5       ,  0.66666667,
            0.83333333,  1.        ])
    >>>
    >>> np.linspace(10, 100, 5)
    array([  10. ,   32.5,   55. ,   77.5,  100. ])

Функция linspace удобна еще и тем, что может быть использована для вычисления значений функций на заданном множестве точек:

    >>> x = np.linspace( 0, 2*np.pi, 10 )
    >>> x
    array([ 0.        ,  0.6981317 ,  1.3962634 ,  2.0943951 ,  2.7925268 ,
            3.4906585 ,  4.1887902 ,  4.88692191,  5.58505361,  6.28318531])
    >>>
    >>> y1 = np.sin(x)
    >>> y1
    array([  0.00000000e+00,   6.42787610e-01,   9.84807753e-01,
            8.66025404e-01,   3.42020143e-01,  -3.42020143e-01,
            -8.66025404e-01,  -9.84807753e-01,  -6.42787610e-01,
            -2.44929360e-16])
    >>>
    >>> y2 = np.cos(x)
    >>> y2
    array([ 1.        ,  0.76604444,  0.17364818, -0.5       , -0.93969262,
        -0.93969262, -0.5       ,  0.17364818,  0.76604444,  1.        ])

[Содержание](#содержание)

# 5. Вывод массивов на экран

Что бы быстрее разобраться с примерами печати массивов воспользуемся методом ndarray.reshape(), который позволяет изменять размеры массивов. Одномерные массивы в NumPy печатаются в виде строк:

    >>> a = np.arange(10)    #  Одномерный массив
    >>> print(a)
    [0 1 2 3 4 5 6 7 8 9]

Двумерные массивы печатаются в виде матриц:

    >>> b = np.arange(16).reshape(4,4)    #  Двумерный массив
    >>> print(b)
    [[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]
    [12 13 14 15]]

Трехмерные массивы печатаются в виде списка матриц, которые разделены пустой строкой:

    >>> c = np.arange(30).reshape(5,2,3)    #  Трехмерный массив
    >>> print(c)
    [[[ 0  1  2]
    [ 3  4  5]]

    [[ 6  7  8]
    [ 9 10 11]]

    [[12 13 14]
    [15 16 17]]

    [[18 19 20]
    [21 22 23]]

    [[24 25 26]
    [27 28 29]]]

Печать четырехмерных массивов происходит в виде списка трехмерных массивов, которые разделены двумя пустыми строками:

    >>> d = np.arange(81).reshape(3, 3, 3, 3)    #  Четырехмерный массив
    >>> print(d)
    [[[[ 0  1  2]
    [ 3  4  5]
    [ 6  7  8]]

    [[ 9 10 11]
    [12 13 14]
    [15 16 17]]

    [[18 19 20]
    [21 22 23]
    [24 25 26]]]


    [[[27 28 29]
    [30 31 32]
    [33 34 35]]

    [[36 37 38]
    [39 40 41]
    [42 43 44]]

    [[45 46 47]
    [48 49 50]
    [51 52 53]]]


    [[[54 55 56]
    [57 58 59]
    [60 61 62]]

    [[63 64 65]
    [66 67 68]
    [69 70 71]]

    [[72 73 74]
    [75 76 77]
    [78 79 80]]]]

Можете поэкспериментировать с печатью массивов большей размерности и вы убедитесь, что в ней довольно легко ориентироваться.

В случае, если массив очень большой (больше 1000 элементов), NumPy печатает только начало и конец массива, заменяя его центральную часть многоточием.

    >>> print(np.arange(1001))
    [   0    1    2 ...,  998  999 1000]
    >>>
    >>> print(np.arange(1000000))
    [     0      1      2 ..., 999997 999998 999999]
    >>> 
    >>> print(np.arange(1000000).reshape(1000,1000))
    [[     0      1      2 ...,    997    998    999]
    [  1000   1001   1002 ...,   1997   1998   1999]
    [  2000   2001   2002 ...,   2997   2998   2999]
    ..., 
    [997000 997001 997002 ..., 997997 997998 997999]
    [998000 998001 998002 ..., 998997 998998 998999]
    [999000 999001 999002 ..., 999997 999998 999999]]
    
Если необходимо выводить весь массив целиком, то такое поведение печати можно изменить с помощью set_printoptions.

    >>>np.set_printoptions(threshold=np.nan)
    >>> #  Придётся лицезреть что-то подобное:
    ... 
    >>> print(np.arange(1001))
    [   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14
    15   16   17   18   19   20   21   22   23   24   25   26   27   28   29
    30   31   32   33   34   35   36   37   38   39   40   41   42   43   44
    45   46   47   48   49   50   51   52   53   54   55   56   57   58   59
    60   61   62   63   64   65   66   67   68   69   70   71   72   73   74
    75   76   77   78   79   80   81   82   83   84   85   86   87   88   89
    90   91   92   93   94   95   96   97   98   99  100  101  102  103  104
    105  106  107  108  109  110  111  112  113  114  115  116  117  118  119
    120  121  122  123  124  125  126  127  128  129  130  131  132  133  134
    135  136  137  138  139  140  141  142  143  144  145  146  147  148  149
    150  151  152  153  154  155  156  157  158  159  160  161  162  163  164
    165  166  167  168  169  170  171  172  173  174  175  176  177  178  179
    180  181  182  183  184  185  186  187  188  189  190  191  192  193  194
    195  196  197  198  199  200  201  202  203  204  205  206  207  208  209
    210  211  212  213  214  215  216  217  218  219  220  221  222  223  224
    225  226  227  228  229  230  231  232  233  234  235  236  237  238  239
    240  241  242  243  244  245  246  247  248  249  250  251  252  253  254
    255  256  257  258  259  260  261  262  263  264  265  266  267  268  269
    270  271  272  273  274  275  276  277  278  279  280  281  282  283  284
    285  286  287  288  289  290  291  292  293  294  295  296  297  298  299
    300  301  302  303  304  305  306  307  308  309  310  311  312  313  314
    315  316  317  318  319  320  321  322  323  324  325  326  327  328  329
    330  331  332  333  334  335  336  337  338  339  340  341  342  343  344
    345  346  347  348  349  350  351  352  353  354  355  356  357  358  359
    360  361  362  363  364  365  366  367  368  369  370  371  372  373  374
    375  376  377  378  379  380  381  382  383  384  385  386  387  388  389
    390  391  392  393  394  395  396  397  398  399  400  401  402  403  404
    405  406  407  408  409  410  411  412  413  414  415  416  417  418  419
    420  421  422  423  424  425  426  427  428  429  430  431  432  433  434
    435  436  437  438  439  440  441  442  443  444  445  446  447  448  449
    450  451  452  453  454  455  456  457  458  459  460  461  462  463  464
    465  466  467  468  469  470  471  472  473  474  475  476  477  478  479
    480  481  482  483  484  485  486  487  488  489  490  491  492  493  494
    495  496  497  498  499  500  501  502  503  504  505  506  507  508  509
    510  511  512  513  514  515  516  517  518  519  520  521  522  523  524
    525  526  527  528  529  530  531  532  533  534  535  536  537  538  539
    540  541  542  543  544  545  546  547  548  549  550  551  552  553  554
    555  556  557  558  559  560  561  562  563  564  565  566  567  568  569
    570  571  572  573  574  575  576  577  578  579  580  581  582  583  584
    585  586  587  588  589  590  591  592  593  594  595  596  597  598  599
    600  601  602  603  604  605  606  607  608  609  610  611  612  613  614
    615  616  617  618  619  620  621  622  623  624  625  626  627  628  629
    630  631  632  633  634  635  636  637  638  639  640  641  642  643  644
    645  646  647  648  649  650  651  652  653  654  655  656  657  658  659
    660  661  662  663  664  665  666  667  668  669  670  671  672  673  674
    675  676  677  678  679  680  681  682  683  684  685  686  687  688  689
    690  691  692  693  694  695  696  697  698  699  700  701  702  703  704
    705  706  707  708  709  710  711  712  713  714  715  716  717  718  719
    720  721  722  723  724  725  726  727  728  729  730  731  732  733  734
    735  736  737  738  739  740  741  742  743  744  745  746  747  748  749
    750  751  752  753  754  755  756  757  758  759  760  761  762  763  764
    765  766  767  768  769  770  771  772  773  774  775  776  777  778  779
    780  781  782  783  784  785  786  787  788  789  790  791  792  793  794
    795  796  797  798  799  800  801  802  803  804  805  806  807  808  809
    810  811  812  813  814  815  816  817  818  819  820  821  822  823  824
    825  826  827  828  829  830  831  832  833  834  835  836  837  838  839
    840  841  842  843  844  845  846  847  848  849  850  851  852  853  854
    855  856  857  858  859  860  861  862  863  864  865  866  867  868  869
    870  871  872  873  874  875  876  877  878  879  880  881  882  883  884
    885  886  887  888  889  890  891  892  893  894  895  896  897  898  899
    900  901  902  903  904  905  906  907  908  909  910  911  912  913  914
    915  916  917  918  919  920  921  922  923  924  925  926  927  928  929
    930  931  932  933  934  935  936  937  938  939  940  941  942  943  944
    945  946  947  948  949  950  951  952  953  954  955  956  957  958  959
    960  961  962  963  964  965  966  967  968  969  970  971  972  973  974
    975  976  977  978  979  980  981  982  983  984  985  986  987  988  989
    990  991  992  993  994  995  996  997  998  999 1000]