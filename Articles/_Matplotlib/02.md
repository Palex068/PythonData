# 2. Я новичок. Можно попроще?

Новичкам, которые пытаются изучать matplotlib самостоятельно, рано или поздно, начинает казаться, что все слишком запутано и сложно. <br>
Вроде бы все примеры с официального руководства работают, получаются красивые картинки. Но сделать, что-то свое либо не получается, либо получается, но без понимания того, как это работает.

Как с ней познакомиться и с какого края к ней подойти? Библиотека matplotlib предназначена для создания научной графики. На мой взгляд, знакомство лучше начать с двух простых вопросов:
+ Какие бывают графики?
+ Как они строятся?

Учитывая, что в простейшем случае, графики строятся парой-тройкой строчек кода, вы очень скоро убедитесь в том, что все довольно просто.

## Содержание

+ [График линии](#график-линии)
+ [График множества точек](#график-множества-точек)
+ [Гистограммы](#гистограммы)
+ [Круговые диаграммы](#круговые-диаграммы)
+ [Ящик с усами](#ящик-с-усами)
+ [Что дальше?](#что-дальше)

<hr>

[Содержание руководства по Matplotlib](/Articles/_Matplotlib/README.MD)

## График линии

Метод построения линии очень прост:
+ есть массив абсцис $(x)$;
+ есть массив ординат $(y)$;
+ элементы с одинаковым индексом в этих массивах - это координаты точек на плоскости;
+ последовательные точки соединяются линией.

Под массивами, подразумеваются списки, кортежи или массивы NumPy. <br>
Кстати, последние предоставляют гораздо больше удобств чем списки и кортежи, поэтому знание пакета NumPy может значительно упростить вам жизнь.

Давайте выполним следующий код:
```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((0, 1, 2, 3, 4, 5, 6, 7), (0, 3, 1, 2, 1, 5, 4, 0))
plt.show()
```

В результате мы получим вот такой простой график:

![График](/Articles/_Matplotlib/Pictures/002_001.PNG)

Метод __plt.plot()__, в простейшем случае, принимает один аргумент - последовательность чисел, которая соответствует оси ординат (y), ось абсцис (x) строится автоматически от 0 до n, где n - это длинна массива ординат. Следующий код построит точно такой же график:
```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((0, 3, 1, 2, 1, 5, 4, 0))
plt.show()
```

Такой способ может оказаться полезным, если диапазон чисел на оси абцис для вас не важен. Однако, если диапазон или шаг все-таки важны, то их все же необходимо указать:
```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((-4, -3, -2, -1, 0, 1, 2, 3), (0, 3, 1, 2, 1, 5, 4, 0))
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_002.PNG)

```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((-0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3), (0, 3, 1, 2, 1, 5, 4, 0))
plt.show()
```
![График](/Articles/_Matplotlib/Pictures/002_003.PNG)

Еще один интересный момент - числа в массиве абсцис не обязательно должны быть последовательными, т.е. могут быть абсолютно произвольными, а соединяться линией будут так же только последовательные точки. 

Например:

```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((0, 0, 5, 4, 0), (0, 3, 2, 1, 0))
plt.show()
```
![График](/Articles/_Matplotlib/Pictures/002_004.PNG)

Такое поведение очень удобно, когда вам необходимо строить плоские, замкнутые кривые или геометрические фигуры:

```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot((0, 0, 1, 1, 0), (0, 1, 1, 0, 0))
plt.plot((0.1, 0.5, 0.9, 0.1), (0.1, 0.9, 0.1, 0.1))
plt.show()
```
![График](/Articles/_Matplotlib/Pictures/002_005.PNG)

Как вы заметили мы два раза использовали метод __plt.plot()__, передавая разные данные. С определенной натяжкой, можна сказать, что метод __plt.plot()__ и занимается прорисовкой наших линий, а __plt.show()__ отображением самого графика. <br>
Но мы оставим все подробности на потом и двинемся дальше.

[Содержание](#содержание)

<hr>

## График множества точек

Единственное отличие графика множества точек от графика линии - точки не соединяются линией. Вот и все.

```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.scatter([0, 1, 2, 3, 4 , 5], [0, 1, 2, 3, 4 , 5])
plt.show()
```
![График](/Articles/_Matplotlib/Pictures/002_006.PNG)

Все как и прежде двум соответствующим значениям из массивов соответствуют координаты точки.

Если у вас несколько множеств, то все их так же можно построить на одном графике:

```python
%matplotlib inline
import matplotlib.pyplot as plt
plt.scatter([0, 1, 2, 3, 4 , 5], [0, 1, 2, 3, 4 , 5])
plt.scatter([1, 2, 3, 1, 2 , 1], [2, 3, 4, 3, 4 , 4])
plt.scatter([2, 3, 4, 3, 4 , 4], [1, 2, 3, 1, 2 , 1])
plt.show()
```
![График](/Articles/_Matplotlib/Pictures/002_007.PNG)

[Содержание](#содержание)

<hr>

## Гистограммы

Очень часто, данные удобно представлять в виде гистограмм. В самом простом случае, гистограмма - это множество прямоугольников, площадь которых (или высота) пропорциональна какой-нибудь величине. Например, осадки за $3# месяца: в июне выпало $10$ мм, в июле - $15$ мм, в августе - $21$ мм.

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.bar([6, 7, 8], [10, 15, 21])
plt.show()
```
![pyplot](/Articles/_Matplotlib/Pictures/002_008.PNG)

Первый массив содержит номера месяцев, а второй массив - значения показателей. <br>
Эти прямоугольники построены вертикально, но их можно отображать и в горизонтальном виде:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.barh([6, 7, 8], [10, 15, 21])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_009.PNG)

Гистограммы могут отображать несколько наборов данных, что очень удобно для их сравнения:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.bar([6, 7, 8], [10, 15, 21])
plt.bar([6, 7, 8], [6, 12, 21])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_010.PNG)

Такой график мог бы отображать летние осадки за два года. <br>
Но вот в чем дело, прямоугольники строятся поверх друг друга и если они равны, как в случае наших осадков за август, то прямоугольники друг друга перекроют. Если указать небольшое смещение по оси x, то ситуация не улучшится:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.bar([6, 7, 8], [10, 15, 21])
plt.bar([6.5, 7.5, 8.5], [6, 12, 28])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_011.PNG)

График станет привлекательней, если сузить прямоугольники и расположить их без наложения друг на друга:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.bar([5.9, 6.9, 7.9], [10, 15, 21], width = 0.2)
plt.bar([6.1, 7.1, 8.1], [6, 12, 28], width = 0.2)
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_012.PNG)

[Содержание](#содержание)

<hr>

## Круговые диаграммы

Если вам необходимо наглядно отобразить соотношение частей целого, то лучше воспользоваться круговой диаграммой. Например, в компании работают $50$ человек из них $40$ женщин и $10$ мужчин:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.pie([40, 10])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_013.PNG)

Все предельно просто - количество элементов в массиве определяет количество клиньев, а величина значений определяет их площадь:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.pie([5, 13, 21, 27, 10, 17])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_014.PNG)

[Содержание](#содержание)

<hr>

## Ящик с усами

Данный тип графиков действительно похож на ящик с усами (если повернуть монитор на $90^o$):

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.boxplot([1, 5, 7, 4, 6, 10])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_015.PNG)

Но на самом деле этот ящик с усами является диаграммой размаха, служит для отображения случайной величины и несет в себе достаточно много информации. 

Во первых, внутри ящика оранжевой линией отмечена медиана элементов массива - это такое значение которое меньше и больше ровно половины элементов массива. 

В нашем случае, это значение равно $5.5$ и как нетрудно заметить половина элементов меньше его, а другая больше. 

Его границами служат $25$-й и $75$-й процентили ($4.25$ и $6.75$ для нашего массива). 

Ну а усами, собственно (как правило) максимальное и минимальное значение в наборе данных. Вот такой непростой, но очень полезный ящик.

Иногда на графике, рядом с усами появляются одна или две точки. Такие точки обозначают выбросы - значения которые находятся очень далеко от статистически значимой части данных:

```python
%matplotlib inline
import matplotlib.pyplot as plt

plt.boxplot([[1, 5, 7, 4, 6, 10, 15],
             [-2, 5, 7, 4, 6, 10, 15],
             [-4, 5, 7, 4, 6, 10]])
plt.show()
```

![График](/Articles/_Matplotlib/Pictures/002_016.PNG)

Как не трудно догадаться, в основе данного типа графиков находится статистическая подоплека и наиболее полезен он именно в этой области.

![График](/Articles/_Matplotlib/Pictures/002_016.PNG)

[Содержание](#содержание)

<hr>

## Что дальше?

Мы построили несколько очень простых графиков и если вам нужно просто взглянуть на данные, то этих методов уже достаточно. Так же мы построили "ящик с усами" - достаточно сложный график, но и он строится по недвусмысленным, четким правилам. Да, __matplotlib__ умеет строить очень сложные графики, например, графики автокорреляции или спектрограмм.

Но, преимущество данной библиотеки даже не в том что она может строить кучу разных графиков, а в том что она предоставляет полный контроль (хотя, полный вовсе не означает, что он простой) над всем, что может отобразить (полный не означает простой).

Собственно, теперь можно сделать следующий шаг - разобраться с магическими командами IPython для matplotlib и с тем как устроена область отображения графиков.

[Содержание](#содержание)

<hr>

[Содержание руководства по Matplotlib](/Articles/_Matplotlib/README.MD)