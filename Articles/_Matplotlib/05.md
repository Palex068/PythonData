# 5. Как строить графики?

## Содержание
+ [Как строить графики?](#как-строить-графики)
+ [Plot - график линии](#plot---график-линии)
+ [Scatter - график разброса (точки)](#scatter---график-разброса-точки)
+ [Bar - гистограмма (столбчатые диаграммы)](#bar---гистограмма)
+ [Fill - закрашенный многоугольник](#fill---закрашенный-многоугольник)
+ [Fill_between - закрашенная область между линиями](#fill_between---закрашенная-область-между-линиями)
+ [Stackplot - надставленные области](#stackplot---надставленные-области)
+ [Imshow - картинки](#imshow---картинки)
+ [Contour - линии уровней](#contour---линии-уровней)
+ [Pcolormesh - псевдоцветная сетка](#pcolormesh---псевдоцветная-сетка)
+ [Arrow - стрелка](#arrow---стрелка)
+ [Quiver - поле векторов](#quiver---поле-векторов)
+ [Streamplot - поток векторов](#streamplot---поток-векторов)

[Содержание руководства по Matplotlib](/Articles/_Matplotlib/README.MD)


## Как строить графики?

Как размещать несколько графиков вместе (несколько областей Axes на Figure) мы разобрались. Как теперь строить эти самые графики? Все довольно просто, после того как мы создали область Axes, которая по сути является объектом Python, мы можем воспользоваться любым из методов этого объекта, включая и те, которые занимаются отображением данных на этой области:

```python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

#  Данные, которые хотим отобразить:
x1 = 10*np.random.rand(100)    #  координаты 'x'
y1 = 10*np.random.rand(100)    #  координаты 'y'

ax.scatter(x1, y1)    #  метод, отображающий данные в виде точек
                      #  на плоскости

ax.set(title='Случайные точки')    #  метод, размещающий заголовок
                                       #  над "Axes"
    
plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_001.PNG)

При этом мы можем отображать на одной области Axes несколько наборов данных, как одинаковыми так и разными методами:

```python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

x1 = np.linspace(0, 10, 30)
y1 = np.random.beta(0.1, 0.6, size = 30)
x2 = np.linspace(11, 20, 30)
y2 = np.random.gamma(shape = 0.3, scale = 1.1, size = 30)
x3 = np.linspace(21, 30, 30)
y3 =np.random.pareto(3.5, size = 30)

#  Данные в виде точек:
ax.scatter(x1, y1)
ax.scatter(x2, y2)
ax.scatter(x3, y3)

#  Данные в виде линий:
ax.plot(x1, y1 + 3)
ax.plot(x2, y2 + 3)
ax.plot(x3, y3 + 3)

ax.set(title='Бетта, Гамма и Паретто распределения')
    
plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_002.PNG)

В случае, когда у нас несколько областей Axes, то отображение на них данных, ничем не отличается от случая единственной области. <br>
Однако, если вы помните, области Axes можно добавить двумя способами: add_subplot() и subplots(). 

Давайте рассмотрим случай add_subplot():

```python
import numpy as np
import matplotlib.pyplot as plt

#  Данные:
x = np.linspace(0, 10, 100)
y = np.sin(x)
img = y.reshape(5, 20)

#  Создаем "Figure" и "Axes":
fig = plt.figure()

ax_1 = fig.add_subplot(2, 1, 1)
ax_2 = fig.add_subplot(2, 1, 2)

#  Методы, отображающие данные:
ax_1.plot(x, y)
ax_2.imshow(img)

#  Добавление заголовков:
ax_1.set(title = 'sin(x)')
ax_2.set(title = 'img')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_003.PNG)

В случае subplots() все тоже самое, только к областям Axes мы обращаемся по индексу:

```python
import numpy as np
import matplotlib.pyplot as plt

#  Данные:
x = np.linspace(0, 10, 100)
y = np.sin(x)
img = y.reshape(5, 20)

#  Создаем "Figure" и "Axes":
fig, axes = plt.subplots(nrows = 2, ncols = 1)

#  Методы, отображающие данные:
axes[0].plot(x, y)
axes[1].imshow(img)

#  Добавление заголовков:
axes[0].set(title = 'sin(x)')
axes[1].set(title = 'img')

plt.show()
```

И получаем тот же самый результат:

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_004.PNG)


[Содержание](#содержание)

<hr>

## Plot - график линии

Без преувеличения - это самый распространенный график и как он строится нам уже известно. Давайте разберемся с тем, как сделать эти графики более привлекательными.

### Цвет линии
Цвет линии можно указать с помощью параметра __color__. Само значение цвета может быть из самых разных цветовых моделей:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = np.zeros(8)

fig, ax = plt.subplots()

# RGB:
ax.plot(x, color = (0.9, 0.2, 0.9))

# RGBA:
ax.plot(np.arange(-1, 7),
        color = (0.1, 0.2, 0.9, 0.5),
        linewidth = 12)

# hex RGB:
ax.plot(x + 1, color = '#0a0b0c')

# hex RGBA:
ax.plot(x + 2, color = '#0a0b0c3a')

# уровень серого в интервале [0, 1]:
ax.plot(x + 3, color = '0.3')

# ключ цвета из {'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}:
ax.plot(x + 4, color = 'g')

# название цвета из X11/CSS4:
ax.plot(x + 5, color = 'indigo')

fig.set_figwidth(12)
fig.set_figheight(6)
fig.set_facecolor('mintcream')
ax.set_facecolor('whitesmoke')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_005.PNG)

Поддержка такого количества цветовых моделей позволяет выбирать именно ту, которая в данной ситуации наиболее удобна. Например, на лекции, я могу быстро установить цвет линии с помощью односимвольного ключа из 
```python
{'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}
```
но готовя график для презентации или публикации мне удобнее использовать X11/CSS4. 

В случае, когда цвет из X11/CSS4 не подходит, смотрю его код RGB и подгоняю до тех пор пока он меня не устроит. <br>
Некоторые мои знакомы подбирают цвета на специальных онлайн сервисах.

Наклоненная линия, цвет которой задан в модели RGBA увеличена в ширине, для наглядности ее прозрачности. <br>
Ширина линии задается с помощью параметра linewidth. Этот параметр часто применяется при изменении начертания линии:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-5, 5, 100)
y = np.sin(x)

fig, ax = plt.subplots()

#  Сплошная линия ('-' или 'solid',
#  установлен по умолчанию):
ax.plot(x, y,
        linestyle = '-',
        linewidth = 1,
        color = 'crimson')

# Пунктирная линия ('--' или 'dashed'):
ax.plot(x, y + 1,
        linestyle = '--',
        linewidth = 2,
        color = 'darkmagenta')

# Точка-тире ('-.' или 'dashdot'):
ax.plot(x, y + 2,
        linestyle = '-.',
        linewidth = 4,
        color = 'indigo')

# Точка-точка (':' или 'dotted'):
ax.plot(x, y + 3,
        linestyle = ':',
        linewidth = 6,
        color = 'darkblue')

fig.set_figwidth(12)
fig.set_figheight(6)
fig.set_facecolor('linen')
ax.set_facecolor('ivory')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_006.PNG)

Рано или поздно вы заметите, что тонкие пунктирные линии заставляют очень сильно напрягать зрение, но если слегка увеличить их ширину, то они воспринимаются гораздо легче.

Улучшить восприятие линии можно так же с помощью маркеров:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = np.zeros(10)

fig, ax = plt.subplots()

#  Вид (marker)и размер маркера (markersize):
ax.plot(x,
        marker = 'o',
        color = 'seagreen')
ax.plot(x + 1,
        marker = '^',
        markersize = 10,
        color = 'seagreen')
ax.plot(x + 2,
        marker = 's',
        markersize = 15,
        color = 'seagreen')
ax.plot(x + 3,
        marker = 'X',
        markersize = 20,
        color = 'seagreen')

#  Цвет маркера (markerfacecolor),
#  его края (markeredgecolor) и
#  толщина его края (markeredgewidth):
ax.plot(x + 5,
        marker = '^',
        markersize = 20,
        color = 'green',
        markerfacecolor = 'lawngreen',
        markeredgecolor = 'darkgreen',
        markeredgewidth = 3)
ax.plot(x + 6,
        marker = 's',
        markersize = 20,
        color = 'lime',
        linewidth = 4,
        markerfacecolor = 'lawngreen',
        markeredgecolor = 'limegreen',
        markeredgewidth = 5)
ax.plot(x + 7,
        marker = 'X',
        markersize = 20,
        color = 'teal',
        markerfacecolor = 'greenyellow',
        markeredgecolor = 'teal',
        markeredgewidth = 3)

fig.set_figwidth(12)
fig.set_figheight(6)
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_007.PNG)

[Содержание](#содержание)

<hr>

## Scatter - график разброса (точки)

График разброса - это тоже очень распространенный график. <br>
Как правило, именно глядя на него, начинаешь понимать, что в данных есть что-то любопытное. <br>
И как правило, этот график практически никогда не требует никакого изменения своего внешнего вида. <br>
Но иногда, наглядность данных сильно снижается из-за небольших размеров графика, а так же размеров и цветов используемых маркеров.

### Цвет точек
Цвет линии можно указать с помощью параметра c. Само значение цвета может быть из самых разных цветовых моделей.

Точки одного цвета:

```python
%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(1000)    #  x - координаты точек
y = np.random.rand(1000)    #  y - координаты точек

fig, ax = plt.subplots()

ax.scatter(x, y,
           c = 'deeppink')    #  цвет точек

ax.set_facecolor('black')     #  цвет области Axes
ax.set_title('Один цвет')     #  заголовок для Axes

fig.set_figwidth(8)     #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_008.PNG)

Если вы хотите поместить на одном графике разные наборы данных, то каждому такому набору можно сопоставить свой цвет точек:

```python
%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(1000)
y1 = np.random.gamma(1, size = 1000)
y2 = np.random.gamma(2, size = 1000)
y3 = np.random.gamma(4, size = 1000)
y4 = np.random.gamma(8, size = 1000)

fig, ax = plt.subplots()

# ключ цвета из {'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}:
ax.scatter(x, y1,
           c = 'r')
# RGB:
ax.scatter(x + 1, y2,
           c = [[0.1, 0.63, 0.55]])
# hex RGB:
ax.scatter(x + 2, y3,
           c = '#ad09a3')
# уровень серого в интервале [0, 1]:
ax.scatter(x + 3, y4,
           c = ['0.9'])


ax.set_facecolor('black')
ax.set_title('Один цвет')

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_009.PNG)

Как я и говорил, здесь можно увидеть два недостатка. <br>
Первый - это слишком большие точки, которые накладываются друг на друга и небольшой размер самого графика. 

Контролировать размер точек можно с помощью параметра s:

```python
%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(5000)
y1 = np.random.gamma(1, size = 5000)
y2 = np.random.gamma(2, size = 5000)
y3 = np.random.gamma(4, size = 5000)
y4 = np.random.gamma(8, size = 5000)

fig, ax = plt.subplots()

# ключ цвета из {'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}:
ax.scatter(x, y1,
           c = 'r',
           s = 1)
# RGB:
ax.scatter(x + 1, y2,
           c = [[0.1, 0.63, 0.55]],
           s = 1)
# hex RGB:
ax.scatter(x + 2, y3,
           c = '#ad09a3',
           s = 1)
# уровень серого в интервале [0, 1]:
ax.scatter(x + 3, y4,
           c = ['0.9'],
           s = 1)


ax.set_facecolor('black')
ax.set_title('Один цвет')

#  Увеличим размер графика:
fig.set_figwidth(14)
fig.set_figheight(14)

plt.show()
```


![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_010.PNG)

Как видите, мы разместили на графике 20000 точек, но от уменьшения размера точек и увеличения размеров самого графика он только выиграл в наглядности. Может показаться странным, но такие небольшие трюки могут очень сильно помочь вашей интуиции.

Второй недостаток - наложение точек друг на друга. Мы можем и не уменьшать размер самих точек, а добавить к их цвету прозрачности, зачастую, это тоже добавляет наглядности:

```python
%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(5000)
y1 = np.random.gamma(1, size = 5000)
y2 = np.random.gamma(2, size = 5000)
y3 = np.random.gamma(4, size = 5000)
y4 = np.random.gamma(8, size = 5000)

fig, ax = plt.subplots()

#  RGBA:
ax.scatter(x, y1,
           c = [[1, 0, 0, 0.05]])
#  RGBA:
ax.scatter(x + 1, y2,
           c = [[0.1, 0.63, 0.55, 0.05]])
#  hex RGBA:
ax.scatter(x + 2, y3,
           c = '#ad09a305')
#  RGBA:
ax.scatter(x + 3, y4,
           c = [[0.5, 0, 0.5, 0.05]])


ax.set_title('Прозрачные точки')

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_011.PNG)

RGB и RGBA цвет, который задается с помощью последовательности чисел, а так же уровень серого цвета, задаваемый одним числом нужно указывать в виде двумерной (RGB и RGBA) или одномерной последовательности (например c = ['0.9']). Дело в том, что мы можем задать цвет каждой точки с помощью одномерной последовательности, каждый элемент которой соотносится с точкой из x, y и задает ее цвет:

```python
import numpy as np
import matplotlib.pyplot as plt

x = [1, 2, 3, 4]
y = [1, 2, 3, 4]

fig, axes = plt.subplots(2, 2)


axes[0][0].scatter(x, y,
                   c = ['r', 'g', 'b', 'w'],
                   s = 1000)
axes[0][0].set_facecolor('black')
axes[0][0].set_title('Цвет каждой точки по строке-ключу')

axes[0][1].scatter(x, y,
                   c = [0.9, 0.8, 0.7, 0.6],
                   s = 1000)
axes[0][1].set_facecolor('black')
axes[0][1].set_title('Цвет каждой точки из встроенной палитры')

rgb = [[1, 0, 0], [0, 1, 0],
       [0, 0, 1], [0.5, 0.5, 0.5]]

axes[1][0].scatter(x, y,
                   c = rgb,
                   s = 1000)
axes[1][0].set_facecolor('black')
axes[1][0].set_title('RGB цвет каждой точки')

rgba = [[1, 0, 0, 0.1], [0, 1, 0, 0.1],
       [0, 0, 1, 0.2], [0.5, 0.5, 0.5, 0.3]]

axes[1][1].scatter(x, y,
                   c = rgba,
                   s = 1000)
axes[1][1].set_facecolor('black')
axes[1][1].set_title('RGBA цвет каждой точки')


fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```
![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_012.PNG)

Благодаря NumPy мы можем очень легко задать цвет каждой точки или закрасить их по определенному правилу:

```python
# Точки и цвет
import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(500)
y = np.random.rand(500)

fig, axes = plt.subplots(4, 1)

colors = np.random.rand(500)
axes[0].scatter(x, y, c = colors)
axes[0].set_facecolor('black')
axes[0].set_title('Цвет каждой точки из палитры по умолчанию')
axes[0].set_xticks([])

rgb = np.random.rand(500, 3)
axes[1].scatter(x, y, c = rgb)
axes[1].set_facecolor('black')
axes[1].set_title('RGB цвет каждой точки')
axes[1].set_xticks([])

rgba = np.random.rand(500, 4)
axes[2].scatter(x, y, c = rgba)
axes[2].set_facecolor('black')
axes[2].set_title('RGBA цвет каждой точки')
axes[2].set_xticks([])

#  Создаем массив цветов по определенному правилу
#  с помощью логических операций и индексации
#  массивов массивами булевых значений:
col = np.empty_like(y)
below_points = (y < 0.5)    #  скобки нужны для читабельности
upper_point = (y >= 0.5)    #  и понятности
col[below_points] = 0
col[upper_point] = 1

axes[3].scatter(x, y, c = col)
axes[3].set_facecolor('black')
axes[3].set_title('Два цвета для точек выше и ниже 0.5')
axes[3].set_xticks([])
axes[3].set_yticks([0.0, 0.5, 1.0])



fig.set_figwidth(12)     #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_013.PNG)

Точки можно отображать разными маркерами. <br>
Установить вид маркера можно, указав соответствующую строку в параметре marker. <br>
Толщина линии края маркера задается параметром linewidths, а цвет линии параметром edgecolors. 

Параметр alpha так же позволяет задавать прозрачность точек:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.random.rand(50)
y1 = np.random.rand(50)
y2 = np.random.rand(50)

fig, axes = plt.subplots(2, 2)


axes[0][0].scatter(x, y1,
                   marker = 's',
                   c = 'fuchsia')
axes[0][0].set_title('marker, c')

colors_1 = np.random.rand(50)
axes[0][1].scatter(x, y1,
                   marker = '*',
                   c = colors_1,
                   s = 700)
axes[0][1].set_title('marker, c, s')

size = 1000*np.random.rand(50)
axes[1][0].scatter(x, y2,
                   marker = 'o',
                   c = 'lightcoral',
                   s = size,
                   linewidths = 2,
                   edgecolors = 'darkred')
axes[1][0].set_title('marker, linewidths, edgecolors, c, s')

size = 1000*np.random.rand(50)
colors_2 = np.random.rand(50)
axes[1][1].scatter(x, y2,
                   marker = 'o',
                   c = colors_2,
                   s = size,
                   edgecolors = 'black',
                   alpha = 0.6)
axes[1][1].set_title('marker, linewidths, edgecolors, alpha, c, s')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()

```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_014.PNG)

[Содержание](#содержание)

<hr>

## Bar - гистограмма
Гистограммы устроены очень просто, но изменяя различные параметры мы можем отобразить с их помощью очень много информации, а так же повысить как наглядность данных так и привлекательность самого графика.

### Ширина прямоугольников

Чаще всего мы строим гистограммы из одиночных наборов данных, в таких случаях мы можем обойтись, вообще, без каких бы то ни было изменений графика. <br>
Просто строим одну или несколько гистограмм на одной области Figure:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 20, size = 7)

fig, ax = plt.subplots()

ax.bar(x, y)

ax.set_facecolor('seashell')
fig.set_facecolor('floralwhite')
fig.set_figwidth(12)    #  ширина Figure
fig.set_figheight(6)    #  высота Figure

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_015.PNG)

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x1 = np.arange(1, 8)
y1 = np.random.randint(1, 20, size = 7)
x2 = np.arange(1, 101)
y2 = np.random.randint(1, 20, size = 100)

fig, axes = plt.subplots(2, 1)

axes[0].bar(x1, y1)
axes[1].bar(x2, y2)

axes[0].set_facecolor('seashell')
axes[1].set_facecolor('seashell')
fig.set_facecolor('floralwhite')
fig.set_figwidth(12)    #  ширина Figure
fig.set_figheight(6)    #  высота Figure

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_016.PNG)

Ширина прямоугольников подбирается автоматически и нас это, вполне, устраивает. <br>
Но если мы имеем дело с несколькими наборами данных, которые нужно отобразить в пределах одной области Axes, то прямоугольники начинают перекрывать друг друга:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y1 = np.random.randint(1, 10, size = 7)
y2 = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

ax.bar(x, y1)
ax.bar(x, y2)

ax.set_facecolor('seashell')
fig.set_figwidth(12)    #  ширина Figure
fig.set_figheight(6)    #  высота Figure
fig.set_facecolor('floralwhite')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_017.PNG)

В таких случаях, нам необходимо вручную задавать ширину с помощью параметра width и смещение прямоугольников в массиве x:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

#  Задаем смещение равное половине ширины прямоугольника:
x1 = np.arange(1, 8) - 0.2
x2 = np.arange(1, 8) + 0.2
y1 = np.random.randint(1, 10, size = 7)
y2 = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

ax.bar(x1, y1, width = 0.4)
ax.bar(x2, y2, width = 0.4)

ax.set_facecolor('seashell')
fig.set_figwidth(12)    #  ширина Figure
fig.set_figheight(6)    #  высота Figure
fig.set_facecolor('floralwhite')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_018.PNG)

В некоторых ситуациях ширина прямоугольников, так же как и их высота, может быть пропорциональна некоторой величине. 

Что бы задать ширину каждого отдельного прямоугольника можно указать параметр width в виде массива чисел:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

width_rectangle = np.random.rand(7)
ax.bar(x, y, width = width_rectangle)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_019.PNG)

### Выравнивание нижнего края прямоугольников

Разместить несколько гистограмм на одной области Axes можно не только с помощью горизонтального смещения и изменения ширины прямоугольников, но и с помощью параметра bottom, который задает значение по которому выравнивается нижний край прямоугольников:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y1 = np.random.randint(1, 10, size = 7)
y2 = np.random.randint(1, 10, size = 7)
y3 = np.random.randint(1, 10, size = 7)


fig, ax = plt.subplots()

ax.bar(x, y1)
ax.bar(x, y2, bottom = 11)
ax.bar(x, y3, bottom = 21)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_020.PNG)

Выравнивание для каждого прямоугольника можно задать с помощью массива:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 51)
y = np.random.randint(1, 50, size = 50)

fig, ax = plt.subplots()

bottom_rectangle = np.random.randint(30, size = 50)
ax.bar(x, y, bottom = bottom_rectangle)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_021.PNG)

Для того что бы состыковать прямоугольники нескольких наборов данных, достаточно выровнять одни прямоугольники по значениям других:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
data_1 = np.random.randint(2, 15, size = 7)
data_2 = np.random.randint(3, 20, size = 7)



fig, ax = plt.subplots()

ax.bar(x, data_1)
ax.bar(x, data_2, bottom = data_1)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_022.PNG)

### Цвет
Для того что бы задать цвет всех прямоугольников достаточно указать его в параметре color:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)


fig, ax = plt.subplots()

ax.bar(x, y, color = 'red')


fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_023.PNG)

Так же возможно задать цвет каждого отдельного прямоугольника, указав в параметре color массив цветов:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

color_rectangle = np.random.rand(7, 3)    # RGB
ax.bar(x, y, color = color_rectangle)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_024.PNG)

Не забывайте, что matplotlib поддерживает разные цветовые модели и форматы. Задавая цвет в модели RGBA вы можете контролировать прозрачность прямоугольников, что так же позволяет размещать несколько наборов данных, но без смещения:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y1 = np.random.randint(1, 10, size = 7)
y2 = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

color_rectangle = np.random.rand(7, 3)    # RGB
ax.bar(x, y1, color = color_rectangle, width = 0.5)

color_rectangle = np.random.rand(7, 4)    # RGBA
color_rectangle[:,3] = 0.5
ax.bar(x, y2, color = color_rectangle)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_025.PNG)

Если вам необходимо выделить границу прямоугольников, то вы можете задать ее цвет (edgecolor) и толщину (linewidth):

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)

fig, ax = plt.subplots()

ax.bar(x, y,
       color = 'chartreuse',
       edgecolor = 'darkblue',
       linewidth = 5)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
ax.set_facecolor('darkslateblue')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_026.PNG)

### Отображение погрешности
На гистограммах можно указывать погрешность измерения величины, как по горизонтали (xerr) так и вертикали (xerr):

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)

fig, axes = plt.subplots(2, 1)

x_error = np.random.rand(7)
axes[0].bar(x, y,
            xerr = x_error,
            width = 0.3)

y_error = np.random.rand(7)*2
axes[1].bar(x, y,
            yerr = y_error,
            width = 0.5)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
axes[0].set_facecolor('seashell')
axes[1].set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_027.PNG)

Одно число задает одинаковую погрешность, массив чисел длинной x задает разную но симметричную погрешность для каждого прямоугольника, а массив чисел с формой (2, x) задает минимальное и максимальное значение погрешности для каждого прямоугольника:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 13)
y = np.random.randint(5, 20, size = 12)

fig, axes = plt.subplots(3, 1)

axes[0].bar(x, y, yerr = 1)

y_error = np.random.rand(12)*5
axes[1].bar(x, y,
            yerr = y_error)

y_error = np.random.rand(2,12)*10
y_error[:][0] /= 2 
axes[2].bar(x, y,
            yerr = y_error)

axes[0].set_title('Одинаковая погрешность')
axes[1].set_title('Разная, но симметричная погрешность')
axes[2].set_title('Максимальная и минимальная погрешность')
axes[0].set_xticks([])
axes[1].set_xticks([])
axes[0].set_facecolor('seashell')
axes[1].set_facecolor('seashell')
axes[2].set_facecolor('seashell')
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(9)    #  высота "Figure"
fig.set_facecolor('floralwhite')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_028.PNG)

Линии погрешности так же можно видоизменять:

```python
# Горизонтальная ошибка
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(1, 8)
y = np.random.randint(1, 10, size = 7)


fig, ax = plt.subplots()

y_error = np.random.randint(5, 20, size = (2, 7))/15
ax.bar(x, y, 
       yerr = y_error,      #  границы погрешностей
       ecolor = 'darkred',  #  цвет линии погрешности
       capsize = 10,        #  горизонтальная черточка
       edgecolor = 'red',   #  цвет края прямоугольника
       linewidth = 2,       #  ширина крайней линии
       color = 'seashell',  #  цвет прямоугольника
       linestyle = '--')    #  начертание линии


fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_029.PNG)

[Содержание](#содержание)

<hr>

## Fill - закрашенный многоугольник
Этот тип графика очень похож на график линии - с помощью двух массивов мы задаем координаты точек, затем концы линии соединяются отрезком и вся область внутри этой замкнутой линии закрашивается. Вот и все.

### Несколько примеров
Давайте сначала нарисуем график линии небольшого массива точек:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

x = [1, 3, 4, 5, 7]
y = [2, 4, 3, 4, 2]

fig, ax = plt.subplots()

ax.plot(x, y)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_030.PNG)

А теперь отобразим тот же набор точек с помощью метода fill:

```python
import numpy as np
import matplotlib.pyplot as plt

x = [1, 3, 4, 5, 7]
y = [2, 4, 3, 4, 2]


fig, ax = plt.subplots()

ax.fill(x, y)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_031.PNG)

Как видите - это действительно просто линия с соединенными концами и закрашенной внутренней областью. <br>
Методу fill можно передавать несколько наборов данных:

```python
import numpy as np
import matplotlib.pyplot as plt

t = np.linspace(0, 2*np.pi, 100)

x = np.sin(t)
y1 = np.cos(t)
y2 = np.cos(t)/2
y3 = np.cos(t)/4

fig, ax = plt.subplots()

ax.fill(x, y1, x + 2, y2, x + 4, y3)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(4)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_032.PNG)

Указанная линия может пересекать сама себя:

```python
import numpy as np
import matplotlib.pyplot as plt

t = np.linspace(0, 2*np.pi, 500)

fig, axes = plt.subplots(2, 2)

x = np.sin(4*t) - np.cos(t/2)
y = np.sin(t/2) - np.cos(2*t)
axes[0][0].fill(x, y, color = 'r',
                fill = False)
axes[0][1].fill(x, y, color = 'r')

x = np.sin(4*t) - np.cos(t/2)
y = np.sin(t/2) - np.cos(4*t)
axes[1][0].fill(x, y,
                color = 'r',
                fill = False)
axes[1][1].fill(x, y,
                color = 'r')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"
fig.set_facecolor('floralwhite')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_033.PNG)

[Содержание](#содержание)

<hr>

## Fill_between - закрашенная область между линиями
Этот тип графика очень похож на график fill с одним отличием - закрашивается область между двумя указанными линиями.

Несколько примеров
В простейшем случае, для создания графика, нужно передать методу fill три массива: x - массив с x координатами точек обеих линий и два массива y1, y2 с y координатами точек первой и второй линии:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

x = np.linspace(0, 10, 10)

y1 = 2*x
y2 = x
ax.fill_between(x, y1, y2)

y3 = 1.5*x + 10
y4 = 4*x + 10
ax.fill_between(x, y3, y4)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_034.PNG)

Указанные линии могут пересекать друг друга:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-10, 10, 100)
y1 = x**2
y2 = x**2 - 20*np.cos(x)

fig, ax = plt.subplots()

ax.fill_between(x, y1, y2)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_035.PNG)

Причем, если линии пересекаются, то с помощью параметра where можно указать выше или ниже какой линии должна закрашиваться область, а с помощью параметра facecolor можно задать ее цвет:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-12, 12, 200)
y1 = x**2
y2 = x**2 - 40*np.cos(x)

fig, ax = plt.subplots()

ax.plot(x, y1, color = 'r', linewidth = 3)
ax.plot(x, y2, color = 'b', linewidth = 3)

ax.fill_between(x, y1, y2,
                where= (y2 > y1),
                facecolor='yellow')
ax.fill_between(x, y1, y2,
                where= (y2 < y1),
                facecolor='black')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()

```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_036.PNG)

Можно управлять цветом и другими параметрами линии, а так же устанавливать прозрачность всей области:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 3*np.pi, 100)
y1 = np.cos(x)
y2 = np.sin(x)

fig, ax = plt.subplots()

ax.fill_between(x, y1, 2*y1 + 1,
                facecolor='r',
                alpha = 0.5,
                color = 'black',    #  цвет линий
                linewidth = 2,      #  ширина линий
                linestyle = '--')   #  начертание линий
ax.fill_between(x, y2, 3*y2,
                facecolor='g',
                alpha = 0.5,
                color = 'black',
                linewidth = 2,
                linestyle = '--')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_037.PNG)

[Содержание](#содержание)

<hr>

## Stackplot - надставленные области
Данный график очень похож на fill_between, но в отличии от него, он может создавать области между несколькими линиями и позволяет определить как эти области должны выравниваться относительно друг-друга.

### Несколько примеров
Чтобы построить график, методу stackplot необходимо всего два аргумента: массив с координатами x и массивы c y координатами линий. Вот только отсчет y координат каждой последующей линии ведется от y координат предыдущей линии:

```python
import numpy as np
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]

y1 = [2, 6, 4, 8, 2, 4]
y2 = [2, 4, 2, 4, 4, 10]

#  Фактические координаты y2 = [4, 10, 6, 12, 6, 14]

fig, ax = plt.subplots()

ax.stackplot(x, [y1, y2])

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_038.PNG)

Наличие в данных отрицательных значений может привести к двусмысленности:

```python
import numpy as np
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]

y1 = [2, 6, 4, 8, 2, 4]
y2 = [2, 4, 2, -1, 4, -2]

#  Фактические координаты y2 = [4, 10, 6, 7, 6, 2]

fig, ax = plt.subplots()

ax.stackplot(x, [y1, y2])

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_039.PNG)

В качестве второго аргумента может выступать массив из массивов y-координат:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(100)
y = np.random.rand(5, 100)*x**(2/3)+x

fig, ax = plt.subplots()

ax.stackplot(x, y)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_040.PNG)

### Выравнивание областей
Выровнять области можно несколькими способами, указав в аргументе baseline одну из следующих строк: 'zero', 'sym', 'wiggle', 'weighted_wiggle'. 

Если указать способ 'zero', то выравнивание следующей линии будет рассчитано относительно предыдущей (установлено по умолчанию):

```python
import numpy as np
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]

y1 = [2, 6, 4, 8, 2, 4]
y2 = [2, 4, 2, 4, 4, 10]

fig, ax = plt.subplots()

ax.stackplot(x, y1, y2, baseline = 'zero')

ax.set_title('zero baseline')
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_041.PNG)

Всю область можно выровнять так, что ее края будут симметричны относительно нулевой линии, для этого необходимо указать строку 'sym':

```python
import numpy as np
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]

y1 = [2, 6, 4, 8, 2, 4]
y2 = [2, 4, 2, 4, 4, 10]

fig, ax = plt.subplots()

ax.stackplot(x, y1, y2, baseline = 'sym')
ax.plot(np.zeros(6), color = 'black')

ax.set_title('sym baseline')
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_042.PNG)

Метод выравнивания 'wiggle' позволяет добиться минимального наклона краев области:

```python
import numpy as np
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]

y1 = [2, 6, 4, 8, 2, 4]
y2 = [2, 4, 2, 4, 4, 10]

fig, ax = plt.subplots()

ax.stackplot(x, y1, y2, baseline = 'wiggle')

ax.plot(np.zeros(6), color = 'black')

ax.set_title('wiggle baseline')
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_043.PNG)

Последний способ выравнивания - 'weighted_wiggle', так же как и метод расчета 'zero' выравнивает одну линию относительно предыдущей, но смещает саму область пропорционально ширине каждого полученного слоя:

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(15)

y1 = np.random.rand(15)
y2 = np.random.rand(15)

fig, ax = plt.subplots()

ax.stackplot(x, y1, y2,
             baseline = 'weighted_wiggle')
ax.plot(np.zeros(15), color = 'black')

ax.set_title('weighted_wiggle baseline')
fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_044.PNG)

Данный вид графиков очень похож на гистограммы, только в отличии от них, каждая величина пропорциональна не прямоугольнику а слою. А различные методы расчета смещения базовой линии позволяют в различной степени "почувствовать энергию" каждого слоя. 

Давайте создадим искусственные данные и посмотрим, как они могут выглядеть:

```python
import numpy as np
import matplotlib.pyplot as plt

def gaus_mix(n):
    a = np.zeros(n)
    x = np.random.randint(20, 60, size = 1)
    y = 0.01*np.random.randint(5, 95, size = 1)
    z = 0.3*x
    for i in range(n):
            w = (i / float(n) - y) * z
            a[i] += x * np.exp(-w * w)
    return a

x = np.arange(100)
y = []
for i in range(15):
    y.append(gaus_mix(100))

fig, axes = plt.subplots(4, 1)

axes[0].stackplot(x, y,
             baseline = 'zero')
axes[1].stackplot(x, y,
             baseline = 'sym')
axes[2].stackplot(x, y,
             baseline = 'wiggle')
axes[3].stackplot(x, y,
             baseline = 'weighted_wiggle')

axes[0].set_title('zero baseline')
axes[1].set_title('sym baseline')
axes[2].set_title('wiggle baseline')
axes[3].set_title('weighted_wiggle baseline')

#  Увеличим расстояние между областями Axes:
fig.subplots_adjust(hspace=0.5)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_045.PNG)

Так же, в отличии от гистограмм, данный вид графиков позволяет отлично визуализировать соотношение непрерывных величин на протяженном промежутке времени, например, объемы выпуска автомобилей различными компаниями за последние 40 лет.

[Содержание](#содержание)

<hr>

## Imshow - картинки
Как работать с изображениями? В последнее время это очень частый вопрос. Matplotlib позволяет не только отображать двумерные массивы, но и загружать их в виде массивов NumPy, что на самом деле очень удобно.

## Простейший случай
В самом простом случае, изображение можно представить в виде двумерного массива чисел:

```python
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

#  Двумерный массив пикселей:
smile = [[0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
         [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
         [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
         [1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
         [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
         [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]]

fig, ax = plt.subplots()

ax.imshow(smile)

fig.set_figwidth(6)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_046.PNG)

Как видите в этом действительно нет ничего сложного - количество строк и столбцов в массиве это высота и ширина изображения, а каждое число в массиве соответствует определенному цвету из встроенной палитры. Как правило, числа, должны находиться в интервале [0, 1]. 

Если вы указываете целые числа, то все они будут автоматически нормализованы и приведены к данному интервалу, в чем очень легко убедиться:

```python
import numpy as np
import matplotlib.pyplot as plt

data_int = np.arange(0, 256).reshape(16, 16)
data_float = np.linspace(0, 1, 256).reshape(16, 16)

fig, axes = plt.subplots(1, 2)

axes[0].imshow(data_int)
axes[0].set_title('Цвет указан целыми числами')

axes[1].imshow(data_float)
axes[1].set_title('Цвет указан вещественными числами')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_047.PNG)

Нередко, бывает очень полезным отобразить в виде изображения график некоторой трехмерной функции z = f(x, y), на котором каждому значению z соответствует определенный цвет:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[-5*np.pi:5*np.pi:1000j,
                -5*np.pi:5*np.pi:1000j]

z = np.sin(x) + np.cos(y)

fig, ax = plt.subplots()

ax.imshow(z)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_048.PNG)

### Файлы изображений
Как отображать сгенерированные данные мы разобрались, теперь давайте разберемся с тем как загружать файлы изображений.

Самый простой способ, загрузить файл изображения и отобразить его - воспользоваться функцией __get_sample_data()__ из модуля __cbook__.

Данная функция, в зависимости от того, в какой директории выполняется скрипт принимает либо имя файла (скрипт выполняется в той же папке что и файл) либо просто путь к файлу. 

После того, как мы создали объект файла его необходимо прочитать в массив NumPy с помощью функции imread модуля pyplot. Давайте проверим в действии:

```python
import numpy as np
import matplotlib.pyplot as plt

#  cbook - модуль "всяких полезностей":
import matplotlib.cbook as cbook

#  Конструкция "with ... as" гарантирует, что файл
#  будет закрыт после прочтения:
with cbook.get_sample_data('guido.jpg') as image_file:
    image = plt.imread(image_file)

fig, ax = plt.subplots()

ax.imshow(image)
ax.set_title(type(image))

fig.set_figwidth(7)    #  ширина и
fig.set_figheight(7)    #  высота "Figure"

plt.show()
```

Обратите внимание на заголовок графика, который мы отобразили командой __ax.set_title(type(image))__.

Строка
```python
<class 'numpy.ndarray'>
```
означает, что объект image - это массив NumPy, т.е. теперь мы можем манипулировать этим массивом как нам угодно. Но для начала давайте узнаем размеры массива:

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_049.PNG)

Из-за того что для обозначения цвета пикселя используется модель RGB наш массив не двумерный, а трехмерный: высота - 399 пикселей, ширина - 266 пикселей, и три числа для уровней красного, зеленого и голубого. 

В модели RGBA каждый пиксель будет задан четырьмя числами, где четвертое число - уровень прозрачности. Если каждый цвет пикселя задан в оттенках серого, то массив будет двумерным, так как для уровня серого достаточно одного числа.

Разобравшись с цветовой моделью картинки можем приступить к ее изменению:

```python
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cbook as cbook

with cbook.get_sample_data('/home/n1/guido.jpg') as image_file:
    image = plt.imread(image_file)

fig, axes = plt.subplots(1, 3)

#  Данные в image доступны только для чтения
image_1 = image.copy()
image_2 = image.copy()
image_3 = image.copy()

image_1[:, :, 0] = 0
axes[0].imshow(image_1)
axes[0].set_title('Red = 0')

image_2[:, :, 1] = 0
axes[1].imshow(image_2)
axes[1].set_title('Green = 0')

image_3[:, :, 2] = 0
axes[2].imshow(image_3)
axes[2].set_title('Blue = 0')

for ax in axes:
    ax.set_xticks([])
    ax.set_yticks([])

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```
[Содержание](#содержание)

<hr>

## Contour - линии уровней
Иногда приходится иметь дело с трехмерными поверхностями, т.е. результатом табулирования функции от двух переменных z = f(x, y). 

Сейчас, как правило, с восприятием таких графиков нет никаких проблем - есть много способов создать интерактивный трехмерный график, который можно вертеть и масштабировать как угодно. 

Но если мы говорим о статичной картинке, то с пониманием графика возникают некоторые трудности. Выход нашли еще до появления компьютеров, при издании технической литературы, который заключается в том что строят не трехмерный график а его отображение на плоскости. 

Это отображение получают по следующим правилам: берут заданное количество плоскостей параллельных плоскости xy и выделяют место пересечения поверхности с каждой из этих плоскостей - контуры, затем проецируют данные контуры на плоскость xy и все график готов.

### Несколько примеров
Давайте разберемся на примере какой нибудь реальной функции от двух переменных, скажем 

$z = np.sinc(x) + np.cos(y):$

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[-3*np.pi:3*np.pi:100j,
                -3*np.pi:3*np.pi:100j]
z = np.sinc(x) + np.cos(y)

fig, ax = plt.subplots()

ax.contour(z)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_050.PNG)

Количество контуров можно увеличить с помощью параметра levels:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[-3*np.pi:3*np.pi:300j,
                -3*np.pi:3*np.pi:300j]
z = np.sinc(x) + np.cos(y)

fig, ax = plt.subplots()

ax.contour(z, levels = 20)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_051.PNG)

### Цвет линий
Цвет линий определяется автоматически на основе, установленной по умолчанию, палитры. С помощью параметра colors мы можем задать один цвет для всех линий или, что очень важно для физиков и инженеров, цвет каждой линии. В случае, если необходимо определить цвет каждой линии, то параметру colors необходимо присвоить массив длинна которого соответствует количеству линий (levels) а каждый элемент определенному цвету. 

Давайте рассмотрим график напряженности электрического поля два электрических заряда:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[0:10:100j, 0:10:100j]

#  Вычисляем напряженность электрического
#  поля двух зарядов в каждой точке плоскости:
x_1, x_2, y_0 = 4, 6, 5
d = x_2 - x_1
r_1 = np.sqrt((x - x_1)**2 + (y - y_0)**2)
r_2 = np.sqrt((x - x_2)**2 + (y - y_0)**2)
a = (d**2 - r_1**2 - r_2**2)/(2*r_1*r_2)
E_1 = 1/(r_1**2)
E_2 = 1/(r_2**2)
E = 10*np.sqrt(E_1**2 + E_2**2 + 2*E_1*E_2*np.cos(a))

fig, axes = plt.subplots(1, 2)

#  Задаем значение каждого уровня:
lev = [1, 2, 3, 4, 6, 10, 20, 40, 100, 900]

#  Контуры одного цвета:
axes[0].contour(x, y, E, levels = lev,
           colors = 'r')
axes[0].set_title('Линии одного цвета')

#  Создаем массив RGB цветов каждого уровня:
color_line = np.zeros((10, 3))
color_line[:, 1:] = 0.1
color_line[:, 0] = np.linspace(0, 1, 10)

#  Контуры разного цвета:
axes[1].contour(x, y, E, levels = lev,
           colors = color_line)
axes[1].set_title('Линии разного цвета')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_052.PNG)

### Contourf - область между контурами
Если области между контурами будут заполнены разными цветами то мы добьемся того же самого результата. Метод contourf выделяет контуры не линиями, а цветом областей между ними:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[-3*np.pi:3*np.pi:300j,
                -3*np.pi:3*np.pi:300j]
z = np.sinc(x) + np.cos(y)

fig, axes = plt.subplots(1, 2)

axes[0].contour(z)
axes[0].set_title('contour')

axes[1].contourf(z)
axes[1].set_title('contourf')

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_053.PNG)

Так же как и с contour мы можем задавать количество уровней и их цвет с помощью параметров levels и colors:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[0:10:100j, 0:10:100j]

x_1, x_2, y_0 = 4, 6, 5
d = x_2 - x_1
r_1 = np.sqrt((x - x_1)**2 + (y - y_0)**2)
r_2 = np.sqrt((x - x_2)**2 + (y - y_0)**2)
a = (d**2 - r_1**2 - r_2**2)/(2*r_1*r_2)
E_1 = 1/(r_1**2)
E_2 = 1/(r_2**2)
E = 10*np.sqrt(E_1**2 + E_2**2 + 2*E_1*E_2*np.cos(a))

fig, ax = plt.subplots()

#  Задаем значение каждого уровня:
lev = [0, 1, 2, 3, 4, 6, 10, 20, 40, 100, 900, 10000]

#  Создаем массив RGB цветов каждой области:
color_region = np.zeros((12, 3))
color_region[:, 1:] = 0.2
color_region[:, 0] = np.linspace(0, 1, 12)

ax.contourf(x, y, E,
            levels = lev,
            colors = color_region)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_054.PNG)

### clabel - метки контуров
Каждому контуру соответствует определенное значение величины. Отобразить это значение в виде меток можно с помощью метода clabel. 

В самом простом случае, данный метод принимает всего один аргумент - объект ContourSet, возвращаемый методом contour:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[0:3*np.pi:100j,
                0:3*np.pi:100j]
z = np.sin(x) + np.cos(y)

fig, ax = plt.subplots()

cs = ax.contour(z)

ax.clabel(cs)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_055.PNG)

Однако, если тоже самое попробовать сделать с областями между контурами (contourf), то ничего не получится. 

Точнее получится, но будет выглядеть вот так:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[0:3*np.pi:100j,
                0:3*np.pi:100j]
z = np.sin(x) + np.cos(y)

fig, ax = plt.subplots()

cs = ax.contourf(z)

ax.clabel(cs)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_056.PNG)

В данном случае необходимо построить contourf и contour на одной области Axes, а уже потом строить clabel с объектом ContourSet, который вернет contour:

```python
import numpy as np
import matplotlib.pyplot as plt


x, y = np.mgrid[0:10:100j, 0:10:100j]

x_1, x_2, y_0 = 4, 6, 5
d = x_2 - x_1
r_1 = np.sqrt((x - x_1)**2 + (y - y_0)**2)
r_2 = np.sqrt((x - x_2)**2 + (y - y_0)**2)
a = (d**2 - r_1**2 - r_2**2)/(2*r_1*r_2)
E_1 = 1/(r_1**2)
E_2 = 1/(r_2**2)
E = 10*np.sqrt(E_1**2 + E_2**2 + 2*E_1*E_2*np.cos(a))

fig, ax = plt.subplots()

###  Строим contourf  ###
#  Задаем количество областей:
lev_region = [0, 1, 2, 3, 4, 6, 10, 20, 40, 100, 900, 10000]
#  Задаем цвет каждой области:
color_fill = np.zeros((12, 3))
color_fill[:, 1:] = 0.1
color_fill[:, 0] = np.linspace(0, 1, 12)

ax.contourf(x, y, E,
            levels = lev_region,
            colors = color_fill)

###  Строим contour  ###
#  Задаем количество линий:
lev_line = [1, 2, 3, 6, 20, 100]
#  Задаем цвет линий:
color_line = np.zeros((6, 3))
color_line[:, 1:] = 0.8
color_line[:, 0] = np.linspace(1, 0, 6)

CS = ax.contour(x, y, E,
                levels = lev_line,
                colors = color_line)

ax.clabel(CS)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_057.PNG)

Обратите внимание на то, что количество областей и линий в contourf и contour не совпадает - это позволяет определять какие уровни помечать меткой а какие нет.

[Содержание](#содержание)

<hr>

## Pcolormesh - псевдоцветная сетка
Мы уже видели, что с помощью метода imshow можно отображать двумерные массивы в виде изображений. Однако, иногда возникает необходимость не отображать определенные ячейки (пиксели) или сделать так что бы ячейки были разного размера. Так же иногда необходимо отображать саму границу между ячейками. Для таких нужд нам и пригодится метод pcolormesh.

### Несколько примеров
В самом простом случае метод pcolormesh принимает всего один аргумент - двумерный массив чисел:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[ 0, 1, 2, 3],
     [ 4, 5, 6, 7],
     [ 8, 9, 10, 11],
     [12, 13, 14, 15]]

fig, ax = plt.subplots()

ax.pcolormesh(c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_058.PNG)

Мы можем легко задавать размеры ячеек. Как это работает легче всего разобрать на графике с небольшим количеством ячеек:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2],
     [2, 8, 0],
     [1, 0, 12]]

x = [0, 2, 4, 7]
y = [3, 4, 6, 9]

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()

```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_059.PNG)

В этом примере мы указали еще два параметра - массив x и массив y, которые на 1 больше длинны и ширины массива c.

Эти массивы и задают ширину столбцов и высоту строк сетки и благодаря им можем записать координаты углов каждой ячейки, например, координаты самой левой нижней ячейки запишутся как:

```python
          (0, 4)           (2, 4)
                +---------+
                | c[2][0] |
                +---------+
          (0, 3)           (2, 3)
```

Или в общем случае для каждой ячейки:

```python
(x[i+1, j], y[i+1, j])          (x[i+1, j+1], y[i+1, j+1])
                      +--------+
                      | c[i,j] |
                      +--------+
    (x[i, j], y[i, j])          (x[i, j+1], y[i, j+1])
```

Массивы x и y могут и совпадать с длинной и шириной массива c, но в этом случае последний столбец и последняя строка массива c будут игнорироваться:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2, 1],
     [2, 8, 0, 2],
     [1, 0, 12, 1]]

#  Длинна x и y совпадает с длиной
#  и шириной c:
x = [0, 2, 4, 7]
y = [3, 4, 6]

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_060.PNG)

Более того, ячейки даже не обязаны быть прямоугольными:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2, 1],
     [2, 8, 0, 2],
     [1, 0, 12, 1]]

x = [[4, 6, 8, 10, 12],
     [3, 5, 8, 11, 13],
     [2, 4, 8, 12, 14],
     [0, 6, 8, 10, 9]]

y = [0, 1, 2, 3]

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_061.PNG)

И еще один пример, в котором ячейки имеют неправильную форму:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2, 1],
     [2, 8, 0, 2],
     [1, 0, 12, 1]]

x = [[4, 6, 8, 10, 12],
     [3, 5, 8, 11, 13],
     [2, 4, 8, 12, 14],
     [3, 6, 8, 10, 13]]

y = [[0,-0.5,-1,-0.5,0],
     [0.5,1,1,1,0.5],
     [1.5,2,2,2,1.5],
     [2.5,3,2.5,3,2.5]]

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_062.PNG)

Как видите, форму каждой ячейки мы задали сначала одним двумерным массивом x, а во втором случае с помощью двумерных массивов x и y. В первом примере видно, что ячейки могут даже перекрывать друг друга, т.е. фактически, единственное за чем нужно следить, так это за совместимостью размеров массивов x и y. 

Если их размеры совместимы, то само содержание массивов может быть каким угодно даже случайным:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2, 1],
     [2, 8, 0, 2],
     [1, 0, 12, 1]]

x = np.random.randint(0, 10, size = (4, 5))
y = np.random.randint(0, 10, size = (4, 5))

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_063.PNG)

### Прозрачность
В случае неравномерной сетки ячейки действительно могут перекрывать друг друга, в этом легко убедиться, если добавить параметр alpha, который задает прозрачность ячеек и может принимать значение из интервала [0, 1]:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[5, 1, 2, 1],
     [2, 8, 0, 2],
     [1, 0, 12, 1]]

x = np.random.randint(1, 20, size = (4, 5))

y = np.random.randint(1, 3, size = (4, 5))

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c, alpha = 0.3)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_064.PNG)

### Линии сетки
Задать цвет линий сетки а так же их параметры можно с помощью множества параметров. Цвет задается параметром edgecolors, а их ширину с помощью параметра linewidth:

```python
import numpy as np
import matplotlib.pyplot as plt

c = [[0, 1, 2, 3],
     [1, 2, 3, 4],
     [2, 3, 4, 5]]

x = [[4, 6, 8, 10, 12],
     [3, 5, 8, 11, 13],
     [2, 4, 8, 12, 14],
     [3, 6, 8, 10, 13]]

y = [[0,-0.5,-1,-0.5,0],
     [0.5,1,1,1,0.5],
     [1.5,2,2,2,1.5],
     [2.5,3,2.5,3,2.5]]

fig, ax = plt.subplots()

ax.pcolormesh(x, y, c,
              cmap = 'spring',
              edgecolors = 'r',
              linewidth = 3)

fig.set_figwidth(10)    #  ширина и
fig.set_figheight(10)    #  высота "Figure"
fig.set_facecolor('floralwhite')
ax.set_facecolor('seashell')

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_065.PNG)

[Содержание](#содержание)

<hr>

## Arrow - стрелка
Если необходимо сфокусировать внимание на определенном участке графика - то это проще всего сделать с помощью стрелок:

```python
import numpy as np
import matplotlib.pyplot as plt


x = np.linspace(-5, 5, 100)
y = x*(x - 4)*(x + 4)



fig, ax = plt.subplots()

ax.plot(x, y)
ax.arrow(-2.3, 0, 0, 20,
         width = 0.1,
         head_length = 4)
ax.arrow(2.3, 0, 0, -20,
         width = 0.1,
         head_length = 4)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(6)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_066.PNG)

### Параметры отображения
В самом простом случае стрелка задается всего четырьмя параметрами:

+ x, y - координаты начала стрелки;
+ dx, dy - длина стрелки по оси x и y.

Но при этом сама стрелка не совсем похожа на стрелку:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0.1, 0.3, 0.7, 0.3)

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_067.PNG)

Более того, даже если нас устраивает такой вид стрелки, она будет рисоваться только в области Axes ограниченной нулем и единицей:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0.1, 0.3, 1.3, 1.7)

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_068.PNG)

Такое поведение стрелки меняется если диапазон значений x и y задан другим методом Axes или если он изменен вручную. Ну а придать стрелке "нормальный" вид можно, указав в параметре width какое-нибудь значение (желательно, небольшое так как по умолчанию width = 0.001):

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0.1, 0.3, 1.3, 1.7,
         width = 0.05)    #  ширина стрелки

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_069.PNG)

### Параметры отображения
Рано или поздно вы заметите, что длина стрелки не включает в себя длину острия. Изменить такое поведение можно с помощью параметра length_includes_head установленным в True:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0, 1, 2, 0,
         width = 0.05)

#  Длина стрелки будет включать в себя
#  длину острия:
ax.arrow(0, 2, 2, 0,
         length_includes_head = True,
         width = 0.05)

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_070.PNG)

Ширина острия стрелки по умолчанию равно трем значениям ширины ее основной линии. С помощью параметра head_width можно установить произвольное значение ширины острия:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0, 1, 1.3, 0,
         width = 0.05)

#  head_width - ширина острия стрелки:
ax.arrow(0, 1.5, 1.5, 0,
         head_width = 0.3,
         width = 0.05)
ax.arrow(0, 2, 2, 0,
         head_width = 0.6,
         width = 0.05)

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_071.PNG)

Параметр head_length позволяет задать длину острия стрелки (по умолчанию длина острия равна 3/2 от ширины острия):

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

#  head_length - длина острия стрелки:
ax.arrow(0, 1, 1.3, 0,
         head_length = 0.1,
         width = 0.05)
ax.arrow(0, 1.5, 1.5, 0,
         head_length = 0.5,
         width = 0.05)
ax.arrow(0, 2, 2, 0,
         head_length = 1,
         width = 0.05)

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_072.PNG)

С помощью параметра shape мы можем выбирать: рисовать ли стрелку полностью или только какую-то ее половину:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

#  shape - форма стрелки:
ax.arrow(0, 0.5, 2, 0,
         shape = 'full',    #  по умолчанию
         width = 0.1)
ax.arrow(0, 1, 2, 0,
         shape = 'left',
         width = 0.1)
ax.arrow(0, 1.5, 2, 0,
         shape = 'right',
         width = 0.1)

#  color - задает цвет стрелки:
ax.arrow(0, 2.5, 2, 0,
         shape = 'left',
         color = 'r',
         width = 0.1)
ax.arrow(0, 2.5, 2, 0,
         shape = 'right',
         color = 'g',
         width = 0.1)

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_073.PNG)

Выровнять основание острия можно с помощью параметра overhang:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0.1, 0.5, 2, 0,
         width = 0.1)

#  overhang - выравнивание края
#  стрелки:
ax.arrow(0.1, 1, 2, 0,
         overhang = 0.2,
         width = 0.1)
ax.arrow(0.1, 1.5, 2, 0,
         overhang = 0,
         width = 0.1)
ax.arrow(0.1, 2, 2, 0,
         overhang = -0.2,
         width = 0.1)

#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 2.5])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_074.PNG)

### Цвет стрелки и ее края
В одном из примеров мы уже устанавливали цвет стрелки с помощью параметра color, но он переопределяет цвет края стрелки. Поэтому, в этом случае мы должны указать цвет стрелки с помощью параметра facecolor:

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

ax.arrow(0.2, 1.5, 2.5, 0,
         facecolor = 'red',    #  цвет стрелки
         edgecolor = 'black',  #  цвет края
         linewidth = 3,        #  ширина линии края
         linestyle = '--',     #  начертание линии
         width = 0.6,
         head_length = 0.9,
         length_includes_head = True)



#  Установим диапазон значений:
ax.set_xticks([0, 1, 2, 3])
ax.set_yticks([0, 1, 2, 3])

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_075.PNG)

[Содержание](#содержание)

<hr>

## Quiver - поле векторов
Стрелки очень удобны тем, что позволяет изображать функцию от двух переменных z = f(x, y) в виде плоскости с множеством векторов, каждый из которых указывает значение и направление некоторой величины.

### Несколько примеров
В самом простом случае, метод quiver принимает всего два аргумента - значениями которых являются два двумерных массива одинакового размера:

+ U - массив длин стрелок по оси x;
+ V - массив длин стрелок по оси y.

Посмотрите на три следующих примера и вы сразу поймете как строятся стрелки:

```python
import matplotlib.pyplot as plt

U = [[1, 1, 1, 1], [-2, -2, -2, -2],
     [3, 3, 3, 3], [-3, -3, -3, -3]]

V = [[0, 0, 0, 0], [0, 0, 0, 0],
     [0, 0, 0, 0], [0, 0, 0, 0]]

fig, ax = plt.subplots()

ax.quiver(U, V)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_076.PNG)

```python
import matplotlib.pyplot as plt

U = [[0, 0, 0, 0], [0, 0, 0, 0],
     [0, 0, 0, 0], [0, 0, 0, 0]]

V = [[1, 1, 1, 1], [-2, -2, -2, -2],
     [3, 3, 3, 3], [-3, -3, -3, -3]]

fig, ax = plt.subplots()

ax.quiver(U, V)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_077.PNG)

```python
import matplotlib.pyplot as plt

U = [[1, 1, 1, 1],
     [0, 2, 2, 2],
     [0, 0, 3, 3],
     [0, 0, 0, 4]]

V = [[1, 0, 0, 0],
     [1, 2, 0, 0],
     [1, 2, 3, 0],
     [1, 2, 3, 4]]

fig, ax = plt.subplots()

ax.quiver(U, V)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"
ax.set_xticks(np.arange(4.5))
ax.set_yticks(np.arange(4.5))

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_078.PNG)

### Координаты стрелок
На предыдущих примерах видно, что каждая стрелка начинается в узлах целочисленной регулярной решетки, которую matplotlib создает автоматически. Но мы можем и сами управлять положением каждой стрелки с помощью параметров X и Y. Как нетрудно догадаться, это два двумерных массива с x и y координатами начала стрелок. 

Причем размеры X и Y совпадают с размерами U и V, т.е. размеры X, Y, U и V должны совпадать:

```python
import matplotlib.pyplot as plt

X = [0, 0, 1, 1, 2, 2]
Y = [0, 0, 1, 1, 0, 0]

U = [2, 4, -2, 2, -4, -2]
V = [3, 0, -3, -3, 0, 3]

fig, ax = plt.subplots()

ax.quiver(X, Y, U, V)

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_079.PNG)

В этом примере мы использовали одномерные массивы, но это только для наглядности. 

Учитывая, что мы работаем с двумерной сеткой, лучше (хотя вовсе не обязательно) использовать двумерные массивы:

```python
import numpy as np
import matplotlib.pyplot as plt


X, Y = np.mgrid[-2*np.pi:2*np.pi:20j,
                -2*np.pi:2*np.pi:20j]

U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

fig, ax = plt.subplots()

ax.quiver(X, Y, U, V)

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_080.PNG)

### Цвет стрелок
Параметр C позволяет с помощью массива определить цвет каждой стрелки:

```python
import matplotlib.pyplot as plt

X = [0, 0, 1, 1, 2, 2]
Y = [0, 0, 1, 1, 0, 0]

U = [2, 4, -2, 2, -4, -2]
V = [3, 0, -3, -3, 0, 3]

C = [0, 2, 0, 1, 2, 1]

fig, ax = plt.subplots()

ax.quiver(X, Y, U, V, C)

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_081.PNG)

Стрелки могут быть как одноцветными так и разноцветными, причем цвет стрелок так же как их длина и направление может отражать некоторую закономерность:

```python
import numpy as np
import matplotlib.pyplot as plt


X, Y = np.mgrid[-2*np.pi:2*np.pi:20j,
                -2*np.pi:2*np.pi:20j]

U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

fig, axes = plt.subplots(1, 2)

C = np.full_like(X, 5)
axes[0].quiver(X, Y, U, V, C)
axes[0].set_title('Стрелки одного цвета')

C = U + V
axes[1].quiver(X, Y, U, V, C)
axes[1].set_title('Цвет задан функцией: C = U + V')


fig.set_figwidth(16)    #  ширина и
fig.set_figheight(7)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_082.PNG)

Однако, параметр C не позволяет задавать цвет строк с помощью строк или управлять прозрачностью стрелок. Поэтому, если параметр C не дает нужного результата то можно вместо него указать параметр color:

```python
import numpy as np
import matplotlib.pyplot as plt

X, Y = np.mgrid[-2*np.pi:2*np.pi:20j,
                -2*np.pi:2*np.pi:20j]

U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

fig, ax = plt.subplots()

ax.quiver(X, Y, U, V, 
          color = 'r')

X, Y = np.mgrid[-2*np.pi:2*np.pi:40j,
                -2*np.pi:2*np.pi:40j]

U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

ax.quiver(X, Y, U + 1, V + 1, 
          color = '#dd113360')    #  RGBA

fig.set_figwidth(12)    #  ширина и
fig.set_figheight(12)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_083.PNG)

[Содержание](#содержание)

<hr>

## Streamplot - поток векторов
Говоря о векторном пространстве, можно ввести такое понятие как векторный поток - там где векторы длиннее там и сильнее их поток. Если векторы мы изображаем прямыми стрелками, то поток изображается стрелками, которые могут иметь самую разную кривизну, в зависимости от неоднородности векторного пространства. 

Взгляните на этот график и вы легко догадаетесь как связано векторное пространство и его векторный поток:

```python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

Y, X = np.mgrid[-2*np.pi:2*np.pi:20j,
                -2*np.pi:2*np.pi:20j]
U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

#  Строим поток векторов:
ax.streamplot(X, Y, U, V, 
              color = 'b')

X, Y = np.mgrid[-2*np.pi:2*np.pi:25j,
                -2*np.pi:2*np.pi:25j]
U = np.sin(X) + np.cos(Y)
V = np.cos(X) + np.cos(Y)

#  Поверх потока строим векторное поле:
ax.quiver(X, Y, U, V, 
          color = '#2011af60')    #  RGBA

fig.set_figwidth(14)    #  ширина и
fig.set_figheight(14)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_084.PNG)

### Простой пример
Метод streamplot всегда принимает четыре обязательных параметра:

+ X, y - одномерные координатные массивы.
+ U, V - массивы длин векторов (под которыми сейчас понимаются векторы скоростей потоков). Количество строк в этих массивах должно соответствовать длине Y, а количество столбцов длине X;

И еще один важный момент - все массивы должны быть массивами NumPy:

```python
import numpy as np
import matplotlib.pyplot as plt

#  X = np.arange(7)
X = np.array([0, 1, 2, 3, 4, 5, 6])

#  Y = np.arange(7)
Y = np.array([0, 1, 2, 3, 4, 5, 6])

#  U = np.repeat([4,3,2,1,2,3,4], 7).reshape(7, 7)
U = np.array([[4, 4, 4, 4, 4, 4, 4],
              [3, 3, 3, 3, 3, 3, 3],
              [2, 2, 2, 2, 2, 2, 2],
              [1, 1, 1, 1, 1, 1, 1],
              [2, 2, 2, 2, 2, 2, 2],
              [3, 3, 3, 3, 3, 3, 3],
              [4, 4, 4, 4, 4, 4, 4]])

#  V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)
V = np.array([[1, 1, 1, 1, 1, 1, 1],
              [2, 2, 2, 2, 2, 2, 2],
              [3, 3, 3, 3, 3, 3, 3],
              [4, 4, 4, 4, 4, 4, 4],
              [3, 3, 3, 3, 3, 3, 3],
              [2, 2, 2, 2, 2, 2, 2],
              [1, 1, 1, 1, 1, 1, 1]])

fig, ax = plt.subplots()

ax.streamplot(X, Y, U, V)

fig.set_figwidth(8)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_085.PNG)

### Цвет линий
Цвет линий задается с помощью параметра color или cmap:

```python
import numpy as np
import matplotlib.pyplot as plt

X = np.arange(7)
Y = np.arange(7)

U = np.repeat([4,3,2,-4,2,3,4], 7).reshape(7, 7)
V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)

fig, axes = plt.subplots(2, 2)

axes[0][0].streamplot(X, Y, U, V,
                      color = 'r')
axes[0][0].set_title('Один цвет')

axes[0][1].streamplot(X, Y, U + 1, V,
                      color = '#9a3030ad')
axes[0][1].streamplot(X, Y, U, V,
                      color = '#309a30ad')
axes[0][1].set_title('RGBA')

axes[1][0].streamplot(X, Y, U, V,
                      color = U + V)
axes[1][0].set_title('Цвет задан массивом U + V')

axes[1][1].streamplot(X, Y, U, V,
                      color = U + V,
                      cmap = 'winter')
axes[1][1].set_title('Массив цветов и цветовая карта "winter"')

fig.set_figwidth(16)    #  ширина и
fig.set_figheight(16)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_086.PNG)

Параметр cmap указывается вместо color только в случае если цвет задан массивом.

### Плотность линий
Плотность линий задается параметром density:

```python
import numpy as np
import matplotlib.pyplot as plt

X = np.arange(7)
Y = np.arange(7)

U = np.repeat([4,3,2,-4,2,3,4], 7).reshape(7, 7)
V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)

fig, axes = plt.subplots(1, 2)

axes[0].streamplot(X, Y, U, V,
              density = 1)
axes[0].set_title('density = 1 (по умолчанию)')

axes[1].streamplot(X, Y, U, V,
              density = 3)
axes[1].set_title('density = 3')

fig.set_figwidth(16)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()

```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_087.PNG)

### Толщина линий
Толщина линий задается параметром linewidth:

```python
import numpy as np
import matplotlib.pyplot as plt

X = np.arange(7)
Y = np.arange(7)

U = np.repeat([4,3,2,-4,2,3,4], 7).reshape(7, 7)
V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)

fig, axes = plt.subplots(1, 2)

axes[0].streamplot(X, Y, U, V,
              linewidth = 3)
axes[0].set_title('linewidth = 3')

axes[1].streamplot(X, Y, U, V,
              linewidth =  4 - U/V )
axes[1].set_title('linewidth = 4 - U/V')

fig.set_figwidth(16)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_088.PNG)

### Величина стрелок
Иногда стрелки могут оказаться слишком маленькими, а их начертание неподходящим. Изменить их размер позволяет параметр arrowsize, а начертание arrowstyle:

```python
import numpy as np
import matplotlib.pyplot as plt

X = np.arange(7)
Y = np.arange(7)

U = np.repeat([4,3,2,-4,2,3,4], 7).reshape(7, 7)
V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)

fig, axes = plt.subplots(1, 2)

axes[0].streamplot(X, Y, U, V,
                   linewidth = 2,
                   arrowsize = 2,
                   arrowstyle = '->')
axes[0].set_title('arrowsize = 2, arrowstyle = "->"')

axes[1].streamplot(X, Y, U, V,
                   linewidth = 1,
                   arrowsize = 1,
                   arrowstyle = '-[')
axes[1].set_title('arrowsize = 1, arrowstyle = "-["')

fig.set_figwidth(16)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_089.PNG)

### Длина линий
Задать максимальную и минимальную длину линий можно с помощью параметров minlength и maxlength:

```python
import numpy as np
import matplotlib.pyplot as plt

X = np.arange(7)
Y = np.arange(7)

U = np.repeat([4,3,2,-4,2,3,4], 7).reshape(7, 7)
V = np.repeat([1,2,3,4,3,2,1], 7).reshape(7, 7)

fig, axes = plt.subplots(1, 2)

axes[0].streamplot(X, Y, U, V,
                   minlength = 0.1,
                   maxlength = 0.2)
axes[0].set_title('minlength = 0.1,  maxlength = 0.2')

axes[1].streamplot(X, Y, U, V,
                   minlength = 0.8,
                   maxlength = 1.2)
axes[1].set_title('minlength = 0.8,  maxlength = 1.2')

fig.set_figwidth(16)    #  ширина и
fig.set_figheight(8)    #  высота "Figure"

plt.show()
```

![Основные компоненты matplotlib](/Articles/_Matplotlib/Pictures/005_090.PNG)

[Содержание](#содержание)

<hr>

[Содержание руководства по Matplotlib](/Articles/_Matplotlib/README.MD)
