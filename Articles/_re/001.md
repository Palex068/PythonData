# Регулярные выражения в Python от простого к сложному.
## Подробности, примеры, картинки, упражнения

![re](/Articles/_re/pictures/001_001.jpeg)

Решил я давеча моим школьникам дать задачек на регулярные выражения для изучения. А к задачкам нужна какая-нибудь теория. И стал я искать хорошие тексты на русском. Пяток сносных нашёл, но всё не то. Что-то смято, что-то упущено. У этих текстов был не только фатальный недостаток. Мало картинок, мало примеров. И почти нет разумных задач. Ну неужели поиск IP-адреса — это самая частая задача для регулярных выражений? Вот и я думаю, что нет.
Про разницу (?:...) / (...) фиг найдёшь, а без этого знания в некоторых случаях можно только страдать.

Плюс в питоне есть немало регулярных плюшек. Например, re.split может добавлять тот кусок текста, по которому был разрез, в список частей. А в re.sub можно вместо шаблона для замены передать функцию. Это — реальные вещи, которые прямо очень нужны, но никто про это не пишет.
Так и родился этот достаточно многобуквенный материал с подробностями, тонкостями, картинками и задачами.

Надеюсь, вам удастся из него извлечь что-нибудь новое и полезное, даже если вы уже в ладах с регулярками.
PS. Решения задач школьники сдают в тестирующую систему, поэтому задачи оформлены в несколько формальном виде.

# Содержание
+ Регулярные выражения в Python от простого к сложному;
+ Содержание;
    + Примеры регулярных выражений;
    + Сила и ответственность;
+ Документация и ссылки;
+ Основы синтаксиса;
    + Шаблоны, соответствующие одному символу;
    + Квантификаторы (указание количества повторений);
    + Жадность в регулярках и границы найденного шаблона;
    + Пересечение подстрок;
+ Эксперименты в песочнице;
+ Регулярки в питоне;
+ Пример использования всех основных функций;
    + Тонкости экранирования в питоне ('\\\\\\\\foo');
    + Использование дополнительных флагов в питоне;
+ Написание и тестирование регулярных выражений;
+ Задачи — 1;
+ Скобочные группы (?:...) и перечисления |;
    + Перечисления (операция «ИЛИ»);
    + Скобочные группы (группировка плюс квантификаторы);
    + Скобки плюс перечисления;
    + Ещё примеры;
+ Задачи — 2;
+ Группирующие скобки (...) и match-объекты в питоне;
    + Match-объекты;
    + Группирующие скобки (...);
    + Тонкости со скобками и нумерацией групп.;
    + Группы и re.findall;
    + Группы и re.split;
+ Использование групп при заменах;
    + Замена с обработкой шаблона функцией в питоне;
    + Ссылки на группы при поиске;
+ Задачи — 3;
+ Шаблоны, соответствующие не конкретному тексту, а позиции;
    + Простые шаблоны, соответствующие позиции;
    + Сложные шаблоны, соответствующие позиции (lookaround и + Co);
    + lookaround на примере королей и императоров Франции;
+ Задачи — 4;
+ Post scriptum;

_Регулярное выражение_ — это строка, задающая шаблон поиска подстрок в тексте. 

Одному шаблону может соответствовать много разных строчек. 

Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». 

Перевод не очень точно отражает смысл, правильнее было бы «шаблонные выражения». 

Регулярное выражение, или коротко «регулярка», состоит из обычных символов и специальных командных последовательностей. 

Например:
+ \d задаёт любую цифру, а 
+ \d+ — задает любую последовательность из одной или более цифр. 

Работа с регулярками реализована во всех современных языках программирования. 

Однако существует несколько «диалектов», поэтому функционал регулярных выражений может различаться от языка к языку. 

В некоторых языках программирования регулярками пользоваться очень удобно (например, в питоне), в некоторых — не слишком (например, в C++).

## Примеры регулярных выражений
###
    Регулярка	                    Её смысл
    simple text	            В точности текст «simple text»
    \d{5}	                Последовательности из 5 цифр
                            \d означает любую цифру
                            {5} — ровно 5 раз
    
    \d\d/\d\d/\d{4}	        Даты в формате ДД/ММ/ГГГГ 
                            (и прочие куски, на них похожие,
                            например, 98/76/5432)
    
    \b\w{3}\b	            Слова в точности из трёх букв
                            \b означает границу слова
                            (с одной стороны буква, а с другой — нет)
                            \w — любая буква,
                            {3} — ровно три раза
    
    [-+]?\d+	            Целое число, например, 7, +17, -42, 0013
                            (возможны ведущие нули)
                            [-+]? — либо -, либо +, либо пусто
                            \d+ — последовательность из 1 или более цифр
    
    [-+]?(?:\d+(?:\.\d*     Действительное число, возможно в
    )?|\.\d+)(?:[eE][-+     экспоненциальной записи
    ]?\d+)?	                Например, 0.2, +5.45, -.4, 6e23, -3.17E-14.
                            См. ниже картинку.

![Пример](/Articles/_re/pictures/001_002.png)

# Сила и ответственность

Регулярные выражения, или коротко, регулярки — это очень мощный инструмент. 

Но использовать их следует с умом и осторожностью, и только там, где они действительно приносят пользу, а не вред. 

+ Во-первых, плохо написанные регулярные выражения работают медленно. 
+ Во-вторых, их зачастую очень сложно читать, особенно если регулярка написана не лично тобой пять минут назад. 
+ В-третьих, очень часто даже небольшое изменение задачи (того, что требуется найти) приводит к значительному изменению выражения. 

    Поэтому про регулярки часто говорят, что это write only code (код, который только пишут с нуля, но не читают и не правят). 
    
    А также шутят: Некоторые люди, когда сталкиваются с проблемой, думают «Я знаю, я решу её с помощью регулярных выражений.» 
    
    Теперь у них две проблемы. 

Вот пример write-only регулярки (для проверки валидности e-mail адреса (не надо так делать!!!)):

    (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|
    2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])

А вот здесь 

http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html

более точная регулярка для проверки корректности email адреса стандарту RFC822. Если вдруг будете проверять email, то не делайте так!

Если адрес вводит пользователь, то пусть вводит почти что угодно, лишь бы там была собака. Надёжнее всего отправить туда письмо и убедиться, что пользователь может его получить.

# Документация и ссылки
+ Оригинальная документация: https://docs.python.org/3/library/re.html;
+ Очень подробный и обстоятельный материал: https://www.regular-expressions.info/;
+ Разные сложные трюки и тонкости с примерами: http://www.rexegg.com/;
+ Он-лайн отладка регулярок https://regex101.com (не забудьте поставить галочку Python в разделе FLAVOR слева);
+ Он-лайн визуализация регулярок https://www.debuggex.com/ (не забудьте выбрать Python);
Могущественный текстовый редактор Sublime text 3, в котором очень удобный поиск по регуляркам;
http://www.sublimetext.com/3

# Основы синтаксиса

Любая строка (в которой нет символов 

    .^$*+?{}[]\|()) 

сама по себе является регулярным выражением. 

Так, выражению Хаха будет соответствовать строка “Хаха” и только она. 

Регулярные выражения являются регистрозависимыми, поэтому строка “хаха” (с маленькой буквы) уже не будет соответствовать выражению выше. 

Подобно строкам в языке Python, регулярные выражения имеют спецсимволы .

    ^$*+?{}[]\|(), 

которые в регулярках являются управляющими конструкциями. 

Для написания их просто как символов требуется их экранировать, для чего нужно поставить перед ними знак \\. 

Так же, как и в питоне, в регулярных выражениях выражение \n соответствует концу строки, а \t — табуляции.

# Шаблоны, соответствующие одному символу

Во всех примерах ниже соответствия регулярному выражению выделяются бирюзовым цветом с подчёркиванием.)))

![Шаблоны](/Articles/_re/pictures/001_003.PNG)

# Квантификаторы (указание количества повторений)

![Квантификаторы](/Articles/_re/pictures/001_004.PNG)

# Жадность в регулярках и границы найденного шаблона

Как указано выше, по умолчанию квантификаторы жадные. 

Этот подход решает очень важную проблему — проблему границы шаблона. 

Скажем, шаблон \d+ захватывает максимально возможное количество цифр. 

Поэтому можно быть уверенным, что перед найденным шаблоном идёт не цифра, и после идёт не цифра. 

Однако если в шаблоне есть не жадные части (например, явный текст), то подстрока может быть найдена неудачно. 

Например, если мы хотим найти «слова», начинающиеся на СУ, после которой идут цифры, при помощи регулярки СУ\d*, то мы найдём и неправильные шаблоны:

    ПАСУ13 СУ12, ЧТОБЫ СУ6ЕНИЕ УДАЛОСЬ.

В тех случаях, когда это важно, условие на границу шаблона нужно обязательно добавлять в регулярку. О том, как это можно делать, будет дальше.

# Пересечение подстрок

В обычной ситуации регулярки позволяют найти только непересекающиеся шаблоны. Вместе с проблемой границы слова это делает их использование в некоторых случаях более сложным. Например, если мы решим искать e-mail адреса при помощи неправильной регулярки

    \w+@\w+ 

или даже лучше:

    [\w'._+-]+@[\w'._+-]+,

то в неудачном случае найдём вот что:

    foo@boo@goo@moo@roo@zoo

То есть это с одной стороны и не e-mail, а с другой стороны это не все подстроки вида текст-собака-текст, так как boo@goo и moo@roo пропущены.

![Пример](/Articles/_re/pictures/001_005.png)

# Эксперименты в песочнице

Если вы впервые сталкиваетесь с регулярными выражениями, то лучше всего сначала попробовать песочницу. 

https://regex101.com/r/aGn8QC/2

Посмотрите, как работают простые шаблоны и квантификаторы. Решите следующие задачи для этого текста (возможно, к части придётся вернуться после следующей теории):

1. Найдите все натуральные числа (возможно, окружённые буквами);
2. Найдите все «слова», написанные капсом (то есть строго заглавными), возможно внутри настоящих слов (аааБББввв);
3. Найдите слова, в которых есть русская буква, а когда-нибудь за ней цифра;
4. Найдите все слова, начинающиеся с русской или латинской большой буквы (\b — граница слова);
5. Найдите слова, которые начинаются на гласную (\b — граница слова);;
6. Найдите все натуральные числа, не находящиеся внутри или на границе слова;
7. Найдите строчки, в которых есть символ * (. — это точно не конец строки!);
8. Найдите строчки, в которых есть открывающая и когда-нибудь потом закрывающая скобки;
9. Выделите одним махом весь кусок оглавления (в конце примера, вместе с тегами);
10. Выделите одним махом только текстовую часть оглавления, без тегов;
11. Найдите пустые строчки;

# Регулярки в питоне

Функции для работы с регулярками живут в модуле re. Основные функции:

![Регулярки в питоне](/Articles/_re/pictures/001_006.PNG)

###
    Функция	                                Её смысл
    re.search(pattern, string)	            Найти в строке string первую строчку,
                                            подходящую под шаблон pattern;
    
    re.fullmatch(pattern, string)	        Проверить, подходит ли строка string 
                                            под шаблон pattern;
    re.split(pattern, string, maxsplit=0)	Аналог str.split(), только разделение 
                                            происходит по подстрокам, подходящим 
                                            под шаблон pattern;
    
    re.findall(pattern, string)	            Найти в строке string все 
                                            непересекающиеся шаблоны pattern;
    
    re.finditer(pattern, string)	        Итератор всем непересекающимся 
                                            шаблонам pattern в строке string 
                                            (выдаются match-объекты);
    
    re.sub(pattern, repl, string, count=0)	Заменить в строке string все 
                                            непересекающиеся шаблоны pattern на repl;

# Пример использования всех основных функций
###
    import re 

    match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12') 
    print(match[0] if match else 'Not found') 
    # -> 23-12 
    match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
    print(match[0] if match else 'Not found') 
    # -> Not found 

    match = re.fullmatch(r'\d\d\D\d\d', r'12-12') 
    print('YES' if match else 'NO') 
    # -> YES 
    match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12') 
    print('YES' if match else 'NO') 
    # -> NO 

    print(re.split(r'\W+', 'Где, скажите мне, мои очки??!')) 
    # -> ['Где', 'скажите', 'мне', 'мои', 'очки', ''] 

    print(re.findall(r'\d\d\.\d\d\.\d{4}', 
                    r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
    # -> ['19.01.2018', '01.09.2017'] 

    for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
        print('Дата', m[0], 'начинается с позиции', m.start()) 
    # -> Дата 19.01.2018 начинается с позиции 20 
    # -> Дата 01.09.2017 начинается с позиции 45 

    print(re.sub(r'\d\d\.\d\d\.\d{4}', 
                r'DD.MM.YYYY', 
                r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
    # -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY 

# Тонкости экранирования в питоне ('\\\\\\\\foo')

Так как символ \ в питоновских строках также необходимо экранировать, то в результате в шаблонах могут возникать конструкции вида

    '\\\\par'. 

Первый слеш означает, что следующий за ним символ нужно оставить «как есть». Третий также. 

В результате с точки зрения питона 
    
    '\\\\' 

означает просто два слеша 

    \\. 

Теперь с точки зрения движка регулярных выражений, первый слеш экранирует второй. 

Тем самым как шаблон для регулярки 

    '\\\\par' 

означает просто текст 

    \par. 

Для того, чтобы не было таких нагромождений слешей, перед открывающей кавычкой нужно поставить символ

    r, 

что скажет питону «не рассматривай \ как экранирующий символ (кроме случаев экранирования открывающей кавычки)». 

Соответственно можно будет писать 
    
    r'\\par'.

# Использование дополнительных флагов в питоне

Каждой из функций, перечисленных выше, можно дать дополнительный параметр flags, что несколько изменит режим работы регулярок. 

В качестве значения нужно передать сумму выбранных констант, вот они:

![flags](/Articles/_re/pictures/001_007.PNG)

###
    Константа	    Её смысл
    re.ASCII	    По умолчанию \w, \W, \b, \B, \d, \D, \s, \S    
                    соответствуют все юникодные символы с 
                    соответствующим качеством.
                    Например, \d соответствуют не только арабские цифры, но и вот такие: ٠١٢٣٤٥٦٧٨٩. 
                    re.ASCII ускоряет работу, если все соответствия 
                    лежат внутри ASCII.

    re.IGNORECASE	Не различать заглавные и маленькие буквы. 
                    Работает медленнее, но иногда удобно

    re.MULTILINE	Специальные символы ^ и $ соответствуют 
                    началу и концу каждой строки

    re.DOTALL	    По умолчанию символ \n конца строки не подходит 
                    под точку. 
                    С этим флагом точка — вообще любой символ

```python
import re 
print(re.findall(r'\d+', '12 + ٦٧')) 
# -> ['12', '٦٧'] 
print(re.findall(r'\w+', 'Hello, мир!')) 
# -> ['Hello', 'мир'] 
print(re.findall(r'\d+', '12 + ٦٧', flags=re.ASCII)) 
# -> ['12'] 
print(re.findall(r'\w+', 'Hello, мир!', flags=re.ASCII)) 
# -> ['Hello'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 
# -> ['ааааа', 'яяяя'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', flags=re.IGNORECASE)) 
# -> ['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 
text = r""" 
Торт 
с вишней1 
вишней2 
""" 
print(re.findall(r'Торт.с', text)) 
# -> [] 
print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 
# -> ['Торт\nс'] 
print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней1', 'вишней2'] 
print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней2'] 
```
