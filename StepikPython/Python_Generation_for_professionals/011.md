# 11. Регулярные выражения

## Содержание

+ [11.1 Регулярные выражения. Часть 1](#111-регулярные-выражения-часть-1)
  + [Жизнь без регулярных выражений](#жизнь-без-регулярных-выражений)
  + [1. Регулярные выражения](#1-регулярные-выражения)
  + [2. Сырые строки и экранирование символов](#2-сырые-строки-и-экранирование-символов)
  + [3. Поиск заданного текста](#3-поиск-заданного-текста)
  + [4. Поиск любого символа](#4-поиск-любого-символа)
  + [5. Поиск символа точки .](#5-поиск-символа-точки)
  + [6. Поиск цифр](#6-поиск-цифр)
  + [7. Поиск пробельных символов](#7-поиск-пробельных-символов)
  + [8. Поиск алфавитно-цифровых символов](#8-поиск-алфавитно-цифровых-символов)
  + [Задачи на регулярное выражение](#задачи-на-регулярное-выражение)
+ [11.2 Регулярные выражения. Часть 2](#112-регулярные-выражения-часть-2)

[Оглавление](../Python_Generation_for_professionals/README.MD)

## 11.1 Регулярные выражения. Часть 1

Аннотация. Урок посвящен изучению регулярных выражений.

### Жизнь без регулярных выражений

Работая со строковыми объектами (тип `str`), программисты часто сталкиваются с задачей определения совпадения строк и/или проверки вхождения одной строки в другую.

В Python строки сравниваются посимвольно: две строки равны, если совпадают их длины и равны символы на каждой из позиций.

Приведенный ниже код:

```python
text1 = 'python!'
text2 = 'python' + '!'
text3 = 'Python!'

print(text1 == text2)
print(text1 == text3)
```

выводит:

```bash
True
False
```

Для проверки принадлежности одной строки другой можно использовать несколько механизмов:

+ оператор принадлежности `in`
+ строковый метод `index()`
+ строковый метод `find()`

Приведенный ниже код:

```python
text = 'python 123 beegeek'

print('123' in text)
print(text.index('123'))
print(text.find('123'))
```

выводит:

```bash
True
7
7
```

Строковый метод `index()` возбуждает исключение, если подстрока не найдена, в то время как метод `find()` возвращает значение $−1$.

Все три механизма (оператор `in`, метод `index()` и метод `find()`) выполняют поиск подстроки путем прямого посимвольного сравнения. Это позволит выполнить работу во многих случаях, но иногда проблема оказывается сложнее. Что если вместо фиксированной подстроки `123`, мы хотим определить содержит ли строка `text` какие-либо три последовательных цифры, как в следующих строках:

```python
python 123 beegeek
python 342 stepik
789 beegeek
number 557 is awesome!
```

В такой ситуации, очевидно приведенные выше механизмы без дополнительной логики не сработают.

Рассмотрим следующую задачу: пусть телефонный номер имеет шаблон `ddd-ddd-dddd` (три цифры дефис три цифры дефис четыре цифры). Требуется найти все телефонные номера в заданном тексте.

Приведенный ниже код решает задачу:

```python
def is_phone_number(phone):
    groups = phone.split('-')
    if len(groups) != 3:
        return False
    if any((len(groups[0]) != 3, len(groups[1]) != 3, len(groups[2]) != 4)):
        return False
    chars = ''.join(groups)
    return all(c.isdigit() for c in chars)

def get_all_numbers(text):
    for c in range(len(text)):
        chunk = text[c:c + 12]
        if is_phone_number(chunk):
            yield chunk

txt = 'Привет всем, мой номер 919-654-8765, а еще у меня есть два дополнительных номера:543-780-0898 и 123-765-8907. Вот и все!'

print(list(get_all_numbers(txt)))
```

и выводит:

```bash
['919-654-8765', '543-780-0898', '123-765-8907']
```

Несмотря на то что код является рабочим и решает поставленную задачу, мы понимаем, что он не очень эффективный.

+ Во-первых, с точки зрения расходуемой памяти, ведь нам приходится делать срезы по $12$ символов. Если исходная строка будет очень большой, это может привести к проблемам нехватки памяти.
+ Во-вторых, наш код жестко завязан на шаблон указанного телефонного номера. При малейшем изменении шаблона или его расширении (например, символ +7 в начале) вся логика кода ломается. Другими словами, наш код открыт для изменения, но закрыт для расширения.

>Принцип открытости/закрытости — принцип ООП, устанавливающий следующее положение: программные сущности (классы, функции и т.д.) должны быть открыты для расширения, но закрыты для изменения.

---
[Содержание](#содержание)

### 1. Регулярные выражения

**Регулярные выражения** (regular expression, regex, регулярка) – это мощный способ обработки текста, позволяющий находить в строках подстроки по сложным условиям.

Чуть более формально, **регулярное выражение** — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строк. Регулярное выражение состоит из обычных символов и специальных командных последовательностей. Например, `\d` задаёт любую цифру, а `\d+` — задает любую последовательность из одной или более цифр.

Работа с регулярными выражениями реализована во всех современных языках программирования. Однако существует несколько диалектов, поэтому функционал регулярных выражений может различаться от языка к языку.

В некоторых языках программирования пользоваться регулярными выражениями очень удобно (например, Python), в некоторых — не слишком (например, C++).

Регулярные выражения обычно применяют для:

+ поиска подстрок в строке
+ разделения строки на подстроки
+ замены части строки

Приведем несколько примеров регулярных выражений:

Регулярное выражение | Его смысл
-- | --
`beegeek` | означает в точности строку beegeek
`\d` | означает любую цифру от $0$ до $9$
`\d{5}` | означает любую последовательность из $5$ цифр
`\d\d/\d\d/\d{4}` | означает любую дату в формате ДД/ММ/ГГГГ
`[-+]?\d+` | означает любое целое число (например, $88$, $+34$, $−69$, $007$)

Регулярные выражения позволяют очень компактно описывать текстовые шаблоны.

Например, указанный выше шаблон телефонного номера ddd-ddd-dddd (три цифры дефис три цифры дефис четыре цифры) можно описать регулярным выражением:

```bash
\d\d\d-\d\d\d-\d\d\d\d
```

или еще более компактной версией:

```bash
\d{3}-\d{3}-\d{4}
```

---
[Содержание](#содержание)

### 2. Сырые строки и экранирование символов

В языке Python некоторые символы нужно экранировать, чтобы они воспринимались правильно. К таким символам относятся:

+ обратный слэш `\`
+ одинарная кавычка `'`
+ двойная кавычка `"`
+ и многие другие
Приведенный ниже код:

```python
print('\\')
print('\'')
print("\"")
```

выводит:

```bash
\
'
"
```

Экранированные последовательности — это последовательности, которые начинаются с символа `\`, за которым следует один или более символов (`\\`, `\'`, `\"`, `\n`, `\t` и т.д.).

Чтобы написать правильно строку, в которой находятся два символа обратного слэша `\\`, оба символа надо экранировать, и в итоге получится строка вида `\\\\`. Вместо экранирования можно использовать сырые (raw) строки, и тогда каждый символ будет восприниматься так, как написан. Сырые строки отличаются от обычных тем, что при создании строки вначале пишется буква `r`.

Приведенный ниже код:

```python
print(r'\\привет мир')
print(r'\\\\')
print(r'\n')
print(r'\t')
```

выводит:

```bash
\\привет мир
\\\\
\n
\t
```

Так как в регулярных выражениях часто используется символ обратного слэша `\`, то рекомендуется использовать сырые строки для описания регулярных выражений. Некоторые выражения правильно отработают и без них, но использование сырых строк для регулярных выражений это хороший тон.

---
[Содержание](#содержание)

### Примечания 1

**Примечание 1.** Если у вас есть проблема, и вы собираетесь её решать с помощью регулярных выражений, тогда у вас уже две проблемы 😂.

**Примечание 2.** О регулярных выражениях на википедии можно почитать по [ссылке](https://ru.wikipedia.org/wiki/Регулярные_выражения).

**Примечание 3.** Термин **регулярные выражения** является переводом английского словосочетания **regular expressions**. Перевод не очень точно отражает смысл, правильнее было бы **шаблонные выражения**.

---
[Содержание](#содержание)

### 3. Поиск заданного текста

Для создания регулярных выражений необходимо использовать специальный синтаксис. Любая строка текста сама по себе является регулярным выражением. Например, `Timur` – это регулярное выражение. Поскольку это просто текст, он ничем не напоминает регулярное выражение, однако он им таки является. Регулярные выражения могут содержать простой текст и могут даже состоять из простого текста.

Регулярному выражению:

```sh
Timur
```

в тексте:

```sh
Hello, my name is Timur. Please visit my website at https://stepik.org/org/pygen.
```

соответствует (выделено жирным шрифтом):

```sh
Hello, my name is `Timur`. Please visit my website at https://stepik.org/org/pygen.
```

Используемое здесь регулярное выражение – буквальный текст, и оно находит вхождение Timur в исходном тексте.

Регулярному выражению:

```sh
is
```

в тексте:

```sh
Hello, my name is Timur. Please visit my website at https://stepik.org/org/pygen.
```

соответствует (выделено жирным шрифтом):

```sh
Hello, my name `is` Timur. Please v`is`it my website at https://stepik.org/org/pygen.
```

Обратите внимание на то, что было найдено два вхождения `is`.

Регулярные выражения сами по себе всегда ищут все вхождения. Модуль `re`, который будет изучен нами чуть позже, включает разные функции, и те, которые ищут только первое вхождение, и те которые возвращают список всех вхождений, соответствующих регулярному выражению.

Регулярные выражения являются **регистрозависимыми**, то есть регулярному выражению `Timur` не будет соответствовать строка `timur`.

---
[Содержание](#содержание)

### 4. Поиск любого символа

С помощью регулярных выражений можно искать не только известный заранее (статический) текст, но и текст в котором есть неизвестные символы. Чтобы найти соответствие некоторому шаблону, в регулярных выражениях используются специальные символы (или наборы символов), которые называются **метасимволами**. Символ точка . соответствует одному любому символу.

Регулярному выражению:

```sh
sales.
```

в тексте:

```sh
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
`sales1.`csv
orders3.csv
`sales2.`csv
`sales3.`csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

Регулярное выражение `sales.` позволяет найти все имена файлов, содержащие подстроку `sales`, за которой следует еще один произвольный символ. Ровно три файла из девяти соответствуют такому шаблону.

Обратите внимание на то, что регулярные выражения сопоставляют шаблоны строкам. Эти шаблоны не всегда будут совпадать со всей строкой, а только с теми символами, которые соответствуют шаблону, даже если они являются только частью строки.

Таким образом, специальный символ `.` соответствует любому символу – символу алфавита, цифре и даже самому символу точки `..`

Регулярному выражению:

```sh
sales.
```

в тексте:

```sh
sales.csv
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
`sales.`csv
`sales1.`csv
orders3.csv
`sales2.`csv
`sales3.`csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

Этот пример содержит один дополнительный файл `sales.csv`. Файл был найден с помощью регулярного выражения `sales.`, поскольку специальный символ `.` находит любой символ.

В регулярном выражении можно использовать несколько символов `.`, либо вместе (регулярное выражение `..` будет соответствовать любым двум символам друг рядом с другом), либо в различных местах.

Регулярному выражению:

```sh
.a.
```

в тексте:

```sh
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
`sal`es1.csv
orders3.csv
`sal`es2.csv
`sal`es3.csv
a`pac`1.csv
europe2.csv
na1.csv
na2.csv
`sa1`.csv
```

Если мы хотим найти все файлы только для Северной Америки (`na`) и Южной Америки (`sa`) независимо от того, какая цифра следует после этих сокращений, то нам нужно немного изменить регулярное выражение. Необходимо регулярное выражение `.a.` за которым следует точка.

Регулярному выражению:

```sh
.a..
```

в тексте:

```sh
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
`sale`s1.csv
orders3.csv
`sale`s2.csv
`sale`s3.csv
a`pac1`.csv
europe2.csv
`na1.`csv
`na2.`csv
`sa1.`csv
```

Несложно заметить, что регулярное выражение `.a..` работает нисколько не лучше, чем `.a.`, поскольку добавленная точка соответствует любому символу.

---
[Содержание](#содержание)

### 5. Поиск символа точки

Точка `.` имеет специальное значение в регулярных выражениях. Если в регулярном выражении нужен сам символ точки `.`, то ее необходимо экранировать. Для этого необходимо предварить точку символом обратного слэша `\.`

В регулярных выражениях точка `.` соответствует любому символу, а обратный слэш с точкой `\.` соответствует только самому символу точки `.`.

Регулярному выражению:

```re
.a.\.csv
```

в тексте:

```sh
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
`na1.csv`
`na2.csv`
`sa1.csv`
```

Первый символ `.` в регулярном выражении `.a.\.csv` соответствует символу `n` (в первых двух вхождениях) или символу `s` (в третьем вхождении). Второй символ `.` соответствует символу `1` (в первом и третьем вхождениях) или символу `2` (во втором вхождении). Последовательность символов `\.` соответствует точке `.`, отделяющей имя файла от расширения, а последовательность символов `csv` соответствует самой себе.

>Если в регулярном выражении нужен символ `\`, то его также нужно экранировать `\\`.

---
[Содержание](#содержание)

### 6. Поиск цифр

Как уже было сказано, **метасимволы** – это символы, которые имеют специальное значение в регулярных выражениях.

Для поиска любой цифры от $0$ до $9$ используется метасимвол `\d`.

Регулярному выражению:

```re
..\d
```

в тексте:

```sh
sales.csv
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
sales.csv
sal`es1`.csv
orde`rs3`.csv
sal`es2`.csv
sal`es3`.csv
ap`ac1`.csv
euro`pe2`.csv
`na1`.csv
`na2`.csv
`sa1`.csv
```

Для поиска любого нецифрового символа используется **метасимвол** `\D`.

Регулярному

```re
e\D
```

в тексте:

```sh
sales.csv
sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
na1.csv
na2.csv
sa1.csv
```

соответствует (выделено жирным шрифтом):

```sh
sal`es`.csv
sal`es`1.csv
orders3.csv
sal`es`2.csv
sal`es`3.csv
apac1.csv
`eu`rope2.csv
na1.csv
na2.csv
sa1.csv
```

---
[Содержание](#содержание)

### 7. Поиск пробельных символов

Для поиска пробельного символа (пробел, табуляция, конец строки) используется метасимвол `\s`.

Регулярному выражению:

```re
.\s.
```

в тексте:

```sh
привет, наконец начали изучать регулярные выражения.
```

соответствует (выделено жирным шрифтом):

```re
привет`, н`аконе`ц н`ачал`и и`зучат`ь р`егулярны`е в`ыражения.
```

Для поиска любого `непробельного` символа используется метасимвол `\S`.

Регулярному выражению:

```re
к\S\S
```

в тексте:

```sh
Математик, учитель, написание нового курса скорррро.
```

соответствует (выделено жирным шрифтом):

```sh
Математик, учитель, написание нового `кур`са с`кор`ррро.
```

---
[Содержание](#содержание)

### 8. Поиск алфавитно-цифровых символов

Есть еще один часто используемый набор – буквы (в верхнем и нижнем регистре), цифры и символ подчеркивания.

Для поиска таких символов используется метасимвол `\w`.

Регулярному выражению:

```re
\w\w\w\w
```

в тексте:

```sh
_xy_
1234
geek
-xy-
Code
a1b2
```

соответствует (выделено жирным шрифтом):

```sh
`_xy_`
`1234`
`geek`
-xy-
`Code`
`a1b2`
```

Для поиска символов, не являющихся буквой, цифрой и подчёркиванием используется метасимвол `\W`.

Регулярному выражению:

```re
\w\W\W\w
```

в тексте:

```sh
x!?y
a..b
geek
1+-2
1234
x__y
```

соответствует (выделено жирным шрифтом):

```sh
`x!?y`
`a..b`
geek
`1+-2`
1234
x__y
```

---
[Содержание](#содержание)

### Примечания 2

**Примечание 1.** Так же, как и в Python, в регулярных выражениях выражение `\n` соответствует концу строки, а `\t` — табуляции.

**Примечание 2.** Регулярные выражения — как полицейский-регулировщик. Когда учишься, всё просто и элементарно, а когда встречаешь в реальности, понимаешь, что всё забыл 😂.

**Примечание 3.** Как правило, в регулярных выражениях точке `.` соответствует любой символ. Однако в большинстве реализаций регулярных выражений точке `.` соответствует любой символ, кроме символа новой строки (`\n`).

**Примечание 4.** Сайт для отладки регулярных выражений доступен по [ссылке](https://regex101.com/) (не забудьте поставить галочку Python в разделе FLAVOR слева).

**Примечание 5.** Разные сложные трюки и тонкости работы с регулярными выражениями доступны по [ссылке](http://www.rexegg.com/).

**Примечание 6.** Очень подробный и обстоятельный материал по регулярным выражениям доступен по [ссылке](https://www.regular-expressions.info/).

---
[Содержание](#содержание)

### Задачи на регулярное выражение

Перед тем как вы приступите к представленным упражнениям, мы бы хотели немного рассказать о задачах, в которых требуется написать регулярное выражение. Рассмотрим пару таких задач и дадим несколько комментариев относительно их оформления.

**Задача 1.** Дополните приведенный ниже код, чтобы переменная `regex` содержала регулярное выражение, которому соответствует строка `Hello`.

```python
regex = r''
```

**Решение.** В задаче требуется реализовать регулярное выражение и присвоить его переменной regex. Регулярное выражение, которому соответствует строка `Hello` представляет собой саму строку `Hello`.

Итак, наше регулярное выражение имеет вид:

```python
regex = r'Hello'
```

Приведенный выше код является ответом на задачу, и именно его следует вставить в окошко ввода. Дополнительно считывать\выводить данные не нужно, требуется лишь реализовать регулярное выражение и присвоить его указанной переменной.

**Задача 2.** Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют трехсимвольные цифровые последовательности.

```python
regex = r''
```

**Решение.** В задаче требуется реализовать регулярное выражение и присвоить его переменной regex. Для решения воспользуемся метасимволом `\d`, соответствующим любой цифре.

Итак, наше регулярное выражение может иметь вид:

```python
regex = r'\d\d\d'
```

Приведенный выше код является ответом на задачу, и именно его следует вставить в окошко ввода. Дополнительно считывать\выводить данные не нужно, требуется лишь реализовать регулярное выражение и присвоить его указанной переменной.

### Примечания 3

**Примечание.** В задачах на регулярное выражение нет входных и выходных данных, тем не менее в тестовых данных вы увидите строки текста и соответствующий вывод: это именно то, как мы будем тестировать реализованное вами регулярное выражение.  
**Sample Input** представляет строку, в которой осуществляется поиск,  
**Sample Output** — список всех значений, указанных через пробел, которые должны быть найдены в данной строке реализованным вами регулярным выражением.

---
[Содержание](#содержание)

## 11.2 Регулярные выражения. Часть 2
