# 11  Списки

# 11.1 Введение в списки

## Тема урока: введение в списки
1. Создание списков
2. Пустые списки
3. Встроенная функция list()
4. Вывод списков

Аннотация. Списки как сохранение последовательностей и аналог массивов. 

# Списки

В предыдущих уроках мы работали с последовательностями чисел, символов, строк, но не сохраняли всю последовательность в памяти компьютера, а обрабатывали ее поэлементно, считывая раз за разом новый элемент. Однако во многих задачах требуется сохранять всю последовательность. 

Например, классическая задача сортировки (упорядочения) некоторой последовательности требует сохранения всех данных в памяти компьютера. Увы, не сохранив, их невозможно отсортировать. 

И тут на помощь приходит структура данных, которая в большинстве языков программирования называется массивом. 

В Python она называется списком.

Структура данных (data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.

Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.

# Создание списка

Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:

    numbers = [2, 4, 6, 8, 10]
    languages = ['Python', 'C#', 'C++', 'Java']

Список numbers состоит из 5 элементов, и каждый из них — целое число.

    numbers[0] == 2;
    numbers[1] == 4;
    numbers[2] == 6;
    numbers[3] == 8;
    numbers[4] == 10.

Список languages состоит из 4 элементов, каждый из которых — строка.

    languages[0] == 'Python';
    languages[1] == 'C#';
    languages[2] == 'C++';
    languages[3] == 'Java'.

Значения, заключенные в квадратные скобки и отделенные запятыми, называются элементами списка.

Список может содержать значения разных типов данных:

    info = ['Timur', 1992, 61.5]

Список info содержит строковое значение, целое число и число с плавающей точкой.

    info[0] == 'Timur';
    info[1] == 1992;
    info[2] == 61.5.

Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.

# Пустой список

Создать пустой список можно двумя способами:

+ Использовать пустые квадратные скобки [];
+ Использовать встроенную функцию, которая называется list.

Следующие две строки кода создают пустой список:

    mylist = []       # пустой список
    mylist = list()   # пустой список

# Вывод списка

Для вывода всего списка можно применить функцию print():

    numbers = [2, 4, 6, 8, 10]
    languages = ['Python', 'C#', 'C++', 'Java']
    print(numbers)
    print(languages)

Функция print() выводит на экран элементы списка, в квадратных скобках, разделенные запятыми:

    [2, 4, 6, 8, 10]
    ['Python', 'C#', 'C++', 'Java']

Обратите внимание, что вывод списка содержит квадратные скобки. Позже мы научимся выводить элементы списка в более удобном виде с помощью циклов.

# Встроенная функция list

Python имеет встроенную функцию list(), которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.

Например, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код:

    numbers = list(range(5))

Во время исполнения этого кода происходит следующее:

+ Вызывается функция range(), в которую в качестве аргумента передается число 5;
+ Эта функция возвращает последовательность чисел 0, 1, 2, 3, 4;
+ Последовательность чисел 0, 1, 2, 3, 4 передается в качестве аргумента в функцию list();
+ Функция list() возвращает список [0, 1, 2, 3, 4];
+ Список [0, 1, 2, 3, 4] присваивается переменной numbers.

Вот еще один пример:

    even_numbers = list(range(0, 10, 2))  # список содержит четные числа 0, 2, 4, 6, 8
    odd_numbers = list(range(1, 10, 2))   # список содержит нечетные числа 1, 3, 5, 7, 9

Точно также с помощью функции list() мы можем создать список из символов строки.  Для преобразования строки в список мы пишем следующий код:

    s = 'abcde'
    chars = list(s)  # список содержит символы 'a', 'b', 'c', 'd', 'e'

Во время исполнения этого кода происходит следующее:

+ Вызывается функция list(), в которую в качестве аргумента передается строка 'abcde';
+ Функция list() возвращает список ['a', 'b', 'c', 'd', 'e'];
+ Список ['a', 'b', 'c', 'd', 'e'] присваивается переменной chars.

## Примечания

### Примечание 1. 
Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.

### Примечание 2. 
Обратите внимание, при выводе содержимого списка с помощью функции print(), все строковые элементы списка обрамляются одинарными кавычками. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.

# 11.2 Основы работы со списками

## Тема урока: основы работы со списками
1. Встроенные функции len(),sum(),min(),max()
2. Оператор принадлежности in
3. Индексация и срезы
4. Конкатенация и умножение на число
5. Отличие списков от строк

Аннотация. Начинаем работать со списками.

# Основы работы со списками

Работа со списками очень сильно напоминает работу со строками, поскольку и списки, и строки содержат отдельные элементы: элементы списка могут иметь произвольный тип, а элементами строк всегда являются символы. Многое из того, что мы делали со строками, доступно и при работе со списками.

# Функция len()

Длиной списка называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию len() (от слова length – длина).

Следующий программный код:

    numbers = [2, 4, 6, 8, 10]
    languages = ['Python', 'C#', 'C++', 'Java']

    print(len(numbers))      # выводим длину списка numbers
    print(len(languages))    # выводим длину списка languages

    print(len(['apple', 'banana', 'cherry']))   # выводим длину списка, состоящего из 3 элементов

выведет:

    5
    4
    3

# Оператор принадлежности in

Оператор in позволяет проверить, содержит ли список некоторый элемент.

Рассмотрим следующий код:

    numbers = [2, 4, 6, 8, 10]

    if 2 in numbers:
        print('Список numbers содержит число 2')
    else:
        print('Список numbers не содержит число 2')

Такой код проверяет, содержит ли список numbers число 2 и выводит соответствующий текст:

    Список numbers содержит число 2

Мы можем использовать оператор in вместе с логическим оператором not. 

Например

    numbers = [2, 4, 6, 8, 10]

    if 0 not in numbers:
        print('Список numbers не содержит нулей')

# Индексация

При работе со строками мы использовали индексацию, то есть обращение к конкретному символу строки по его индексу. Аналогично, можно индексировать и списки.

Для индексации списков в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного элемента в списке:

Пусть numbers = [2, 4, 6, 8, 10].

Таблица ниже, показывает как работает индексация:

    Выражение	Результат	Пояснение
    numbers[0]	    2	    первый элемент списка
    numbers[1]	    4	    второй элемент списка
    numbers[2]	    6	    третий элемент списка
    numbers[3]	    8	    четвертый элемент списка
    numbers[4]	    10  	пятый элемент списка

Обратите внимание первый элемент списка numbers[0], а не numbers[1]. 

Так же, как и в строках, для нумерации с конца разрешены отрицательные индексы.

    Выражение	Результат	Пояснение
    numbers[-1]	    10  	пятый элемент списка
    numbers[-2]	    8	    четвертый элемент списка
    numbers[-3]	    6	    третий элемент списка
    numbers[-4]	    4	    второй элемент списка
    numbers[-5]	    2	    первый элемент списка

Как и в строках, попытка обратиться к элементу списка по несуществующему индексу:

    print(numbers[17])

вызовет ошибку:

    IndexError: index out of range

# Срезы

Рассмотрим список numbers = [2, 4, 6, 8, 10].

С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием numbers[x:y].

Следующий программный код:

    print(numbers[1:3])
    print(numbers[2:5])

выводит:

    [4, 6]
    [6, 8, 10]

При построении среза numbers[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного.

При использовании срезов со списками мы также можем опускать второй параметр в срезе numbers[x:] (но поставить двоеточие), тогда срез берется до конца списка. Аналогично если опустить первый параметр numbers[:y], то можно взять срез от начала списка.

Срез numbers[:] возвращает копию исходного списка.

Как и в строках, мы можем использовать отрицательные индексы в срезах списков.

Использование срезов для изменения элементов в заданном диапазоне
Для изменения целого диапазона элементов списка можно использовать срезы. Например, если мы хотим перевести на русский язык названия фруктов 'banana', 'cherry', 'kiwi', то это можно сделать с помощью среза.

Следующий программный код:

    fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
    fruits[2:5] = ['банан', 'вишня', 'киви']

    print(fruits)

выводит:

    ['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']

# Операция конкатенации + и умножения на число *

Мы можем применять операторы + и * для списков подобно тому как мы это делали со строками.

Следующий программный код:

    print([1, 2, 3, 4] + [5, 6, 7, 8])
    print([7, 8] * 3)
    print([0] * 10)

выводит:

    [1, 2, 3, 4, 5, 6, 7, 8]
    [7, 8, 7, 8, 7, 8]
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

Для генерации списков, состоящих строго из повторяющихся элементов, умножение на число — самый короткий и правильный метод.

Мы также можем использовать расширенные операторы += и *= при работе со списками.

Следующий программный код:

    a = [1, 2, 3, 4]
    b = [7, 8]
    a += b   # добавляем к списку a список b
    b *= 5   # повторяем список b 5 раз 

    print(a)
    print(b)

выводит:

    [1, 2, 3, 4, 7, 8]
    [7, 8, 7, 8, 7, 8, 7, 8, 7, 8]

# Встроенные функции sum(), min(), max()

Встроенная функция sum() принимает в качестве параметра список чисел и вычисляет сумму его элементов.

Следующий программный код:

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print('Сумма всех элементов списка =', sum(numbers))

выводит:

    Сумма всех элементов списка = 55

Встроенные функции min() и max() принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.

Следующий программный код:

    numbers = [3, 4, 10, 3333, 12, -7, -5, 4]
    print('Минимальный элемент =', min(numbers))
    print('Максимальный элемент =', max(numbers))

выводит:

    Минимальный элемент = -7
    Максимальный элемент = 3333

# Отличие списков от строк

Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.

Следующий программный код:

    s = 'abcdefg'
    s[1] = 'x'    # пытаемся изменить 2 символ (по индексу 1) строки 

приводит к ошибке:

    object does not support item assignment

Следующий программный код:

    numbers = [1, 2, 3, 4, 5, 6, 7]
    numbers[1] = 101     # изменяем 2 элемент (по индексу 1) списка
    print(numbers)

выводит:

    [1, 101, 3, 4, 5, 6, 7]

Запомни: изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания.

# 11.3 Методы списков. Часть 1

## Тема урока: методы добавления и удаления элементов
1. Метод добавления элемента append()
2. Метод расширения списка extend()
3. Оператор del
4. Решение задач

Аннотация. Добавление элементов в список. Оператор del, удаляющий элементы по заданному индексу.

# Добавление элементов
Мы научились создавать статические списки, то есть списки, элементы которых известны на этапе создания. Следующий шаг – научиться добавлять элементы в уже существующие списки.

# append()

Для добавления нового элемента в конец списка используется метод append().

Следующий программный код:

    numbers = [1, 1, 2, 3, 5, 8, 13]  # создаем список

    numbers.append(21)  # добавляем число 21 в конец списка
    numbers.append(34)  # добавляем число 34 в конец списка

    print(numbers)

выведет:

    [1, 1, 2, 3, 5, 8, 13, 21, 34]

Обратите внимание, для того чтобы использовать метод append(), нужно, чтобы список был создан, при этом он может быть пустым.

Следующий программный код:

    numbers = []  # создаем пустой список

    numbers.append(1)
    numbers.append(2)
    numbers.append(3)

    print(numbers)

выведет:

    [1, 2, 3]

Важно: мы не можем использовать индексаторы для установки значений элементов списка, если список пустой. Следующий программный код:

    numbers = []  # создаем пустой список

    numbers[0] = 1
    numbers[1] = 2
    numbers[2] = 3

    print(numbers)

приводит к ошибке:

    IndexError: list assignment index out of range

# extend()

Можно также расширить список другим списком, путем вызова метода extend().

Следующий программный код:

    numbers = [0, 2, 4, 6, 8, 10]
    odds = [1, 3, 5, 7]

    numbers.extend(odds)
    print(numbers)

выведет:

    [0, 2, 4, 6, 8, 10, 1, 3, 5, 7]

Метод extend() как бы расширяет один список, добавляя к нему элементы другого списка.

Отличие между методами append() и extend() проявляется при добавлении строки к списку.

Следующий программный код:

    words1 = ['iq option', 'stepik', 'beegeek']
    words2 = ['iq option', 'stepik', 'beegeek']

    words1.append('python')
    words2.extend('python')

    print(words1)
    print(words2)

выведет:

    ['iq option', 'stepik', 'beegeek', 'python']
    ['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']

Метод:
+ append() добавляет строку 'python' целиком к списку, а метод 
+ extend() разбивает строку 'python' на  символы 'p', 'y', 't', 'h', 'o', 'n' и их добавляет в качестве элементов списка. 

# del Удаление элементов

С помощью оператора del можно удалять элементы списка по определенному индексу.

Следующий программный код:

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    del numbers[5]    # удаляем элемент имеющий индекс 5

    print(numbers)

выведет:

    [1, 2, 3, 4, 5, 7, 8, 9]

Элемент под указанным индексом удаляется, а список перестраивается.

Обратите внимание на синтаксис удаления, так как он отличается от обычного вызова метода. При удалении элементов не надо передавать аргумент внутри круглых скобок.

Оператор del работает и со срезами: мы можем удалить целый диапазон элементов списка.

Следующий программный код:

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    del numbers[2:7]    # удаляем элементы с 2 по 6 включительно

    print(numbers)

выведет:

    [1, 2, 8, 9]

Мы можем удалить все элементы на четных позициях (0, 2, 4, ...) исходного списка.

Следующий программный код:

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    del numbers[::2]

    print(numbers)

выведет:

    [2, 4, 6, 8]

# 11.4 Вывод элементов списка

# Вывод элементов списка

При выводе содержимого списка с помощью функции print()  вывод элементов осуществляется в квадратных скобках, причем все элементы разделены запятой. Такой вывод не всегда удобен и предпочтителен, поэтому нужно уметь выводить элементы списка нужным нам способом.

# Вывод с помощью цикла for

Для вывода элементов списка каждого на отдельной строке можно использовать следующий код:

Вариант 1. Если нужны индексы элементов:

    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    for i in range(len(numbers)):
        print(numbers[i])

Мы передаем в функцию range() длину списка len(numbers). В нашем случае длина списка numbers, равна 11. Таким образом вызов функции range(len(numbers)) имеет вид range(11) и переменная цикла i последовательно перебирает все значения от 0 до 10. Это означает, что выражение numbers[i] последовательно вернет все элементы списка numbers. Такой способ итерации списка удобен, когда нам нужен не только сам элемент numbers[i], но и его индекс i.

Вариант 2. Если индексы не нужны:

    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    for num in numbers:
        print(num)

Этот цикл пройдет по списку numbers, придавая переменной цикла num значение каждого элемента списка (!) в отличие от предыдущего цикла, в котором переменная цикла «бегала» по индексам списка.

Если требуется выводить  элементы списка на одной строке, через пробел, то мы можем использовать необязательный параметр end функции print():

    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    for num in numbers:
        print(num, end=' ')

# Вывод с помощью распаковки списка

В Python есть удобный способ вывода элементов списка без использования цикла for.

Вариант 1. Вывод элементов списка через один символ пробела:

    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    print(*numbers)

Такой код выведет:

    0 1 2 3 4 5 6 7 8 9 10

Вариант 2. Вывод элементов списка, каждого на отдельной строке

    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    print(*numbers, sep='\n')

Такой код выведет:

    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

Поскольку строки содержат символы, подобно тому, как списки содержат элементы, то мы можем использовать распаковку строк точно так же, как и распаковку списков. 

Такой код:

    s = 'Python'

    print(*s)
    print()
    print(*s, sep='\n')

выведет:

    P y t h o n

    P
    y
    t
    h
    o
    n

# 11.5 Методы строк: split, join

## Тема урока: строковые методы
1. Метод split()
2. Метод join()

Аннотация. Строковые методы split() и join().

В предыдущем модуле мы детально изучили основные строковые методы, однако обошли стороной два важных: split() и join(), имеющих отношение к спискам. Они как бы противоположны по смыслу: метод split() разбивает строку по произвольному разделителю на список слов, а метод join() собирает строку из списка слов через заданный разделитель.

# split()

Метод split() разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов.

Следующий программный код:

    s = 'Python is the most powerful language'
    words = s.split()
    print(words)

выведет: 

    ['Python', 'is', 'the', 'most', 'powerful', 'language']

![split()](/StepikPython/Python_Generation_for_beginners/pictures/028.png)

Таким образом, вызов метода split() разбивает строку на слова и возвращает список, содержащий все слова.

Рассмотрим следующий программный код:

    numbers = input().split()

Если при запуске этой программы ввести строку 1 2 3 4 5, то список numbers будет следующим  ['1', '2', '3', '4', '5']. Обратите внимание, что список будет состоять из строк, а не из чисел. Если требуется получить именно список чисел, то затем нужно элементы списка по одному преобразовать в числа:

    numbers = input().split()
    for i in range(len(numbers)):
        numbers[i] = int(numbers[i])

Необязательный параметр

У метода split() есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. Например, вызов метода split('.') вернет список, полученный разделением исходной строки по символу '.'.

Следующий программный код:

    ip = '192.168.1.24'
    numbers = ip.split('.')    # указываем явно разделитель
    print(numbers)
выведет список:

    ['192', '168', '1', '24']

![split()](/StepikPython/Python_Generation_for_beginners/pictures/029.png)

# join()

Метод join() собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.

Следующий программный код:

    words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
    s = ' '.join(words)
    print(s)

выведет: 

    Python is the most powerful language

![join()](/StepikPython/Python_Generation_for_beginners/pictures/030.png)

Обратите внимание, все слова разделены одним пробелом, поскольку метод join() вызывался на строке состоящей из одного символа пробела ' '.

Рассмотрим еще пару примеров:

    words = ['Мы', 'учим', 'язык', 'Python']
    print('*'.join(words))
    print('-'.join(words))
    print('?'.join(words))
    print('!'.join(words))
    print('*****'.join(words))
    print('abc'.join(words))
    print('123'.join(words))
Результатом выполнения такого кода будет:

    Мы*учим*язык*Python
    Мы-учим-язык-Python
    Мы?учим?язык?Python
    Мы!учим!язык!Python
    Мы*****учим*****язык*****Python
    МыabcучимabcязыкabcPython
    Мы123учим123язык123Python

Запомни: Строковый метод split() служит для преобразования строки в список, а метод join() — для преобразования списка в строку.

## Примечания
### Примечание 1. 

Существует большая разница между результатами вызова методов s.split() и s.split(' '). Разница в поведении проявляется когда строка содержит несколько пробелов между словами.

Следующий программный код:

    s = 'Python    is   the  most  powerful  language'
    words1 = s.split()
    words2 = s.split(' ')
    print(words1)
    print(words2)

выведет списки:

    ['Python', 'is', 'the', 'most', 'powerful', 'language']
    ['Python', '', '', '', 'is', '', '', 'the', '', 'most', '', 'powerful', '', 'language']

### Примечание 2. 

Методы split() и join() являются строковыми методами. Следующий код приводит к ошибке:

    print([1, 2].split())
    print([1, 2].join([3, 4, 5]))

### Примечание 3. 

Строковый метод join() работает только со списком строк. Следующий код приводит к ошибке:

    numbers = [1, 2, 3, 4]  # список чисел
    s = '*'.join(numbers)
    print(s)

# 11.6 Методы списков. Часть 2

## Тема урока: методы списков
1. Метод insert()
2. Метод index()
3. Метод remove()
4. Метод pop()
5. Метод reverse()
6. Метод count()
7. Метод clear()
8. Метод copy()
9. Метод sort()

Аннотация. Другие методы списков.

Мы уже познакомились с двумя списочными методами append() и extend(). Первый добавляет в конец списка один новый элемент, а второй расширяет список другим списком. К спискам в Python применимы и другие удобные методы, с которыми мы познакомимся в этом уроке.

# insert()

Метод insert() позволяет вставлять значение в список в заданной позиции. В него передается два аргумента:

1. index: индекс, задающий место вставки значения;
2. value: значение, которое требуется вставить.

Когда значение вставляется в список, список расширяется в размере, чтобы разместить новое значение. Значение, которое ранее находилось в заданной индексной позиции, и все элементы после него сдвигаются на одну позицию к концу списка.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    print(names)
    names.insert(0, 'Anders')
    print(names)
    names.insert(3, 'Josef')
    print(names)

выведет:

    ['Gvido', 'Roman' , 'Timur']
    ['Anders', 'Gvido', 'Roman' , 'Timur']
    ['Anders', 'Gvido', 'Roman' , 'Josef', 'Timur']

Если указан недопустимый индекс, то во время выполнения программы не происходит ошибки. Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка. Если применен отрицательный индекс, который указывает на недопустимую позицию, то значение будет вставлено в начало списка.

#  index()

Метод index() возвращает индекс первого элемента, значение которого равняется переданному в метод значению. Таким образом, в метод передается один параметр:

1. value: значение, индекс которого требуется найти.

Если элемент в списке не найден, то во время выполнения происходит ошибка.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    position = names.index('Timur')
    print(position)

выведет:

    2

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    position = names.index('Anders')
    print(position)

приводит к ошибке:

    ValueError: 'Anders' is not in list

Чтобы избежать таких ошибок, можно использовать метод index() вместе с оператором принадлежности in:

    names = ['Gvido', 'Roman' , 'Timur']
    if 'Anders' in names:
        position = names.index('Anders')
        print(position)
    else:
        print('Такого значения нет в списке')

# remove()

Метод remove() удаляет первый элемент, значение которого равняется переданному в метод значению. В метод передается один параметр:

1. value: значение, которое требуется удалить.

Метод уменьшает размер списка на один элемент. Все элементы после удаленного элемента смещаются на одну позицию к началу списка. Если элемент в списке не найден, то во время выполнения происходит ошибка.

Следующий программный код:

    food = ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
    print(food)
    food.remove('Рис')
    print(food)

выведет:

    ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
    ['Курица', 'Рыба', 'Брокколи', 'Рис']

Важно: метод remove() удаляет только первый элемент с указанным значением. Все последующие его вхождения остаются в списке. Чтобы удалить все вхождения нужно использовать цикл while в связке с оператором принадлежности in и методом remove.

# pop()

Метод pop() удаляет элемент по указанному индексу и возвращает его. В метод pop() передается один необязательный аргумент:

1. index: индекс элемента, который требуется удалить.

Если индекс не указан, то метод удаляет и возвращает последний элемент списка. Если список пуст или указан индекс за пределами диапазона, то во время выполнения происходит ошибка.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    item = names.pop(1)
    print(item)
    print(names)

выведет:

    Roman
    ['Gvido', 'Timur']

# count()

Метод count() возвращает количество элементов в списке, значения которых равны переданному в метод значению. 

Таким образом, в метод передается один параметр:

1. value: значение, количество элементов, равных которому,  нужно посчитать.

Если значение в списке не найдено, то метод возвращает 0.

Следующий программный код:

    names = ['Timur', 'Gvido', 'Roman', 'Timur', 'Anders', 'Timur']
    cnt1 = names.count('Timur')
    cnt2 = names.count('Gvido')
    cnt3 = names.count('Josef')

    print(cnt1)
    print(cnt2)
    print(cnt3)

выведет:

    3
    1
    0

# reverse()
Метод reverse() инвертирует порядок следования значений в списке, то есть меняет его на противоположный.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    names.reverse()
    print(names)

выведет:

    ['Timur', 'Roman', 'Gvido']

Существует большая разница между вызовом метода names.reverse() и использованием среза names[::-1]. Метод reverse() меняет порядок элементов на обратный в текущем списке, а срез создает копию списка, в котором элементы следуют в обратном порядке.

# clear()

Метод clear() удаляет все элементы из списка.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    names.clear()
    print(names)

выведет:

    []

# copy()

Метод copy() создает поверхностную копию списка.

Следующий программный код:

    names = ['Gvido', 'Roman' , 'Timur']
    names_copy = names.copy()              # создаем поверхностную копию списка names

    print(names)
    print(names_copy)

выведет:

    ['Gvido', 'Roman', 'Timur']
    ['Gvido', 'Roman', 'Timur']

Аналогичного результата можно достичь с помощью срезов или функции list():

    names = ['Gvido', 'Roman' , 'Timur']
    names_copy1 = list(names)             # создаем поверхностную копию с помощью функции list()
    names_copy2 = names[:]                # создаем поверхностную копию с помощью среза от начала до конца

## Примечания

### Примечание. 

Существует большая разница в работе строковых и списочных методов. Строковые методы не изменяют содержимого объекта к которому они применяются, а возвращают новое значение. Списочные методы, напротив, меняют содержимое объекта к которому применяются.

# 11.6 Методы списков. Часть 2

# sort()
Метод sort()

В Python списки имеют встроенный метод sort(), который сортирует элементы списка по возрастанию или убыванию.

Следующий программный код:

    a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
    a.sort()
    print('Отсортированный список:', a)

выведет:

    Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]

По умолчанию метод sort() сортирует список по возрастанию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр reverse = True.

Следующий программный код:

    a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
    a.sort(reverse = True)   # сортируем по убыванию
    print('Отсортированный список:', a)

выведет:

    Отсортированный список: [1000, 99, 45, 34, 12, 9, 8, 7, 6, 1, 0, -2, -3, -67]

## Примечания
### Примечание 1. 

С помощью метода sort() можно сортировать списки содержащие не только числа, но и строки. В таком случае элементы списка сортируются в соответствии с лексикографическим порядком.

Следующий программный код:

    a = ['бета', 'альфа', 'дельта', 'гамма']
    a.sort()
    print ('Отсортированный список:', a)

выведет:

    Отсортированный список: ['альфа', 'бета', 'гамма', 'дельта']

### Примечание 2. 
Метод sort() использует алгоритм Timsort.
https://ru.wikipedia.org/wiki/Timsort

# 11.7 Списочные выражения

## Тема урока: списочные выражения
1. Списочные выражения
2. Решение задач

Аннотация. Списочные выражения. Создание списков без явного использования циклов и вызова списочного метода append().

# Создание списков

Для того, чтобы создать список состоящий из 10 нулей мы можем использовать следующий код:

    zeros = []
    for i in range(10):
        zeros.append(0)

В Python, однако есть более простой и компактный способ для создания такого списка. Мы можем использовать оператор умножения списка на число:

    zeros = [0] * 10

Для создания списков, заполненных по более сложным правилам нам приходится явно использовать цикл for.

Например, для создания списка целых чисел от 00 до 99, мы вынуждены писать такой код:

    numbers = []
    for i in range(10):
        numbers.append(i)

Такой код хоть и не является сложным, однако достаточно громоздок.

## Списочные выражения

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — списочное выражение (list comprehension).

Предыдущий код можно записать следующим образом:

    numbers = [i for i in range(10)]

Общий вид списочного выражения следующий:

    [выражение for переменная in последовательность]

+ где переменная — имя некоторой переменной, 
+ последовательность — последовательность значений, которые она принимает (список, строка или объект, полученный при помощи функции range), 
+ выражение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка.

## Примеры использования списочных выражений

1. Создать список, заполненный 10 нулями можно и при помощи списочного выражения:
###
    zeros = [0 for i in range(10)]

2. Создать список, заполненный квадратами целых чисел от 0 до 9 можно так:
###
    squares = [i ** 2 for i in range(10)]

3. Создать список, заполненный кубами целых чисел от 10 до 20 можно так:
###
    cubes = [i ** 3 for i in range(10, 21)]

4. Создать список, заполненный символами строки:
###
    chars = [c for c in 'abcdefg']
    print(chars)

# Считывание входных данных

При решении многих задач из предыдущих уроков мы считывали начальные данные (строки, числа) и заполняли ими список. С помощью списочных выражений процесс заполнения списка можно заметно сократить.

Например, если сначала вводится число n – количество строк, а затем сами строки, то создать список можно так:

    n = int(input())
    lines = [input() for _ in range(n)]

Можно опустить описание переменной n:

    lines = [input() for _ in range(int(input()))]

Если требуется считать список чисел, то необходимо добавить преобразование типов:

    numbers = [int(input()) for _ in range(int(input()))]

Обратите внимание, мы используем символ _ в качестве имени переменной цикла, поскольку она не используется.

Списочные выражения часто используются для инициализации списков. В Python не принято создавать пустые списки, а затем заполнять их значениями, если можно этого избежать.

# Условия в списочном выражении

В списочных выражениях можно использовать условный оператор. Например, если требуется создать список четных чисел от 0 до 20, то мы можем написать такой код:

    evens = [i for i in range(21) if i % 2 == 0]

Важно: для того, чтобы получить список, состоящий из четных чисел, лучше использовать функцию range(0, 21, 2). Предыдущий пример приведен для демонстрации возможности использования условий в списочных выражениях.

# Вложенные циклы

В списочном выражении можно использовать вложенные циклы.

Следующий программный код:

    numbers = [i * j for i in range(1, 5) for j in range(2)]
    print(numbers)

выведет список:

    [0, 1, 0, 2, 0, 3, 0, 4]

Такой код равнозначен следующему:

    numbers = []

    for i in range(1, 5):
        for j in range(2):
            numbers.append(i * j)
    print(numbers)

# Подводя итог

Пусть word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six'].

    Списочное выражение	                    Результирующий список
    [0 for i in range(10)]	                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    [i ** 2 for i in range(1, 8)]	        [1, 4, 9, 16, 25, 36, 49]
    [i * 10 for i in numbers]	            [10, 140, 50, 90, 120]
    [c * 2 for c in word]	                ['HH', 'ee', 'll', 'll', 'oo']
    [m[0] for m in words]	                ['o', 't', 't', 'f', 'f', 's']
    [i for i in numbers if i < 10]	        [1, 5, 9]
    [m[0] for m in words if len(m) == 3]	['o', 't', 's']

# 11.8 Сортировка списков

## Тема урока: сортировка списков
1. Задача сортировки;
2. Сортировка пузырьком;
3. Сортировка выбором;
4. Сортировка простыми вставками.

Аннотация.  Задачи и способы (алгоритмы) сортировки списков.

# Задача сортировки

Задача сортировки списка заключается в перестановке его элементов так, чтобы они были упорядочены по возрастанию или убыванию. Это одна из основных задач программирования. Мы сталкиваемся с ней очень часто: при записи фамилий учеников в классном журнале, при подведении итогов соревнований и т.д.

# Алгоритмы сортировки

Алгоритм сортировки — это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:

+ время — основной параметр, характеризующий быстродействие алгоритма;
+ память — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.

Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.

# Основные алгоритмы сортировки

## Медленные:

+ Пузырьковая сортировка (Bubble sort);
+ Сортировка выбором (Selection sort);
+ Сортировка простыми вставками (Insertion sort).

Быстрые:

+ Сортировка Шелла (Shell sort);
+ Быстрая сортировка (Quick sort);
+ Сортировка слиянием (Merge sort);
+ Пирамидальная сортировка (Heap sort);
+ Сортировка TimSort (используется в Java и Python).

Большинство алгоритмов сортировки, в частности, указанные выше, основаны на сравнении двух элементов списка. 

Существуют однако алгоритмы не основанные на сравнениях. 

Такие алгоритмы как правило используют наперед заданные условия относительно элементов списка. 

Например, элементами списка являются натуральные или целые числа в некотором диапазоне, элементами являются строки и т.д.

К алгоритмам не основанным на сравнениях можно отнести следующие:

+ Сортировка подсчетом (Counting sort);
+ Блочная сортировка (Bucket sort);
+ Поразрядная сортировка (Radix sort).

В рамках курса мы рассмотрим несложные алгоритмы пузырьковой сортировки, сортировки выбором и сортировки простыми вставками.

## Примечания

### Примечание 1. 
Подробнее об алгоритмах сортировки можно почитать тут.
https://ru.wikipedia.org/wiki/Алгоритм_сортировки

### Примечание 2. 
Мы называем некоторые алгоритмы сортировки медленными, поскольку они тратят много времени на сортировку больших списков. Например, если список содержит порядка миллиона элементов, то такие алгоритмы тратят часы, а то и дни на выполнение сортировки, в то время как быстрые алгоритмы справляются с задачей за секунды.

### Примечание 3. 
Наглядную работу алгоритмов сортировки на разных входных данных можно посмотреть тут.
https://www.toptal.com/developers/sorting-algorithms

![Sort](/StepikPython/Python_Generation_for_beginners/pictures/031.png)

# Сортировка пузырьком

Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку. 

За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. 

Проходы по списку повторяются n − 1 раз, где n n – длина списка. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка ставится на свое место в конце списка рядом с предыдущим «наибольшим элементом».

Наибольший элемент каждый раз «всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма.

Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.

Рассмотрим работу алгоритма на примере сортировки списка a = [5, 1, 4, 2, 8] по возрастанию.

Первый проход:

    [5, 1, 4, 2, 8] → [1, 5, 4, 2, 8]: меняем местами первый и второй элементы, так как 5 > 15>1;
###
    [1, 5, 4, 2, 8] → [1, 4, 5, 2, 8]: меняем местами второй и третий элементы, так как 5 > 45>4;
###    
    [1, 4, 5, 2, 8] → [1, 4, 2, 5, 8]: меняем местами третий и четвертый элементы, так как 5 > 25>2;
###
    [1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]: не меняем четвертый и пятый элементы местами, так как 5 < 85<8;

Самый большой элемент встал («всплыл») на свое место.

Второй проход:

### 
    [1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]: не меняем первый и второй элементы местами, так как 1 < 41<4;
### 
    [1, 4, 2, 5, 8] → [1, 2, 4, 5, 8]: меняем местами второй и третий элементы, так как 4 > 24>2;
### 
    [1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем местами третий и четвертый элементы, так как 4 < 54 <5;

Второй по величине элемент встал («всплыл») на свое место.

Теперь список полностью отсортирован, но алгоритму это неизвестно и он работает дальше.

Третий проход:

    [1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем первый и второй элементы местами, так как 1 < 21<2;
###
    [1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем второй и третий элементы местами, так как 2 < 42 <4;

Третий по величине элемент встал («всплыл») на свое место. (на котором и был)

Четвертый проход:

    [1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]:

Четвертый по величине элемент встал («всплыл») на свое место.

Теперь список отсортирован и алгоритм может быть завершен.

# Реализация алгоритма
Пусть требуется отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99].

Следующий программный код реализует алгоритм пузырьковой сортировки:

    a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
    n = len(a)

    for i in range(n - 1):
        for j in range(n - i - 1):
            if a[j] > a[j + 1]:                  # если порядок элементов пары неправильный
                a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами 

    print('Отсортированный список:', a)

Результатом выполнения такого кода будет:

    Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]

# Оптимизация алгоритма
Алгоритм пузырьковой сортировки можно немного ускорить. Если на одном из очередных проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, то есть список отсортирован. Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания break.

# Сортировка выбором
Сортировка выбором улучшает пузырьковую сортировку, совершая всего один обмен за каждый проход по списку. Для этого алгоритм ищет максимальный элемент и помещает его на соответствующую позицию. Как и для пузырьковой сортировки, после первого прохода самый большой элемент находится на правильном месте. После второго прохода на своё место становится следующий максимальный элемент. Проходы по списку повторяются n−1 раз, где n – длина списка, поскольку последний из них автоматически оказывается на своем месте.

Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На практике используют более эффективные алгоритмы.

Рассмотрим работу алгоритма на примере сортировки списка a = [5, 1, 8, 2, 4] по возрастанию.

Первый проход:

Находим максимальный элемент 8 в неотсортированной части списка и меняем его с последним элементом списка:

    [5, 1, 4, 2, 8].

Второй проход:

Находим максимальный элемент 5 в неотсортированной части списка и меняем его с предпоследним элементом списка:

    [2, 1, 4, 5, 8].

Третий проход:

Находим максимальный элемент 4 в неотсортированной части списка и меняем его с пред-предпоследним элементом списка:

    [2, 1, 4, 5, 8].

Четвертый проход:

Находим максимальный элемент 2 в неотсортированной части списка и меняем его с вторым элементом списка:

    [1, 2, 4, 5, 8].

Теперь список отсортирован и алгоритм может быть завершен.

Вместо максимального элемента можно искать минимальный.

# Сортировка простыми вставками

Алгоритм сортировки простыми вставками делит список на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается очередной элемент и вставляется на нужную позицию, в результате чего отсортированная часть списка увеличивается, а неотсортированная уменьшается. Так происходит, пока не исчерпан набор входных данных  и не отсортированы все элементы.

Сортировка простыми вставками наиболее эффективна когда список уже частично отсортирован и элементов массива немного. Если элементов в списке меньше 10, то этот алгоритм — один из самых быстрых.

Рассмотрим его работу на примере сортировки списка a = [5, 1, 8, 2, 4] по возрастанию.

Первый проход:

Делим список на две части: отсортированную [5] и неотсортированную [1, 8, 2, 4].

Извлекаем первый элемент 1 из неотсортированной части списка и находим ему место в отсортированной части:

    [1, 5, 8, 2, 4].

Второй проход:

Делим список на две части: отсортированную [1, 5] и неотсортированную [8, 2, 4].

Извлекаем первый элемент 8 из неотсортированной части списка и находим ему место в отсортированной части:

    [1, 5, 8, 2, 4].

Третий проход:

Делим список на две части: отсортированную [1, 5, 8] и неотсортированную [2, 4].

Извлекаем первый элемент 2 из неотсортированной части списка и находим ему место в отсортированной части:

    [1, 2, 5, 8, 4].

Четвертый проход:

Делим список на две части: отсортированную [1, 2, 5, 8] и неотсортированную [4].

Извлекаем первый элемент 4 из неотсортированной части списка и находим ему место в отсортированной части:

    [1, 2, 4, 5, 8].

Теперь список отсортирован и алгоритм может быть завершен.

# Реализация алгоритма
Пусть требуется отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99].

Следующий программный код реализует алгоритм сортировки простыми вставками:

    a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
    n = len(a)

    for i in range(1, n): 
        elem = a[i]  # первый элемент из неотсортированной части списка
        j = i
        while j >= 1 and a[j - 1] > elem: 
            a[j] = a[j - 1]
            j -= 1
        a[j] = elem


    print('Отсортированный список:', a)
Результатом выполнения такого кода будет:

Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
## Оптимизация алгоритма

Алгоритм сортировки простыми вставками можно значительно ускорить, если осуществлять поиск нужной позиции для вставки очередного элемента из неотсортированной части списка с помощью бинарного поиска.
https://ru.wikipedia.org/wiki/Двоичный_поиск