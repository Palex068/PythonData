# 11  Списки

# Содержание

+ [Введение в списки](#111-введение-в-списки)
    + [Списки](#списки)
    + [Создание списка](#создание-списка)
    + [Пустой список](#пустой-список)
    + [Вывод списка](#вывод-списка)
    + [Встроенная функция list](#встроенная-функция-list)
+ [Основы работы со списками](#основы-работы-со-списками)
    + [Функция len()](#функция-len)
    + [Оператор принадлежности in](#оператор-принадлежности-in)
    + [Индексация](#индексация)
    + [Срезы](#срезы)
    + [Использование срезов для изменения элементов в заданном диапазоне](#использование-срезов-для-изменения-элементов-в-заданном-диапазоне)
    + [Операция конкатенации + и умножения на число *](#операция-конкатенации--и-умножения-на-число)
    + [Встроенные функции sum(), min(), max()](#встроенные-функции-sum-min-max)
    + [Отличие списков от строк](#отличие-списков-от-строк)
+ [Методы списков. Часть 1](#113-методы-списков-часть-1)
    + [Добавление элементов](#добавление-элементов)
        + [append()](#append)
        + [extend()](#extend)
    + [Удаление элементов](#удаление-элементов-del)
+ [Вывод элементов списка](#114-вывод-элементов-списка)
    + [Вывод с помощью цикла for](#вывод-с-помощью-цикла-for)
    + [Вывод с помощью распаковки списка](#вывод-с-помощью-распаковки-списка)
+ [Методы строк: split, join](#115-методы-строк-split-join)
    + [split()](#split)
    + [join()](#join)
    + [Примечания](#примечания-5)
+ [Методы списков. Часть 2](#116-методы-списков-часть-2)
    + [insert()](#insert)
    + [index()](#index)
    + [remove()](#remove)
    + [pop()](#pop)
    + [reverse()](#reverse)
    + [count()](#count)
    + [clear()](#clear)
    + [copy()](#copy)
    + [sort()](#sort)
    + [Примечания](#примечания-62)
+ [Списочные выражения](#117-списочные-выражения)
    + [Создание списков](#создание-списков)
    + [Списочные выражения (list comprehension)](#списочные-выражения)
    + [Примеры использования списочных выражений](#примеры-использования-списочных-выражений)
    + [Считывание входных данных](#считывание-входных-данных)
    + [Условия в списочном выражении](#условия-в-списочном-выражении)
    + [Вложенные циклы](#вложенные-циклы)
    + [Подводя итог](#подводя-итог)
+ [Сортировка списков](#118-сортировка-списков)
    + [Задача сортировки](#задача-сортировки)
    + [Основные алгоритмы сортировки](#основные-алгоритмы-сортировки)
    + [Сортировка пузырьком](#сортировка-пузырьком)
        + [Реализация алгоритма](#реализация-алгоритма-сортировка-пузырьком)
        + [Оптимизация алгоритма](#оптимизация-алгоритма-сортировка-пузырьком)
    + [Сортировка выбором](#сортировка-выбором)
    + [Сортировка простыми вставками](#сортировка-простыми-вставками)
        + [Реализация алгоритма](#реализация-алгоритма-сортировка-простыми-вставками)
        + [Оптимизация алгоритма](#оптимизация-алгоритма-сортировка-простыми-вставками)

[Содержание курса](/StepikPython/Python_Generation_for_beginners/README.MD)


# 11.1 Введение в списки

## Тема урока: введение в списки
1. Создание списков
2. Пустые списки
3. Встроенная функция list()
4. Вывод списков

Аннотация. Списки как сохранение последовательностей и аналог массивов. 

## Списки

В предыдущих уроках мы работали с последовательностями чисел, символов, строк, но не сохраняли всю последовательность в памяти компьютера, а обрабатывали ее поэлементно, считывая раз за разом новый элемент. Однако во многих задачах требуется __сохранять всю последовательность__. 

Например, классическая задача [сортировки](https://ru.wikipedia.org/wiki/Алгоритм_сортировки) (упорядочения) некоторой последовательности требует сохранения всех данных в памяти компьютера. Увы, не сохранив, их невозможно отсортировать. 

И тут на помощь приходит структура данных, которая в большинстве языков программирования называется [массивом](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). 

В Python она называется __списком__.

Структура данных (data structure) — программная единица, позволяющая __хранить и обрабатывать__ множество однотипных и/или логически связанных данных.

Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.

[Содержание](#содержание)

<hr>

## Создание списка

Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
```

Список numbers состоит из 5 элементов, и каждый из них — целое число.

```python
numbers[0] == 2;
numbers[1] == 4;
numbers[2] == 6;
numbers[3] == 8;
numbers[4] == 10.
```

Список languages состоит из 4 элементов, каждый из которых — __строка__.

```python
languages[0] == 'Python';
languages[1] == 'C#';
languages[2] == 'C++';
languages[3] == 'Java'.
```

Значения, заключенные в квадратные скобки и отделенные запятыми, называются __элементами списка__.

Список может содержать значения __разных типов данных__:

```python
info = ['Timur', 1992, 61.5]
```

Список info содержит строковое значение, целое число и число с плавающей точкой.

```python
info[0] == 'Timur';
info[1] == 1992;
info[2] == 61.5.
```

Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.

[Содержание](#содержание)

<hr>

## Пустой список

Создать пустой список можно двумя способами:

+ Использовать пустые квадратные скобки [];
+ Использовать встроенную функцию, которая называется list.

Следующие две строки кода создают пустой список:

```python
mylist = []       # пустой список
mylist = list()   # пустой список
```

[Содержание](#содержание)

<hr>

## Вывод списка

Для вывода всего списка можно применить функцию print():

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
print(numbers)
print(languages)
```

Функция print() выводит на экран элементы списка, в квадратных скобках, разделенные запятыми:

```python
[2, 4, 6, 8, 10]
['Python', 'C#', 'C++', 'Java']
```

Обратите внимание, что вывод списка содержит квадратные скобки. Позже мы научимся выводить элементы списка в более удобном виде с помощью циклов.

[Содержание](#содержание)

<hr>

## Встроенная функция list

Python имеет встроенную функцию list(), которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.

Например, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код:

```python
numbers = list(range(5))
```

Во время исполнения этого кода происходит следующее:

+ Вызывается функция range(), в которую в качестве аргумента передается число 5;
+ Эта функция возвращает последовательность чисел 0, 1, 2, 3, 4;
+ Последовательность чисел 0, 1, 2, 3, 4 передается в качестве аргумента в функцию list();
+ Функция list() возвращает список [0, 1, 2, 3, 4];
+ Список [0, 1, 2, 3, 4] присваивается переменной numbers.

Вот еще один пример:

```python
even_numbers = list(range(0, 10, 2))  # список содержит четные числа 0, 2, 4, 6, 8
odd_numbers = list(range(1, 10, 2))   # список содержит нечетные числа 1, 3, 5, 7, 9
```

Точно также с помощью функции list() мы можем создать список из символов строки.  Для преобразования строки в список мы пишем следующий код:

```python
s = 'abcde'
chars = list(s)  # список содержит символы 'a', 'b', 'c', 'd', 'e'
```

Во время исполнения этого кода происходит следующее:

+ Вызывается функция list(), в которую в качестве аргумента передается строка 'abcde';
+ Функция list() возвращает список ['a', 'b', 'c', 'd', 'e'];
+ Список ['a', 'b', 'c', 'd', 'e'] присваивается переменной chars.

[Содержание](#содержание)

<hr>

## Примечания 1

### Примечание 1. 
Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.

### Примечание 2. 
Обратите внимание, при выводе содержимого списка с помощью функции print(), все строковые элементы списка обрамляются __одинарными кавычками__. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.

[Содержание](#содержание)

<hr>

# 11.2 Основы работы со списками

## Тема урока: основы работы со списками
1. Встроенные функции len(),sum(),min(),max()
2. Оператор принадлежности in
3. Индексация и срезы
4. Конкатенация и умножение на число
5. Отличие списков от строк

Аннотация. Начинаем работать со списками.

## Основы работы со списками

Работа со списками очень сильно напоминает работу со строками, поскольку и списки, и строки содержат отдельные элементы: элементы списка могут иметь произвольный тип, а элементами строк всегда являются символы. Многое из того, что мы делали со строками, доступно и при работе со списками.

## Функция len()

__Длиной списка__ называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию len() (от слова length – длина).

Следующий программный код:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

print(len(numbers))      # выводим длину списка numbers
print(len(languages))    # выводим длину списка languages

print(len(['apple', 'banana', 'cherry']))   # выводим длину списка, состоящего из 3 элементов
```

выведет:

```python
5
4
3
```

[Содержание](#содержание)

<hr>

## Оператор принадлежности in

Оператор in позволяет проверить, содержит ли список некоторый элемент.

Рассмотрим следующий код:

```python
numbers = [2, 4, 6, 8, 10]

if 2 in numbers:
    print('Список numbers содержит число 2')
else:
    print('Список numbers не содержит число 2')
```

Такой код проверяет, содержит ли список numbers число 2 и выводит соответствующий текст:

```python
Список numbers содержит число 2
```

Мы можем использовать оператор in вместе с логическим оператором not. 

Например

```python
numbers = [2, 4, 6, 8, 10]

if 0 not in numbers:
    print('Список numbers не содержит нулей')
```

[Содержание](#содержание)

<hr>

## Индексация

При работе со строками мы использовали __индексацию__, то есть обращение к конкретному символу строки по его индексу. Аналогично, можно индексировать и списки.

Для индексации списков в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного элемента в списке:

Пусть numbers = [2, 4, 6, 8, 10].

Таблица ниже, показывает как работает индексация:

|    Выражение	| Результат |	Пояснение |
|---------------|-----------|-------------|
|    numbers[0] |	    2	|    первый элемент списка |
|    numbers[1] |	    4	|    второй элемент списка |
|    numbers[2] |	    6	|    третий элемент списка |
|    numbers[3] |	    8	|    четвертый элемент списка |
|    numbers[4] |	    10  | 	 пятый элемент списка |

Обратите внимание первый элемент списка numbers[0], а не numbers[1]. 

Так же, как и в строках, для нумерации с конца разрешены отрицательные индексы.

|    Выражение   | Результат |	Пояснение   |
|----------------|-----------|-------------|
|    numbers[-1] |	    10   | пятый элемент списка    |
|    numbers[-2] |	    8    | четвертый элемент списка    |
|    numbers[-3] |	    6    | третий элемент списка   |
|    numbers[-4] |	    4    | второй элемент списка   |
|    numbers[-5] |	    2    | первый элемент списка   |

Как и в строках, попытка обратиться к элементу списка по несуществующему индексу:

```python
print(numbers[17])
```

вызовет ошибку:

```python
IndexError: index out of range
```

[Содержание](#содержание)

<hr>

## Срезы

Рассмотрим список numbers = [2, 4, 6, 8, 10].

С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием numbers[x:y].

Следующий программный код:

```python
print(numbers[1:3])
print(numbers[2:5])
```

выводит:

```python
[4, 6]
[6, 8, 10]
```

При построении среза numbers[x:y] первое число – это то место, где начинается срез (__включительно__), а второе – это место, где заканчивается срез (__невключительно__). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного.

При использовании срезов со списками мы также можем опускать второй параметр в срезе numbers[x:] (но поставить двоеточие), тогда срез берется до конца списка. Аналогично если опустить первый параметр numbers[:y], то можно взять срез от начала списка.

Срез numbers[:] возвращает копию исходного списка.

Как и в строках, мы можем использовать отрицательные индексы в срезах списков.

[Содержание](#содержание)

<hr>

## Использование срезов для изменения элементов в заданном диапазоне

Для изменения целого диапазона элементов списка можно использовать срезы. Например, если мы хотим перевести на русский язык названия фруктов 'banana', 'cherry', 'kiwi', то это можно сделать с помощью среза.

Следующий программный код:

```python
fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
fruits[2:5] = ['банан', 'вишня', 'киви']

print(fruits)
```

выводит:

```python
['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']
```

[Содержание](#содержание)

<hr>

## Операция конкатенации + и умножения на число *

Мы можем применять операторы + и * для списков подобно тому как мы это делали со строками.

Следующий программный код:

```python
print([1, 2, 3, 4] + [5, 6, 7, 8])
print([7, 8] * 3)
print([0] * 10)
```

выводит:

```python
[1, 2, 3, 4, 5, 6, 7, 8]
[7, 8, 7, 8, 7, 8]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Для генерации списков, состоящих строго из повторяющихся элементов, умножение на число — самый короткий и правильный метод.

Мы также можем использовать расширенные операторы += и *= при работе со списками.

Следующий программный код:

```python
a = [1, 2, 3, 4]
b = [7, 8]
a += b   # добавляем к списку a список b
b *= 5   # повторяем список b 5 раз 

print(a)
print(b)
```

выводит:

```python
[1, 2, 3, 4, 7, 8]
[7, 8, 7, 8, 7, 8, 7, 8, 7, 8]
```

[Содержание](#содержание)

<hr>

## Встроенные функции sum(), min(), max()

Встроенная функция sum() принимает в качестве параметра список чисел и вычисляет сумму его элементов.

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print('Сумма всех элементов списка =', sum(numbers))
```

выводит:

```python
Сумма всех элементов списка = 55
```

Встроенные функции min() и max() принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.

Следующий программный код:

```python
numbers = [3, 4, 10, 3333, 12, -7, -5, 4]
print('Минимальный элемент =', min(numbers))
print('Максимальный элемент =', max(numbers))
```

выводит:

```python
Минимальный элемент = -7
Максимальный элемент = 3333
```

[Содержание](#содержание)

<hr>

## Отличие списков от строк

Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.

Следующий программный код:

```python
s = 'abcdefg'
s[1] = 'x'    # пытаемся изменить 2 символ (по индексу 1) строки 
```

приводит к ошибке:

```python
object does not support item assignment
```

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7]
numbers[1] = 101     # изменяем 2 элемент (по индексу 1) списка
print(numbers)
```

выводит:

```python
[1, 101, 3, 4, 5, 6, 7]
```

Запомни: изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания.

[Содержание](#содержание)

<hr>

# 11.3 Методы списков. Часть 1

## Тема урока: методы добавления и удаления элементов
1. Метод добавления элемента append()
2. Метод расширения списка extend()
3. Оператор del
4. Решение задач

Аннотация. Добавление элементов в список. Оператор del, удаляющий элементы по заданному индексу.

## Добавление элементов
Мы научились создавать статические списки, то есть списки, элементы которых известны на этапе создания. Следующий шаг – научиться добавлять элементы в уже существующие списки.

### append()

Для добавления нового элемента в __конец списка__ используется метод append().

Следующий программный код:

```python
numbers = [1, 1, 2, 3, 5, 8, 13]  # создаем список

numbers.append(21)  # добавляем число 21 в конец списка
numbers.append(34)  # добавляем число 34 в конец списка

print(numbers)
```

выведет:

```python
[1, 1, 2, 3, 5, 8, 13, 21, 34]
```

Обратите внимание, для того чтобы использовать метод append(), нужно, чтобы список был создан, при этом он может быть пустым.

Следующий программный код:

```python
numbers = []  # создаем пустой список

numbers.append(1)
numbers.append(2)
numbers.append(3)

print(numbers)
```

выведет:

```python
[1, 2, 3]
```

Важно: мы не можем использовать индексаторы для установки значений элементов списка, если список пустой. Следующий программный код:

```python
numbers = []  # создаем пустой список

numbers[0] = 1
numbers[1] = 2
numbers[2] = 3

print(numbers)
```

приводит к ошибке:

```python
IndexError: list assignment index out of range
```

[Содержание](#содержание)

<hr>

### extend()

Можно также расширить список другим списком, путем вызова метода extend().

Следующий программный код:

```python
numbers = [0, 2, 4, 6, 8, 10]
odds = [1, 3, 5, 7]

numbers.extend(odds)
print(numbers)
```

выведет:

```python
[0, 2, 4, 6, 8, 10, 1, 3, 5, 7]
```

Метод extend() как бы расширяет один список, добавляя к нему элементы другого списка.

Отличие между методами append() и extend() проявляется при добавлении строки к списку.

Следующий программный код:

```python
words1 = ['iq option', 'stepik', 'beegeek']
words2 = ['iq option', 'stepik', 'beegeek']

words1.append('python')
words2.extend('python')

print(words1)
print(words2)
```

выведет:

```python
['iq option', 'stepik', 'beegeek', 'python']
['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']
```

Метод:
+ append() добавляет строку 'python' целиком к списку, а метод 
+ extend() разбивает строку 'python' на  символы 'p', 'y', 't', 'h', 'o', 'n' и их добавляет в качестве элементов списка. 

[Содержание](#содержание)

<hr>

## Удаление элементов del

С помощью оператора del можно удалять элементы списка по определенному индексу.

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[5]    # удаляем элемент имеющий индекс 5

print(numbers)
```

выведет:

```python
[1, 2, 3, 4, 5, 7, 8, 9]
```

Элемент под указанным индексом удаляется, а список перестраивается.

Обратите внимание на синтаксис удаления, так как он отличается от обычного вызова метода. При удалении элементов не надо передавать аргумент внутри круглых скобок.

Оператор del работает и со срезами: мы можем удалить целый диапазон элементов списка.

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[2:7]    # удаляем элементы с 2 по 6 включительно

print(numbers)
```

выведет:

```python
[1, 2, 8, 9]
```

Мы можем удалить все элементы на четных позициях (0, 2, 4, ...) исходного списка.

Следующий программный код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[::2]

print(numbers)
```

выведет:

```python
[2, 4, 6, 8]
```

[Содержание](#содержание)

<hr>

# 11.4 Вывод элементов списка

## Вывод элементов списка

При выводе содержимого списка с помощью функции print()  вывод элементов осуществляется в квадратных скобках, причем все элементы разделены запятой. Такой вывод не всегда удобен и предпочтителен, поэтому нужно уметь выводить элементы списка нужным нам способом.

## Вывод с помощью цикла for

Для вывода элементов списка __каждого на отдельной__ строке можно использовать следующий код:

Вариант 1. Если нужны индексы элементов:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for i in range(len(numbers)):
    print(numbers[i])
```

Мы передаем в функцию range() длину списка len(numbers). В нашем случае длина списка numbers, равна 11. Таким образом вызов функции range(len(numbers)) имеет вид range(11) и переменная цикла i последовательно перебирает все значения от 0 до 10. Это означает, что выражение numbers[i] последовательно вернет все элементы списка numbers. Такой способ итерации списка удобен, когда нам нужен не только сам элемент numbers[i], но и его индекс i.

Вариант 2. Если индексы не нужны:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num)
```

Этот цикл пройдет по списку numbers, придавая переменной цикла num значение каждого элемента списка (!) в отличие от предыдущего цикла, в котором переменная цикла «бегала» по индексам списка.

Если требуется выводить  элементы списка на одной строке, через пробел, то мы можем использовать необязательный параметр end функции print():

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num, end=' ')
```

[Содержание](#содержание)

<hr>

## Вывод с помощью распаковки списка

В Python есть удобный способ вывода элементов списка без использования цикла for.

Вариант 1. Вывод элементов списка через один символ пробела:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers)
```

Такой код выведет:

```python
0 1 2 3 4 5 6 7 8 9 10
```

Вариант 2. Вывод элементов списка, каждого на отдельной строке

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers, sep='\n')
```

Такой код выведет:

```python
0
1
2
3
4
5
6
7
8
9
10
```

Поскольку строки содержат символы, подобно тому, как списки содержат элементы, то мы можем использовать распаковку строк точно так же, как и распаковку списков. 

Такой код:

```python
s = 'Python'

print(*s)
print()
print(*s, sep='\n')
```

выведет:

```python
P y t h o n

P
y
t
h
o
n
```

[Содержание](#содержание)

<hr>

# 11.5 Методы строк: split, join

## Тема урока: строковые методы
1. Метод [split()](#split)
2. Метод [join()](#join)

Аннотация. Строковые методы split() и join().

В предыдущем модуле мы детально изучили основные строковые методы, однако обошли стороной два важных: split() и join(), имеющих отношение к спискам. Они как бы противоположны по смыслу: метод split() разбивает строку по произвольному разделителю на список слов, а метод join() собирает строку из списка слов через заданный разделитель.

## split()

Метод split() разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов.

Следующий программный код:

```python
s = 'Python is the most powerful language'
words = s.split()
print(words)
```

выведет: 

```python
['Python', 'is', 'the', 'most', 'powerful', 'language']
```

![split()](/StepikPython/Python_Generation_for_beginners/pictures/028.png)

Таким образом, вызов метода split() разбивает строку на слова и возвращает список, содержащий все слова.

Рассмотрим следующий программный код:

```python
numbers = input().split()
```

Если при запуске этой программы ввести строку 1 2 3 4 5, то список numbers будет следующим  ['1', '2', '3', '4', '5']. Обратите внимание, что список будет состоять из строк, а не из чисел. Если требуется получить именно список чисел, то затем нужно элементы списка по одному преобразовать в числа:

```python
numbers = input().split()
for i in range(len(numbers)):
    numbers[i] = int(numbers[i])
```

Необязательный параметр

У метода split() есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. Например, вызов метода split('.') вернет список, полученный разделением исходной строки по символу '.'.

Следующий программный код:

```python
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)
```

выведет список:

```python
['192', '168', '1', '24']
```

![split()](/StepikPython/Python_Generation_for_beginners/pictures/029.png)

[Содержание](#содержание)

<hr>

## join()

Метод join() собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.

Следующий программный код:

```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)
```

выведет: 

```python
Python is the most powerful language
```

![join()](/StepikPython/Python_Generation_for_beginners/pictures/030.png)

Обратите внимание, все слова разделены одним пробелом, поскольку метод join() вызывался на строке состоящей из одного символа пробела ' '.

Рассмотрим еще пару примеров:

```python
words = ['Мы', 'учим', 'язык', 'Python']
print('*'.join(words))
print('-'.join(words))
print('?'.join(words))
print('!'.join(words))
print('*****'.join(words))
print('abc'.join(words))
print('123'.join(words))
```

Результатом выполнения такого кода будет:

```python
Мы*учим*язык*Python
Мы-учим-язык-Python
Мы?учим?язык?Python
Мы!учим!язык!Python
Мы*****учим*****язык*****Python
МыabcучимabcязыкabcPython
Мы123учим123язык123Python
```

Запомни: Строковый метод split() служит для преобразования строки в список, а метод join() — для преобразования списка в строку.

## Примечания 5
### Примечание 1. 

Существует большая разница между результатами вызова методов s.split() и s.split(' '). Разница в поведении проявляется когда строка содержит несколько пробелов между словами.

Следующий программный код:

```python
s = 'Python    is   the  most  powerful  language'
words1 = s.split()
words2 = s.split(' ')
print(words1)
print(words2)
```

выведет списки:

```python
['Python', 'is', 'the', 'most', 'powerful', 'language']
['Python', '', '', '', 'is', '', '', 'the', '', 'most', '', 'powerful', '', 'language']
```

### Примечание 2. 

Методы split() и join() являются строковыми методами. Следующий код приводит к ошибке:

```python
print([1, 2].split())
print([1, 2].join([3, 4, 5]))
```

### Примечание 3. 

Строковый метод join() работает только со списком строк. Следующий код приводит к ошибке:

```python
numbers = [1, 2, 3, 4]  # список чисел
s = '*'.join(numbers)
print(s)
```

[Содержание](#содержание)

<hr>

# 11.6 Методы списков. Часть 2

## Тема урока: методы списков
1. Метод [insert()](#insert)
2. Метод [index()](#index)
3. Метод [remove()](#remove)
4. Метод [pop()](#pop)
5. Метод [reverse()](#reverse)
6. Метод [count()](#count)
7. Метод [clear()](#clear)
8. Метод [copy()](#copy)
9. Метод [sort()](#sort)

Аннотация. Другие методы списков.

Мы уже познакомились с двумя списочными методами append() и extend(). Первый добавляет в конец списка один новый элемент, а второй расширяет список другим списком. К спискам в Python применимы и другие удобные методы, с которыми мы познакомимся в этом уроке.

## insert()

Метод `insert()` позволяет вставлять значение в список в заданной позиции. В него передается два аргумента:

1. index: индекс, задающий место вставки значения;
2. value: значение, которое требуется вставить.

Когда значение вставляется в список, список расширяется в размере, чтобы разместить новое значение. Значение, которое ранее находилось в заданной индексной позиции, и все элементы после него сдвигаются на одну позицию к концу списка.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
print(names)
names.insert(0, 'Anders')
print(names)
names.insert(3, 'Josef')
print(names)
``` 

выведет:

```python
['Gvido', 'Roman' , 'Timur']
['Anders', 'Gvido', 'Roman' , 'Timur']
['Anders', 'Gvido', 'Roman' , 'Josef', 'Timur']
```

Если указан недопустимый индекс, то во время выполнения программы не происходит ошибки. Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка. Если применен отрицательный индекс, который указывает на недопустимую позицию, то значение будет вставлено в начало списка.

[Содержание](#содержание)

<hr>

##  index()

Метод index() возвращает индекс первого элемента, значение которого равняется переданному в метод значению. Таким образом, в метод передается один параметр:

1. value: значение, индекс которого требуется найти.

Если элемент в списке не найден, то во время выполнения происходит ошибка.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
position = names.index('Timur')
print(position)
```

выведет:

```python
2
```

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
position = names.index('Anders')
print(position)
```

приводит к ошибке:

```python
ValueError: 'Anders' is not in list
```

Чтобы избежать таких ошибок, можно использовать метод index() вместе с оператором принадлежности in:

```python
names = ['Gvido', 'Roman' , 'Timur']
if 'Anders' in names:
    position = names.index('Anders')
    print(position)
else:
    print('Такого значения нет в списке')
```

[Содержание](#содержание)

<hr>

## remove()

Метод remove() удаляет первый элемент, значение которого равняется переданному в метод значению. В метод передается один параметр:

1. value: значение, которое требуется удалить.

Метод уменьшает размер списка на один элемент. Все элементы после удаленного элемента смещаются на одну позицию к началу списка. Если элемент в списке не найден, то во время выполнения происходит ошибка.

Следующий программный код:

```python
food = ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
print(food)
food.remove('Рис')
print(food)
```

выведет:

```python
['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
['Курица', 'Рыба', 'Брокколи', 'Рис']
```

Важно: метод `remove()` удаляет только первый элемент с указанным значением. Все последующие его вхождения остаются в списке. Чтобы удалить все вхождения нужно использовать цикл `while` в связке с оператором принадлежности `in` и методом remove.

[Содержание](#содержание)

<hr>

## pop()

Метод pop() удаляет элемент по указанному индексу и возвращает его. В метод pop() передается один необязательный аргумент:

1. index: индекс элемента, который требуется удалить.

Если индекс не указан, то метод удаляет и возвращает последний элемент списка. Если список пуст или указан индекс за пределами диапазона, то во время выполнения происходит ошибка.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
item = names.pop(1)
print(item)
print(names)
```

выведет:

```python
Roman
['Gvido', 'Timur']
```

## count()

Метод count() возвращает количество элементов в списке, значения которых равны переданному в метод значению. 

Таким образом, в метод передается один параметр:

1. value: значение, количество элементов, равных которому,  нужно посчитать.

Если значение в списке не найдено, то метод возвращает 0.

Следующий программный код:

```python
names = ['Timur', 'Gvido', 'Roman', 'Timur', 'Anders', 'Timur']
cnt1 = names.count('Timur')
cnt2 = names.count('Gvido')
cnt3 = names.count('Josef')

print(cnt1)
print(cnt2)
print(cnt3)
```

выведет:

```python
3
1
0
```

## reverse()

Метод reverse() инвертирует порядок следования значений в списке, то есть меняет его на противоположный.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
names.reverse()
print(names)
```

выведет:

```python
['Timur', 'Roman', 'Gvido']
```

Существует большая разница между вызовом метода names.reverse() и использованием среза names[::-1]. Метод reverse() меняет порядок элементов на обратный в текущем списке, а срез создает копию списка, в котором элементы следуют в обратном порядке.

## clear()

Метод clear() удаляет все элементы из списка.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
names.clear()
print(names)
```

выведет:

```python
[]
```

## copy()

Метод copy() создает поверхностную копию списка.

Следующий программный код:

```python
names = ['Gvido', 'Roman' , 'Timur']
names_copy = names.copy()              # создаем поверхностную копию списка names

print(names)
print(names_copy)
```

выведет:

```python
['Gvido', 'Roman', 'Timur']
['Gvido', 'Roman', 'Timur']
```

Аналогичного результата можно достичь с помощью срезов или функции list():

```python
names = ['Gvido', 'Roman' , 'Timur']
names_copy1 = list(names)             # создаем поверхностную копию с помощью функции list()
names_copy2 = names[:]                # создаем поверхностную копию с помощью среза от начала до конца
```

[Содержание](#содержание)

<hr>

## Примечания 6

### Примечание. 

Существует большая разница в работе строковых и списочных методов. Строковые методы не изменяют содержимого объекта к которому они применяются, а возвращают новое значение. Списочные методы, напротив, меняют содержимое объекта к которому применяются.

[Содержание](#содержание)

<hr>

## sort()
Метод sort()

В Python списки имеют встроенный метод sort(), который сортирует элементы списка по возрастанию или убыванию.

Следующий программный код:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort()
print('Отсортированный список:', a)
```

выведет:

```python
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

По умолчанию метод sort() сортирует список по возрастанию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр reverse = True.

Следующий программный код:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort(reverse = True)   # сортируем по убыванию
print('Отсортированный список:', a)
```

выведет:
```python
Отсортированный список: [1000, 99, 45, 34, 12, 9, 8, 7, 6, 1, 0, -2, -3, -67]
```

[Содержание](#содержание)

<hr>

## Примечания 6.2

### Примечание 1. 

С помощью метода sort() можно сортировать списки содержащие не только числа, но и строки. В таком случае элементы списка сортируются в соответствии с [лексикографическим порядком](https://ru.wikipedia.org/wiki/Лексикографический_порядок).

Следующий программный код:

```python
a = ['бета', 'альфа', 'дельта', 'гамма']
a.sort()
print ('Отсортированный список:', a)
```

выведет:

```python
Отсортированный список: ['альфа', 'бета', 'гамма', 'дельта']
```

### Примечание 2. 
Метод sort() использует алгоритм [Timsort](https://ru.wikipedia.org/wiki/Timsort)

[Содержание](#содержание)

<hr>

# 11.7 Списочные выражения

## Тема урока: списочные выражения
1. Списочные выражения
2. Решение задач

Аннотация. Списочные выражения. Создание списков без явного использования циклов и вызова списочного метода append().

## Создание списков

Для того, чтобы создать список состоящий из 10 нулей мы можем использовать следующий код:

```python
zeros = []
for i in range(10):
    zeros.append(0)
```

В Python, однако есть более простой и компактный способ для создания такого списка. Мы можем использовать оператор умножения списка на число:

```python
zeros = [0] * 10
```

Для создания списков, заполненных по более сложным правилам нам приходится явно использовать цикл for.

Например, для создания списка целых чисел от 00 до 99, мы вынуждены писать такой код:

```python
numbers = []
for i in range(10):
    numbers.append(i)
```

Такой код хоть и не является сложным, однако достаточно громоздок.

[Содержание](#содержание)

<hr>

## Списочные выражения

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — списочное выражение (list comprehension).

Предыдущий код можно записать следующим образом:

```python
numbers = [i for i in range(10)]
```

Общий вид списочного выражения следующий:

>[выражение for переменная in последовательность]

+ где переменная — имя некоторой переменной, 
+ последовательность — последовательность значений, которые она принимает (список, строка или объект, полученный при помощи функции range), 
+ выражение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка.

[Содержание](#содержание)

<hr>

## Примеры использования списочных выражений

1. Создать список, заполненный 10 нулями можно и при помощи списочного выражения:

```python
zeros = [0 for i in range(10)]
```

2. Создать список, заполненный квадратами целых чисел от 0 до 9 можно так:
```python
squares = [i ** 2 for i in range(10)]
```

3. Создать список, заполненный кубами целых чисел от 10 до 20 можно так:

```python
cubes = [i ** 3 for i in range(10, 21)]
```

4. Создать список, заполненный символами строки:
```python
chars = [c for c in 'abcdefg']
print(chars)
```

[Содержание](#содержание)

<hr>

## Считывание входных данных

При решении многих задач из предыдущих уроков мы считывали начальные данные (строки, числа) и заполняли ими список. С помощью списочных выражений процесс заполнения списка можно заметно сократить.

Например, если сначала вводится число n – количество строк, а затем сами строки, то создать список можно так:

```python
n = int(input())
lines = [input() for _ in range(n)]
```

Можно опустить описание переменной n:

```python
lines = [input() for _ in range(int(input()))]
```

Если требуется считать список чисел, то необходимо добавить преобразование типов:

```python
numbers = [int(input()) for _ in range(int(input()))]
```

Обратите внимание, мы используем символ _ в качестве имени переменной цикла, поскольку она не используется.

Списочные выражения часто используются для инициализации списков. В Python не принято создавать пустые списки, а затем заполнять их значениями, если можно этого избежать.

[Содержание](#содержание)

<hr>

## Условия в списочном выражении

В списочных выражениях можно использовать условный оператор. Например, если требуется создать список четных чисел от 0 до 20, то мы можем написать такой код:

```python
evens = [i for i in range(21) if i % 2 == 0]
```

Важно: для того, чтобы получить список, состоящий из четных чисел, лучше использовать функцию range(0, 21, 2). Предыдущий пример приведен для демонстрации возможности использования условий в списочных выражениях.

[Содержание](#содержание)

<hr>

## Вложенные циклы

В списочном выражении можно использовать вложенные циклы.

Следующий программный код:

```python
numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)
```

выведет список:

```python
[0, 1, 0, 2, 0, 3, 0, 4]
```

Такой код равнозначен следующему:

```python
numbers = []

for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)
```

[Содержание](#содержание)

<hr>

## Подводя итог

Пусть 
>word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six'].

|    Списочное выражение	           |     Результирующий список      |
|--------------------------------------|--------------------------------|
| [0 for i in range(10)]	           | [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] |
| [i ** 2 for i in range(1, 8)]	       | [1, 4, 9, 16, 25, 36, 49]      |
| [i * 10 for i in numbers]	           | [10, 140, 50, 90, 120]         |
| [c * 2 for c in word]	               | ['HH', 'ee', 'll', 'll', 'oo'] |
| [m[0] for m in words]	               | ['o', 't', 't', 'f', 'f', 's'] |
| [i for i in numbers if i < 10]	   | [1, 5, 9]                      |
| [m[0] for m in words if len(m) == 3] | ['o', 't', 's']                |

[Содержание](#содержание)

<hr>

# 11.8 Сортировка списков

## Тема урока: сортировка списков
1. Задача сортировки;
2. Сортировка пузырьком;
3. Сортировка выбором;
4. Сортировка простыми вставками.

Аннотация.  Задачи и способы (алгоритмы) сортировки списков.

## Задача сортировки

Задача сортировки списка заключается в перестановке его элементов так, чтобы они были упорядочены по возрастанию или убыванию. Это одна из основных задач программирования. Мы сталкиваемся с ней очень часто: при записи фамилий учеников в классном журнале, при подведении итогов соревнований и т.д.

[Содержание](#содержание)

<hr>

## Алгоритмы сортировки

Алгоритм сортировки — это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:

+ время — основной параметр, характеризующий быстродействие алгоритма;
+ память — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.

Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.

[Содержание](#содержание)

<hr>

## Основные алгоритмы сортировки

### Медленные:

+ Пузырьковая сортировка (Bubble sort);
+ Сортировка выбором (Selection sort);
+ Сортировка простыми вставками (Insertion sort).

### Быстрые:

+ Сортировка Шелла (Shell sort);
+ Быстрая сортировка (Quick sort);
+ Сортировка слиянием (Merge sort);
+ Пирамидальная сортировка (Heap sort);
+ Сортировка TimSort (используется в Java и Python).

Большинство алгоритмов сортировки, в частности, указанные выше, основаны на сравнении двух элементов списка. 

Существуют однако алгоритмы не основанные на сравнениях. 

Такие алгоритмы как правило используют наперед заданные условия относительно элементов списка. 

Например, элементами списка являются натуральные или целые числа в некотором диапазоне, элементами являются строки и т.д.

К алгоритмам не основанным на сравнениях можно отнести следующие:

+ Сортировка подсчетом (Counting sort);
+ Блочная сортировка (Bucket sort);
+ Поразрядная сортировка (Radix sort).

В рамках курса мы рассмотрим несложные алгоритмы пузырьковой сортировки, сортировки выбором и сортировки простыми вставками.

## Примечания 8

### Примечание 1. 
Подробнее об алгоритмах сортировки можно почитать [тут](https://ru.wikipedia.org/wiki/Алгоритм_сортировки).


### Примечание 2. 
Мы называем некоторые алгоритмы сортировки __медленными__, поскольку они тратят много времени на сортировку больших списков. Например, если список содержит порядка миллиона элементов, то такие алгоритмы тратят часы, а то и дни на выполнение сортировки, в то время как быстрые алгоритмы справляются с задачей за секунды.

### Примечание 3. 
Наглядную работу алгоритмов сортировки на разных входных данных можно посмотреть [тут](https://www.toptal.com/developers/sorting-algorithms).


![Sort](/StepikPython/Python_Generation_for_beginners/pictures/031.png)

[Содержание](#содержание)

<hr>

## Сортировка пузырьком

Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку. 

За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. 

Проходы по списку повторяются n − 1 раз, где n n – длина списка. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка ставится на свое место в конце списка рядом с предыдущим «наибольшим элементом».

Наибольший элемент каждый раз «всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма.

Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.

Рассмотрим работу алгоритма на примере сортировки списка a = [5, 1, 4, 2, 8] по возрастанию.

Первый проход:

>$[5, 1, 4, 2, 8] → [1, 5, 4, 2, 8]$: меняем местами первый и второй элементы, так как $5 > 1$;<br>
>$[1, 5, 4, 2, 8] → [1, 4, 5, 2, 8]$: меняем местами второй и третий элементы, так как $5 > 4$;<br>
>$[1, 4, 5, 2, 8] → [1, 4, 2, 5, 8]$: меняем местами третий и четвертый элементы, так как $5 > 2$;<br>
>$[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]$: не меняем четвертый и пятый элементы местами, так как $5 < 8$; 


Самый большой элемент встал («всплыл») на свое место.

Второй проход:

>$[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]$: не меняем первый и второй элементы местами, так как $1 < 4$;<br>
>$[1, 4, 2, 5, 8] → [1, 2, 4, 5, 8]$: меняем местами второй и третий элементы, так как $4 > 2$;<br>
>$[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]$: не меняем местами третий и четвертый элементы, так как $4 < 5$;<br>

Второй по величине элемент встал («всплыл») на свое место.

Теперь список полностью отсортирован, но алгоритму это неизвестно и он работает дальше.

Третий проход:

>$[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]$: не меняем первый и второй элементы местами, так как $1 < 2$;<br>
>$[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]$: не меняем второй и третий элементы местами, так как $2 < 4$;<br>

Третий по величине элемент встал («всплыл») на свое место. (на котором и был)

Четвертый проход:

>$[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]$:

Четвертый по величине элемент встал («всплыл») на свое место.

Теперь список отсортирован и алгоритм может быть завершен.

[Содержание](#содержание)

<hr>

### Реализация алгоритма Сортировка пузырьком
Пусть требуется отсортировать по возрастанию список чисел: 

>a = $[1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]$.

Следующий программный код реализует алгоритм пузырьковой сортировки:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(n - 1):
    for j in range(n - i - 1):
        if a[j] > a[j + 1]:      # если порядок элементов пары неправильный
            a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами 

print('Отсортированный список:', a)
```

Результатом выполнения такого кода будет:

```python
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

### Оптимизация алгоритма Сортировка пузырьком
Алгоритм пузырьковой сортировки можно немного ускорить. Если на одном из очередных проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, то есть список отсортирован. Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания break.

[Содержание](#содержание)

<hr>

## Сортировка выбором

Сортировка выбором улучшает пузырьковую сортировку, совершая всего __один обмен за каждый проход по списку__. Для этого алгоритм ищет максимальный элемент и помещает его на соответствующую позицию. Как и для пузырьковой сортировки, после первого прохода самый большой элемент находится на правильном месте. После второго прохода на своё место становится следующий максимальный элемент. Проходы по списку повторяются n−1 раз, где n – длина списка, поскольку последний из них автоматически оказывается на своем месте.

Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На практике используют более эффективные алгоритмы.

Рассмотрим работу алгоритма на примере сортировки списка 

>a = $[5, 1, 8, 2, 4]$ по возрастанию.

__Первый проход:__

Находим максимальный элемент 8 в неотсортированной части списка и меняем его с последним элементом списка:

>$[5, 1, 4, 2, 8]$.

Второй проход:

Находим максимальный элемент 5 в неотсортированной части списка и меняем его с предпоследним элементом списка:

>$[2, 1, 4, 5, 8]$.

Третий проход:

Находим максимальный элемент 4 в неотсортированной части списка и меняем его с пред-предпоследним элементом списка:

>$[2, 1, 4, 5, 8]$.

Четвертый проход:

Находим максимальный элемент 2 в неотсортированной части списка и меняем его с вторым элементом списка:

>$[1, 2, 4, 5, 8]$.

Теперь список отсортирован и алгоритм может быть завершен.

Вместо максимального элемента можно искать минимальный.

[Содержание](#содержание)

<hr>

# Сортировка простыми вставками

Алгоритм сортировки простыми вставками делит список на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается очередной элемент и вставляется на нужную позицию, в результате чего отсортированная часть списка увеличивается, а неотсортированная уменьшается. Так происходит, пока не исчерпан набор входных данных  и не отсортированы все элементы.

Сортировка простыми вставками наиболее эффективна когда список уже частично отсортирован и элементов массива немного. Если элементов в списке меньше 10, то этот алгоритм — один из самых быстрых.

Рассмотрим его работу на примере сортировки списка 

>a = $[5, 1, 8, 2, 4]$ по возрастанию.

Первый проход:

Делим список на две части: отсортированную $[5]$ и неотсортированную $[1, 8, 2, 4]$.

Извлекаем первый элемент $1$ из неотсортированной части списка и находим ему место в отсортированной части:

> $[1, 5, 8, 2, 4]$.

Второй проход:

Делим список на две части: отсортированную $[1, 5]$ и неотсортированную $[8, 2, 4]$.

Извлекаем первый элемент $8$ из неотсортированной части списка и находим ему место в отсортированной части:

>$[1, 5, 8, 2, 4]$.

Третий проход:

Делим список на две части: отсортированную $[1, 5, 8]$ и неотсортированную $[2, 4]$.

Извлекаем первый элемент $2$ из неотсортированной части списка и находим ему место в отсортированной части:

>$[1, 2, 5, 8, 4]$.

Четвертый проход:

Делим список на две части: отсортированную $[1, 2, 5, 8]$ и неотсортированную $[4]$.

Извлекаем первый элемент 4 из неотсортированной части списка и находим ему место в отсортированной части:

>$[1, 2, 4, 5, 8]$.

Теперь список отсортирован и алгоритм может быть завершен.

[Содержание](#содержание)

<hr>

## Реализация алгоритма Сортировка простыми вставками

Пусть требуется отсортировать по возрастанию список чисел: 

>$a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]$.

Следующий программный код реализует алгоритм сортировки простыми вставками:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(1, n): 
    elem = a[i]  # первый элемент из неотсортированной части списка
    j = i
    while j >= 1 and a[j - 1] > elem: 
        a[j] = a[j - 1]
        j -= 1
    a[j] = elem


print('Отсортированный список:', a)
```

Результатом выполнения такого кода будет:

```python
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

## Оптимизация алгоритма Сортировка простыми вставками

Алгоритм сортировки простыми вставками можно значительно ускорить, если осуществлять поиск нужной позиции для вставки очередного элемента из неотсортированной части списка с помощью [бинарного поиска](https://ru.wikipedia.org/wiki/Двоичный_поиск).

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikPython/Python_Generation_for_beginners/README.MD)