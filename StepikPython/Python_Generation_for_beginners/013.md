# 13  Функции

# 13.1 Функции без параметров

## Тема урока: пользовательские функции 

1. Функции без параметров
2. Преимущества использования функций
3. Ключевое слово pass
4. Решение задач

Аннотация. Создание пользовательских функций без параметров. 

# Функции

В предыдущих уроках мы использовали встроенные в Python функции print(), input(), int(), str(), len() и многие другие. Пришло время начать писать свои собственные функции.

В самом начале курса вам было предложено решить задачу, в которой требовалось изобразить звездный прямоугольник размерами 5 × 7 (5 5 строк и 7 7 столбцов).

Наш первый вариант кода выглядел примерно так:

    print('*******')
    print('*******')
    print('*******')
    print('*******')
    print('*******')

Далее мы изучили оператор умножения строки на число (оператор повторения) и написали бы код:

    print('*' * 7)
    print('*' * 7)
    print('*' * 7)
    print('*' * 7)
    print('*' * 7)

Ну и наконец, мы изучили циклы, после чего код принял бы вид:

    for _ in range(5):
        print('*' * 7)

А теперь представим, что таких прямоугольников нужно изобразить не один, а несколько, скажем 3 штуки.

Тогда код программы будет иметь вид:

    for _ in range(5):
        print('*' * 7)

    print()

    for _ in range(5):
        print('*' * 7)

    print()

    for _ in range(5):
        print('*' * 7)

Результатом выполнения такого кода будет:

    *******
    *******
    *******
    *******
    *******

    *******
    *******
    *******
    *******
    *******

    *******
    *******
    *******
    *******
    *******

И хотя предыдущий код полностью решает поставленную задачу, он не лишен недостатков. 
+ Во-первых, он довольно громоздкий из-за повторения части кода, отвечающей за вывод прямоугольника. 
+ Во-вторых, если понадобится изменить размеры прямоугольника, придется менять их трижды, в каждой части кода, выводящей прямоугольник.    

Вместо повторения кода для вывода прямоугольника, можно перенести  его в отдельную функцию  и вызвать ее 3 раза.

Для создания функции пишем такой код:

    def draw_box():
        for _ in range(5):
            print('*' * 7)

Когда функция создана, чтобы увидеть результат ее работы, надо вызвать ее по имени:

    draw_box()

Теперь чтобы изобразить 3 прямоугольника можно написать код:

    draw_box()
    print()
    draw_box()
    print()
    draw_box()

Код стал короче, читабельнее (за счет удачного названия функции), а главное, если потребуются иные размеры прямоугольника, достаточно будет изменить только саму функцию draw_box().

# Именование функций

Имена функциям назначаются точно так же, как переменным. Имя функции должно быть достаточно описательным, чтобы любой, читающий ваш код, мог догадаться, что именно функция делает.

Python и тут требует соблюдения тех же правил, что при именовании переменных:

1. в имени функции используются только латинские буквы a-z, A-Z, цифры и символ нижнего подчеркивания (_);

2. имя функции не может начинаться с цифры;

3. имя функции по возможности должно отражать ее назначение;

4. символы верхнего и нижнего регистра различаются.

Помни: Python — регистрочувствительный язык. Для именования переменных и функций принято использовать стиль lower_case_with_underscores (слова из маленьких букв с подчеркиваниями).

Поскольку функции выполняют действия, большинство программистов предпочитает в именах функций использовать глаголы. Например:

+ функцию, которая рисует прямоугольник можно назвать draw_box();
+ функцию, которая печатает чек, можно назвать print_check();
+ функцию, которая вычисляет заработную плату до удержаний, можно назвать calculate_gross_рау(). 

Каждое из этих имен дает описание того, что функция делает.

# Объявление функции

Итак, функция – отдельная, функционально независимая часть программы, выполняющая определенную задачу.

Функции объявляются с помощью ключевого слова def (от слова define – определять). За ключевым словом def следуют название функции, круглые скобки (), и двоеточие :.

    def название_функции():
        блок кода

![def](/StepikPython/Python_Generation_for_beginners/pictures/032.png)

Первая строка объявления функции называется заголовком функции.

Со следующей строки идет блок кода – тело функции. Это набор инструкций, составляющих одно целое и выполняющихся каждый раз, когда вызывается функция.

Обратите внимание, что каждая строка в теле функции выделена отступом. 

Для выделения строк блока кода отступом программисты Python обычно используют четыре пробела, в соответствии со стандартом PEP 8.

Рассмотрим объявление функции: 

    def print_message():
        print('Я - Артур,')
        print('король британцев. ')

Этот фрагмент кода определяет функцию с именем print_message(). Тело ее состоит из двух инструкций, и вызов приведет к их исполнению.

# Вызов функции

Для вызова функции пишут ее название и круглые скобки.

Важно: очень часто начинающие программисты забывают вызывать функцию. Помните, что объявление функции не вызывает ее.

    # объявление функции
    def print_message():
        print('Я - Артур,')
        print('король британцев. ')

    # вызов функции
    print_message()

## Примечания
### Примечание 1. 

Обратите внимание, что объявление пользовательской функции немного напоминает использование условного оператора if и циклов for, while.

### Примечание 2. 
Объявление функции должно предшествовать ее вызову. Следующий программный код:

    # вызов функции
    print_message()

    # объявление функции
    def print_message():
        print('Я - Артур,')
        print('король британцев. ')

приведет к ошибке:

    NameError: name 'print_message' is not defined

### Примечание 3. 
При объявлении функции следует убедиться, что каждая строка тела функции начинается с одинакового количества пробелов, иначе произойдет ошибка. Например, приведенное ниже определение функции приведет к ошибке:

    def print_greeting():
        рrint('Доброе утро!')
    рrint('Сегодня мы будем изучать функции.')
        рrint('Это очень важная тема!')

### Примечание 4. 
Иногда, при объявлении функции требуется сделать своего рода заглушку, чтобы функция ничего не выполняла. Тогда мы используем ключевое слово pass: 

    def do_nothing():
        pass

Мы объявили функцию с именем do_nothing(). Тело такой функции содержит единственную строку кода, которая ничего не делает.

### Примечание 5. 
Функции часто называют подпрограммами.

# 13.2 Функции с параметрами

## Тема урока: функции с параметрами
1. Функции с параметрами
2. Область видимости параметрической переменной
3. Параметры по умолчанию
4. Решение задач

Аннотация. Создание пользовательских функций с параметрами. 

# Функции с параметрами

В предыдущем уроке мы определили функцию draw_box(), которая выводит звездный прямоугольник с размерами 5 \times 75×7:

    def draw_box():
        for i in range(5):
            print('*' * 7)

Было бы намного удобнее, если бы функция draw_box() выводила прямоугольник с произвольными размерами. И действительно, функции могут принимать входные параметры, что делает их более гибкими.

Функции с параметрами объявляются так же как функции без параметров, только с указанием в скобках:

    def название_функции(параметры):
        блок кода
![def](/StepikPython/Python_Generation_for_beginners/pictures/033.png)

Давайте перепишем предыдущую версию функции draw_box() так, чтобы она принимала параметры, задающие высоту и ширину прямоугольника:

    def draw_box(height, width):    # функция принимает два параметра
        for i in range(height):
            print('*' * width)

Теперь наша функция draw_box() принимает два целочисленных параметра height – высота прямоугольника и width – ширина прямоугольника, и для ее вызова нам нужно обязательно их указать.

Чтобы вывести звездный прямоугольник размерами 5 на 7 мы пишем код:

    draw_box(5, 7)

Результатом такого вызова функции draw_box(5, 7) будет:

    *******
    *******
    *******
    *******
    *******

Чтобы вывести прямоугольник размерами 10 на 15, мы пишем код:

    draw_box(10, 15)

Результатом такого вызова функции draw_box(10, 15) будет:

    ***************
    ***************
    ***************
    ***************
    ***************
    ***************
    ***************
    ***************
    ***************
    ***************

Теперь с помощью нашей новой версии функции draw_box() можем в одной программе выводить прямоугольники разных размеров. Следующий программный код:

    draw_box(3, 3)
    print()
    draw_box(5, 5)
    print()
    draw_box(4, 10)

выведет:

    ***
    ***
    ***

    *****
    *****
    *****
    *****
    *****

    **********
    **********
    **********
    **********

На место параметров мы можем подставлять не только целочисленные константы, но и значения переменных. Следующий программный код:

    n = 3
    m = 9
    draw_box(n, m)

выведет:

    *********
    *********
    *********

## Еще примеры

Напишем функцию print_hello(n), которая принимает одно натуральное число n и печатает слово Hello ровно n раз.

    def print_hello(n):
        print('Hello' * n)

Следующий программный код:

    print_hello(3)
    print_hello(5)
    times = 2
    print_hello(times)

выведет:

    HelloHelloHello
    HelloHelloHelloHelloHello
    HelloHello

Функцию print_hello() можно сделать более гибкой, если передавать в нее еще один параметр – текст для вывода:

    def print_text(txt, n):
        print(txt * n)

Следующий программный код:

    print_text('Hello', 5)
    print_text('A', 10)

выведет:

    HelloHelloHelloHelloHello
    AAAAAAAAAA

# Параметры VS аргументы

Аргумент – это любая порция данных, которая передается в функцию, когда функция вызывается. Параметр – это переменная, которая получает аргумент, переданный в функцию.

Для функции draw_box(height, width):

    ​def draw_box(height, width):
        for i in range(height):
            print('*' * width)

параметрами являются переменные height и width.

В момент вызова функции draw_box(height, width):

    height = 10
    draw_box(height, 9)

аргументами являются height и 9.

Параметры функций часто называют параметрическими переменными.

# Внесение изменений в параметры

Когда аргумент передается в функцию, параметрическая переменная функции будет ссылаться на значение этого аргумента. Однако любые изменения, которые вносятся в параметрическую переменную, не будут влиять на аргумент.

Cледующий программный код:

    def draw_box(height, width):
        height = 2
        width = 10
        for i in range(height):
            print('*' * width)

    n = 5
    m = 7
    draw_box(n, m)
    print(n, m)

выведет:

    **********
    **********
    5 7

В теле функции вносятся изменения в значения параметрических переменных height и width, однако это никак не повлияло на значение переменных n и m из основной программы, которые передавались в качестве аргументов в функцию draw_box().

## Примечание

### Примечание 1. 
Функции в Python могут принимать сколько угодно параметров.

### Примечание 2. 
Иногда вместо параметров и аргументов говорят о формальных параметрах и фактических параметрах. Формальные параметры – переменные, которые мы пишем при описании функции. Фактические параметры – то, что реально подставляется при вызове функции.

# 13.3 Локальные и глобальные переменные

## Тема урока: локальные и глобальные переменные 
1. Локальные переменные
2. Область действия локальной переменной
3. Глобальные переменные
4. Глобальные константы
5. Решение задач

Аннотация. Локальные и глобальные переменные. 

# Локальные переменные

Локальными называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.

Рассмотрим функцию print_texas(), которая выводит информацию о количестве птиц, обитающих в Техасе.

    def print_texas():
        birds = 5000
        print('В Техасе обитает', birds, 'птиц.')

В теле функции мы создаем переменную birds, которой присваивается значение, равное 5000. Такая переменная является локальной для функции print_texas(). 

Всякий раз, когда переменной внутри функции присваивается значение, в результате создается локальная переменная. Она принадлежит функции, в которой создается,  и к ней получает доступ только программный код этой функции.

Термин “локальная” указывает на то, что переменная может использоваться лишь в этом месте — внутри функции, в которой создается.

Если программный код одной функции попытается обратиться к локальной переменной, принадлежащей другой функции, произойдет ошибка.

Рассмотрим следующий программный код:

    def print_texas():
        birds = 5000
        print('В Техасе обитает', birds, 'птиц.')

    def print_california():
        print('В Калифорнии обитает', birds, 'птиц.')

Функция print_california() обращается к локальной переменной birds функции print_texas(). Вызов функции print_california(), приводит к ошибке:

    NameError: name 'birds' is not defined

Локальные переменные скрыты от других функций, поэтому другие функции могут иметь собственные локальные переменные с тем же именем. Например,

    def print_texas():
        birds = 5000
        print('В Техасе обитает', birds, 'птиц.')

    def print_california():
        birds = 9000
        print('В Калифорнии обитает', birds, 'птиц.')

В каждой из этих двух функций есть локальная переменная с именем birds. Но они никогда не видны одновременно, так как находятся в разных функциях.

Когда выполняется функция print_texas(), видима переменная birds, значение которой равно 5000. Когда выполняется функция print_california(), видима переменная birds, значение которой равно 9000.

Разные функции могут иметь локальные переменные с одинаковыми именами, потому что они не видят локальных переменных друг друга.

# Область действия переменной

Область действия переменной – часть программы, в которой можно к ней обращаться, та функция, где она создана. Переменная видима только программному коду в области ее действия. Никакая инструкция за пределами функции не может обращаться к такой переменной.

К локальной переменной не может обращаться программный код, который появляется внутри функции до того, как переменная была создана.

Например, если в функции print_texas() поменять местами строки кода:

    def print_texas():
        print('В Техасе обитает', birds, 'птиц.')
        birds = 5000

то при вызове этой функции получим ошибку:

    UnboundLocalError: local variable 'birds' referenced before assignment

Ошибка возникла в результате преждевременного обращения к еще не объявленной локальной переменной birds.

# Область действия параметрической переменной

Область действия параметрической переменной — функция, в которой этот параметр используется. К параметрической переменной имеет доступ весь программный код этой функции.

Рассмотрим уже известную нам функцию:

    def draw_box(height, width):
        for i in range(height):
            print('*' * width)

Параметрические переменные тут height, width. Внутри функции объявляется одна локальная переменная i.

## Примечания

### Примечание 1. 
Параметрическая переменная тоже локальная.

### Примечание 2. 
Память для локальных переменных выделяется на время исполнения данной функции в специальной области, называемой стеком. При завершении работы функции память освобождается, внутренние результаты работы функции не сохраняются от одного обращения к другому.
https://ru.wikipedia.org/wiki/Стек

# Глобальные переменные

Глобальными называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям.

Рассмотрим следующий программный код:

    birds = 5000    # глобальная переменная

    def print_texas():
        print('В Техасе обитает', birds, 'птиц.')

    def print_california():
        print('В Калифорнии обитает', birds, 'птиц.')

В самом начале программы создаем глобальную переменную birds, значение которой равно 5000. Далее описываем две функции, обращающиеся к глобальной переменной. Результатом выполнения следующего кода:

    print_texas()
    print_california()
будет:

    В Техасе обитает 5000 птиц.
    В Калифорнии обитает 5000 птиц.

Обмен информацией между основной программой и функциями осуществляется только с помощью параметров функций и глобальных переменных.

Функция может использовать любые глобальные переменные кроме имеющих те же имена, что и ее локальные переменные. Если в функции объявлена локальная переменная с тем же именем, что у одной из глобальных, то данная глобальная переменная становится недоступной в этой функции, и при указании идентификатора переменной произойдет обращение к локальной переменной функции, а не одноименной глобальной.

Рассмотрим следующий программный код:

    birds = 5000   # глобальная переменная

    def print_texas():
        birds = 1000  # локальная переменная
        print('В Техасе обитает', birds, 'птиц.')

    def print_california():
        birds = 7000  # локальная переменная
        print('В Калифорнии обитает', birds, 'птиц.')

В самом начале программы мы создаем глобальную переменную birds, значение которой равно 5000. Далее мы описываем две функции, в которых создаются локальные переменные с таким же именем birds. Таким образом при обращении к переменной birds внутри функций будет происходить обращение именно к локальной переменной.

Результатом выполнения следующего кода:

    print_texas()
    print_california()

будет:

    В Техасе обитает 1000 птиц.
    В Калифорнии обитает 7000 птиц.
# Глобальные переменные – зло

Большинство программистов согласны, что следует ограничить использование глобальных переменных либо не использовать их вообще. Причины следующие.

+ Глобальные переменные затрудняют отладку программы. 
    
    Значение глобальной переменной может быть изменено любой инструкцией в программном файле. 
    
    Если обнаружится, что в глобальной переменной хранится неверное значение, то придется отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. 
    
    В программе с тысячами строк кода сделать это непросто.
+ Функции, использующие глобальные переменные, обычно зависят от этих переменных. 

    Если возникнет необходимость применить такую функцию в другой программе, скорее всего придется эту функцию перепроектировать, чтобы она не опиралась на глобальную переменную.
+ Глобальные переменные затрудняют понимание программы. 

    Глобальная переменная может быть модифицирована любой инструкцией в программе. 
    
    При необходимости разобраться в какой-то части программы, использующей глобальную переменную, придется узнать обо всех других частях программы, обращающихся к этой глобальной переменной.

В большинстве случаев следует создавать переменные локально и передавать их в качестве аргументов в функции, которым нужно к ним обратиться.

# Глобальные константы

Хотя следует избегать использования глобальных переменных, в программе допускается применение глобальных констант. 

Глобальная константа – глобальное имя, ссылающееся на неизменное значение. Поскольку значение глобальной константы не может быть изменено во время исполнения программы, можно не беспокоиться о потенциальных опасностях, обычно связанных с использованием глобальных переменных.

Несмотря на то, что язык Python не позволяет создавать настоящие глобальные константы, их можно имитировать при помощи глобальных переменных. 

Если глобальная переменная не объявляется с использованием ключевого слова global внутри функции, то присвоенное ей значение невозможно изменить внутри этой функции. 

Математический модуль math  определяет две глобальные переменные, math.pi и math.e, которым присвоены математические значения констант π = 3.14159265 и e = 2.71828.

# Ключевое слово global

Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный шаг. В этом случае, глобальная переменная должна быть объявлена внутри функции.

Рассмотрим следующий программный код:

    def print_texas():
        global birds
        birds = 5000
        print('В Техасе обитает', birds, 'птиц.')

    def print_california():
        print('В Калифорнии обитает', birds, 'птиц.')

    print_texas()
    print_california()

Результатом выполнения следующего кода:

    print_texas()
    print_california()

будет:

    В Техасе обитает 5000 птиц.
    В Калифорнии обитает 5000 птиц.

# 13.4 Функции с возвратом значения. Часть 1

## Тема урока: функции с возвратом значения
1. Функции с возвратом значения
2. Решение задач

Аннотация. Функции могут не только принимать и не принимать параметры, как в примерах предыдущих уроков, но и возвращать значения. Рассмотрим этот особый тип функций - с возвратом значения.

# Функция с возвратом значения
Функция с возвратом значения похожа на функцию без возврата значения тем, что:

+ это набор инструкций, выполняющий определенную задачу;
+ когда нужно выполнить функцию, ее вызывают.

Однако когда функция с возвратом значения завершается, она возвращает значение в ту часть программы, которая ее вызвала. 

Возвращаемое из функции значение используется как любое другое: 
+ оно может быть присвоено переменной, 
+ выведено на экран, 
+ использовано в математическом выражении (если это число) и т. д.

Функция с возвратом значения возвращает значение обратно в ту часть программы, которая ее вызвала.

Мы уже сталкивались со многими функциями с возвратом значений:

+ функция int() – преобразует строку к целому числу и возвращает его;
+ функция float() – преобразует строку к вещественному числу и возвращает его;
+ функция range() – возвращает последовательность целых чисел 0, 1, 2, ...;
+ функция abs() – возвращает абсолютное значение числа (модуль числа);
+ функция len() – возвращает длину строки или списка.

Функцию с возвратом значения пишут точно так же, как и без, но она должна иметь инструкцию return.

Вот общий формат определения функции с возвратом значения в Python:

    def название_функции():
        блок кода
        return выражение

В функции должна быть инструкция return, принимающая форму:

    return выражение

Значение выражения, которое следует за ключевым словом return, будет отправлено в ту часть программы, которая вызвала функцию. 

Это может быть переменная либо выражение, к примеру, математическое.

Функция с возвратом значения имеет инструкцию return, возвращающую значение в ту часть программы,  которая ее вызвала.

При изучении вещественных чисел мы решали задачу о переводе градусов по шкале Фаренгейта в градусы по шкале Цельсия по формуле C = (5 / 9) *(F - 32).

Напишем функцию, которая осуществляет перевод: 

    def convert_to_celsius(temp):
        result = (5 / 9) * (temp - 32)
        return result

Задача этой функции — принять одно число temp в качестве аргумента – количество градусов по шкале Фаренгейта, и вернуть другое — количество градусов по шкале Цельсия.

Рассмотрим ее работу. Первая инструкция в блоке функции присваивает значение (5 / 9) * (temp - 32) переменной result. Затем исполняется инструкция return, которая приводит к завершению исполнения функции и отправляет значение из переменной result, назад в ту часть программы, которая вызвала эту функцию.

    # функция перевода градусов Фаренгейта в градусы Цельсия
    def convert_to_celsius(temp):
        result = (5 / 9) * (temp - 32)
        return result

    # основная программа
    temp = float(input('Bвeдитe количество градусов по Фаренгейту: '))
    celsius = convert_to_celsius(temp)
    print(celsius)  # градусы Цельсия

Основная программа получает от пользователя одно число – значение в градусах Фаренгейта, и вызывает функцию, передавая значение переменной temp в качестве аргумента. Значение, которое возвращается из функции convert_to_celsius, присваивается переменной celsius.

![function](/StepikPython/Python_Generation_for_beginners/pictures/034.png)
![function](/StepikPython/Python_Generation_for_beginners/pictures/035.png)

# Использование инструкции return по максимуму
Взглянем еще раз на функцию convert_to_celsius():

    def convert_to_celsius(temp):
        result = (5 / 9) * (temp - 32)
        return result

Обратите внимание, что внутри этой функции происходят две вещи: 
+ во-первых, переменной result присваивается значение выражения (5 / 9) * (temp - 32), и 
+ во-вторых, значение переменной result возвращается из функции. 

Эта функция хорошо справляется с поставленной перед ней задачей, но ее можно упростить. 

Поскольку инструкция return возвращает значение выражения, переменную result устраняем и переписываем функцию так:

    def convert_to_celsius(temp):
        return (5 / 9) * (temp - 32)

Эта версия функции не сохраняет значение (5 / 9) * (temp - 32) в отдельной переменной, а сразу возвращает значение выражения с помощью инструкции return. 

Делает то же, что и предыдущая версия, но за один шаг.

# Использование нескольких return

В одной функции может быть сколько угодно инструкций return. 

Рассмотрим функцию convert_grade(), которая переводит стобалльную оценку в пятибалльную:

    def convert_grade(grade):
        if grade >= 90:
            return 5
        elif grade >= 80:
            return 4
        elif grade >= 70: 
            return 3
        elif grade >= 60:
            return 2
        else:
            return 1

    # основная программа
    grade = int(input('Введите вашу отметку по 100-балльной системе: '))
    print(convert_grade(grade))

В функции convert_grade() используется 5 инструкций return. Каждая из них возвращает соответствующее значение и завершает работу функции.

Функцию convert_grade() можно переписать с помощью одной инструкции return:

    def convert_grade(grade):
        result = -1
        if grade >= 90:
            result = 5
        elif grade >= 80:
            result = 4
        elif grade >= 70: 
            result = 3
        elif grade >= 60:
            result = 2
        else:
            result = 1
        
        return result

## Примечания
### Примечание 1. 
Функции с возвратом значения предоставляют те же преимущества, что функции без возврата значения:

+ упрощают программный код;
+ уменьшают дублирование кода;
+ упрощают тестирование кода;
+ увеличивают скорость разработки;
+ способствуют работе в команде.

### Примечание 2. 
Графическая интерпретация работы функции с возвратом значения:

![Графическая интерпретация работы функции с возвратом значения](/StepikPython/Python_Generation_for_beginners/pictures/036.png)

### Примечание 3. 
result – хорошее название для переменной, значение которой возвращается из функции. 

# Решение задач
## Задача 1. 
Напишите функцию, которая возвращает длину гипотенузы прямоугольного треугольника по известным значениям его катетов.

### Решение. 
Для нахождения длины гипотенузы, нам нужно применить теорему Пифагора: квадрат гипотенузы прямоугольного треугольника, равен сумме квадратов его катетов. 

Другими словами, если a, b – длины катетов, а c – длина гипотенузы, то имеет место равенство:

    c ** 2 = a ** 2 + b ** 2 

Функция, вычисляющая длину гипотенузы, может иметь вид:

    def compute_hypotenuse(a, b):
        c = (a ** 2 + b ** 2) ** 0.5
        return c

Для извлечения квадратного корня мы использовали оператор возведения в степень. Напомним, что результатом обоих выражений: math.sqrt(c) и c ** 0.5 является одно число.

Следующий программный код:

    print(compute_hypotenuse(3, 4))
    print(compute_hypotenuse(5, 12))
    print(compute_hypotenuse(1, 1))

выведет:

    5.0                   # длина гипотенузы треугольника с катетами 3 и 4
    13.0                  # длина гипотенузы треугольника с катетами 5 и 12
    1.4142135623730951    # длина гипотенузы треугольника с катетами 1 и 1

Если нужно передать программе числа, считанные с клавиатуры, то мы пишем следующий код:

    x = int(input())
    y = int(input())

    hypotenuse = compute_hypotenuse(x, y)

    print(hypotenuse)

В модуле math имеется встроенная функция hypot(x, у) которая возвращает длину гипотенузы прямоугольного треугольника с катетами x и y.

Одним из основных преимуществ функций является возможность их повторного использования для решения похожих задач. Рассмотрим задачу нахождения расстояния между двумя точками.

## Задача 2. 
Напишите функцию get_distance(x1, y1, x2, y2), вычисляющую расстояние между точками (x_1; y_1) и (x_2; y_2).

### Решение. 
Расстояние между двумя точками (x_1; y_1) и (x_2; y_2) определяется по формуле

P = ((x_1 - x_2) ** 2 + (y_1 - y_2) ** 2}) ** 0.5.

Несложно заметить, что искомое расстояние – это длина гипотенузы прямоугольного треугольника с катетами равными |x_1 - x_2| и |y_1-y_2|.

Функция, вычисляющая расстояние между точками, может иметь вид:

    def get_distance(x1, y1, x2, y2):
        return compute_hypotenuse(x1 - x2, y1 - y2)

Для подсчета искомого расстояния мы используем уже созданную нами функцию compute_hypotenuse передавая ей в качестве аргументов числа x1 - x2 и y1 - y2.

Основная программа имеет вид:

    x1, y1 = float(input()), float(input())  # считываем координаты первой точки
    x2, y2 = float(input()), float(input())  # считываем координаты второй точки

    print(get_distance(x1, y1, x2, y2))      # вычисляем и выводим расстояние между точками

## Задача 3. 

Напишите функцию sum_digits(n), принимающую в качестве аргумента натуральное число и возвращающую сумму его цифр.

### Решение. 
Функция sum_digits(n) может иметь вид:

    def sum_digits(n):
        result = 0
        while n > 0:
            result += n % 10
            n //= 10
        return result

Основная программа имеет вид:

    n = int(input())
    print(sum_digits(n))      # вычисляем и выводим сумму цифр считанного числа

## Задача 4. 
Напишите функцию compute_average(numbers), принимающую в качестве аргумента список чисел и возвращающую среднее значение элементов списка.

### Решение. 
Для подсчета среднего значения элементов списка нужно вычислить сумму всех элементов и их количество, то есть использовать функции sum() и len(). Функция compute_average(numbers) может иметь вид:

    def compute_average(numbers):
        return sum(numbers) / len(numbers)

Основная программа имеет вид:

    numbers = [1, 3, 5, 1, 6, 8, 10, 2]
    print(compute_average(numbers))      # вычисляем и выводим среднее значение элементов списка

Результатом работы такой программы будет число 4.5, которое и является средним значением.

# Слияние двух отсортированных списков

Слияние двух отсортированных списков в один — важная задача в информатике. Она естественно возникает при сортировке списков c использованием сортировки слиянием.
https://ru.wikipedia.org/wiki/Сортировка_слиянием

Пусть даны два отсортированных по возрастанию списка чисел list1 и list2:

    list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
    list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]

Простейшее решение задачи слияния списков использует списочный метод sort():

    def merge(list1, list2):
        result = list1 + list2   # создаем результирующий список
        result.sort()            # сортируем список встроенным методом sort()
        return result            # возвращаем отсортированный список

    list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
    list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
    list3 = merge(list1, list2)  # вызываем функцию слияния двух отсортированных списков
    print(list3)

Результатом работы такого кода будет список:

    [0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]

И хотя функция merge() полностью справляется с своей задачей, она абсолютно не учитывает то, что два списка list1 и list2 уже отсортированы.

# Быстрое слияние двух отсортированных списков в один

Пусть мы имеем два уже отсортированных по возрастанию списка list1 и list2.

## Алгоритм быстрого слияния следующий:

1. Создаем численные указатели p1 = 0 и p2 = 0 на начала обоих списков list1 и list2 соответственно;
2. На каждом шаге берем меньший из двух элементов list1[p1] и list2[p2];
3. Записываем его в результирующий список; 
4. Увеличиваем указатель на первый элемент списка (p1 или p2) из которого был взят элемент на 1;
5. Когда один из начальных списков закончился, добавляем все оставшиеся элементы второго списка в результирующий список.

###
    def quick_merge(list1, list2):
        result = []

        p1 = 0  # указатель на первый элемент списка list1
        p2 = 0  # указатель на первый элемент списка list2

        while p1 < len(list1) and p2 < len(list2):  # пока не закончился хотя бы один список
            if list1[p1] <= list2[p2]:
                result.append(list1[p1])
                p1 += 1
            else:
                result.append(list2[p2])
                p2 += 1

        if p1 < len(list1):   # прицепление остатка
            result += list1[p1:]
        if p2 < len(list2):
            result += list2[p2:]
        
        return result

Следующий программный код:

    list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
    list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
    list3 = quick_merge(list1, list2)
    print(list3)

выведет:

    [0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]

# 13.5 Функции с возвратом значения. Часть 2

## Тема урока: функции с возвратом значения
1. Функции с возвратом значения
2. Решение задач

Аннотация. Кроме функций, возвращающих числовые значения, можно писать и возвращающие логические, строковые и другие значения. 

# Возвращение булевых значений

Python позволяет писать булевы функции, возвращающие либо истину (True), либо ложь (False). Булеву функцию можно применять для проверки условия, тогда значения True и False будут сигнализировать о его выполнении.

https://ru.wikipedia.org/wiki/Булева_функция

Булевы функции широко применяются для упрощения сложных условий, проверяемых в структурах принятия решения и структурах с повторением.

Например, напишем программу, которая просит пользователя ввести число, и определяет четное оно или нечетное.

Это можно сделать так:

    number = int(input())
    if number % 2 == 0:
        print('Это число четное. ')
    else:
        print('Это число нечетное.')

Этот фрагмент кода будет легче понять, если написать булеву функцию is_even(), которая принимает число в качестве аргумента и возвращает True, если оно четное, и False если нечетное.

    def is_even(number):
        if number % 2 == 0:
            return True
        else:
            return False

Теперь можно переписать инструкцию if-else основной программы так, чтобы она для определения четности переменной number вызывала функцию is_even():

    number = int(input())
    if is_even(number):
        print('Это число четное. ')
    else:
        print('Это число нечетное.')

Так логику программы легче понять, а функцию можно вызывать в программе всякий раз, когда необходимо проверить четность числа.

# Использование булевых функций для валидации входных данных

Булевы функции можно также использовать для упрощения сложного кода валидации входных данных. Например в программе, предлагающей пользователю ввести номер модели изделия, где возможны только значения 100, 200 и 300, можем написать такой код:

    model = int(input())

    while model != 100 and model != 200 and model != 300:
        print('Допустимыми номерами моделей являются 100, 200 и 300.')
        model = int(input())

Цикл валидации использует длинное составное булево выражение, и повторяется до тех пор, пока model не будет равняться 100 и 200 или 300. 

Вместе с тем, цикл валидации можно упростить, написав булеву функцию проверки переменной model, и вызывая ее в цикле. Напишем функцию is_invalid(), которая принимает один параметр model и возвращает значение True, если модель недопустима и False в противном случае. Тогда цикл валидации можно переписать следующим образом:

    while is_invalid(model):
        print('Допустимыми номерами моделей являются 100, 200 и 300.')
        model = int(input())

После этого изменения цикл становится легче читать. 

Теперь вполне очевидно, что цикл повторяется до тех пор, пока номер модели недопустим. 

Приведенный ниже фрагмент кода показывает, как можно было бы написать функцию is_invalid(). 

Она принимает номер модели в качестве аргумента, и если аргумент не равен 100, 200 и 300, то эта функция возвращает True, говоря, что он недопустимый. 

В противном случае функция возвращает False.

    def is_invalid(model):
        if model != 100 and model != 200 and model != 300:
            return True
        else:
            return False

Создание функций, реализующих такую простую логику — не всегда оптимальное решение, так как увеличивает размер кода и ведет к затратам времени на вызов функции и возврат обратно результата, что может сказаться на производительности программы.

# 13.6 Функции с возвратом значения. Часть 3

## Тема урока: функции с возвратом значения
1. Функции с возвратом нескольких значений
2. Решение задач

Аннотация. Урок посвящен функциям с возвратом нескольких значений.

# Функции с возвратом нескольких значений

В Python функции не ограничены возвратом всего одного значения. После инструкции return можно определить много выражений, разделенных запятыми:

    return выражение 1, выражение 2, выражение 3 ...

Следующий программный код определяет функцию get_powers(num), которая принимает в качестве аргумента число num и возвращает его квадрат, куб и четвертую степень.

    def get_powers(num):
        return num**2, num**3, num**4

Результатом выполнения следующего кода:

    a, b, c = get_powers(2)
    print(a)
    print(b)
    print(c)

будет:

    4
    8
    16

Возвращающие несколько значений функции – исключительная особенность языка Python. 

В большинстве языков программирования для возврата нескольких значений используется результирующий тип данных – список, который может содержать несколько значений.

Рассмотрим еще один пример. 

Пусть требуется написать функцию, которая находит точку пересечения двух непараллельных прямых a * x + b * y = e и c* x + d * y = f. 

Другими словами требуется решить систему уравнений:

![Система уравнений](/StepikPython/Python_Generation_for_beginners/pictures/037.PNG)

Программный код, решающий задачу, имеет вид:

    def solve(a, b, c, d, e, f):
        x = (d * e - b * f)/(a * d - b * c)
        y = (a * f - c * e)/(a * d - b * c)
        return x, y

Следующий код:

    xsol, ysol = solve(2, 3, 4, 1, 2, 5)
print('Решением системы являются числа', 'x =', xsol, 'y =', ysol)

выведет

    Решением системы являются числа x = 1.3 y = -0.2

![Система уравнений](/StepikPython/Python_Generation_for_beginners/pictures/038.PNG)

# Преимущества использования функций
Разбивая программы на функции получаем:

+ Более простой код. 

    Разбитый на функции код программы проще и легче для понимания.  Несколько небольших функций намного легче читать, чем одну длинную последовательность инструкций;
+ Повторное использование кода. 

    Функции позволяют избежать многократного повторения кода в программе. Если какая-то операция в программе выполняется в нескольких местах, то можно один раз написать для нее функцию и затем исполнять ее, когда понадобится.
+   Более простое тестирование.  
    
    Когда каждая задача в программе содержится в собственной функции, программисты могут индивидуально протестировать каждую функцию и определить, выполняет ли она свою задачу правильно.
+ Более быстрая разработка. 
    
    Предположим, что программист или команда программистов разрабатывает много программ. Они обнаруживают общие задачи у разных программ, например выяснение имени пользователя и пароля, вывод текущего времени. Каждый раз писать программный код для этих задач не имеет смысла. Для часто встречающихся задач пишут функции, и включают в состав любой нуждающейся в них программы.

+   Упрощение командной работы. 
    
    Когда программа разрабатывается как набор функций, разным программистам можно поручить написание отдельных функций.

# Что выделять в функции?

В функцию можно выделить любой законченный фрагмент программы. Можно ориентироваться на рекомендации:

+ Когда несколько раз пишете в программе одну и ту же последовательность команд, необходимость введения функции приобретает характер острой внутренней потребности;

+ Иногда обилие мелочей заслоняет главное и полезно убрать в функцию подробности, скрывающие смысл основной программы;

+ Полезно разбить длинную программу на составные части, как книгу разбивают на главы, при этом основная программа становится похожей на оглавление;

+ Сложные частные алгоритмы бывает полезно отладить отдельно в небольших тестирующих программах. Включить их в основную программу будет легко, если они оформлены в виде функций. Например, функций сортировок;

+ Сделанное хорошо в одной программе, хочется перенести в новые. Для повторного использования лучше сразу выделять в программе полезные алгоритмы в отдельные функции, а функции собирать в пакеты.
