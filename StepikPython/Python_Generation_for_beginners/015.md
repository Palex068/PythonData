# 15  Работа над мини-проектами

# 15.1 Модуль random

## Тема урока: модуль random

1. Случайные числа
2. Модуль random

Аннотация. Урок посвящен модулю random, который содержит функции по работе со случайными числами.

# Случайные числа

Случайные числа широко используются в различных задачах программирования:

+ случайные числа используются в играх. 

    Например, компьютерным играм, которые позволяют игроку подбрасывать игральный кубик, нужны случайные числа для представления значений кубика. 
    
    Программы, которые раскрывают игральные карты, вынимаемые из перетасованной колоды, используют случайные числа для представления достоинства карт;

+ случайные числа применяются в программах имитационного моделирования. 

    В некоторых симуляциях компьютер должен случайным образом решить, как будет вести себя человек, животное, насекомое или другое живое существо. 
    
    Нередко конструируются формулы, где случайное число используется для определения различных вариантов действий и событий, происходящих в программе;

+ случайные числа распространены в статистических программах, случайным образом отбирающих данные для анализа;

+ случайные числа используются в компьютерной безопасности для шифрования уязвимых данных.

Python предлагает встроенные функции для работы со случайными числами. Эти функции хранятся в модуле random в стандартной библиотеке.

# Модуль random

Модуль random предоставляет функции для генерации случайных чисел, букв и случайного выбора элементов последовательности (списка, строки и т.д.).

Для использования этих функций в начале программы необходимо подключить модуль, что делается командой import:

    import random

После подключения модуля мы можем использовать его функции.

# randint()

Функция randint() принимает два обязательных аргумента a и b и возвращает случайное целое число из отрезка [a; b].

Следующий код выводит два случайных целых числа: num1 из отрезка [0; 17] и num2 из отрезка [-5; 5] . 

    import random

    num1 = random.randint(0, 17)
    num2 = random.randint(-5, 5)

    print(num1)
    print(num2)

Важно: левая и правая граница a и b включаются в диапазон генерируемых случайных чисел. Результатом вызова функции random.randint(2, 9) может быть любое число от 2 до 9 включительно.

Следующий код выводит 10 случайных целых чисел из диапазона [1; 100]:

    import random

    for _ in range(10):
        print(random.randint(1, 100))

Среди этих чисел возможны повторения, поскольку каждый раз выбирается случайное.

# randrange()

Функция randrange()

Если вы помните, как применять функцию range(), то почувствуете себя непринужденно с функцией randrange(). Функция randrange() принимает такие же аргументы, что и функция range(). Различие состоит в том, что функция randrange() не возвращает саму последовательность чисел. 

Вместо этого она возвращает случайно выбранное число из последовательности чисел.

Следующий код присваивает переменной num случайное число в диапазоне от 0 до 9:

    import random

    num = random.randrange(10)

Аргумент 10 задает конечный предел последовательности значений. Функция возвратит случайно выбранное число из последовательности чисел от 0 до конечного предела, исключая сам предел.

Следующий код задает начальное значение и конечный предел последовательности:

    import random

    num = random.randrange(5, 10)

Таким образом в переменной num будет храниться случайное число в диапазоне от 5 до 9.

Следующий код задает начальное значение, конечный предел и величину шага:

    import random

    num = random.randrange(0, 101, 10)

Таким образом в переменной num будет храниться случайное число из последовательности чисел: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100.

# random()

Функции randint() и randrange() возвращают случайное целое число. А вот функция random() возвращает случайное число с плавающей точкой (вещественное число). В функцию random() никаких аргументов не передается. Функция random() возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (исключая 1.0).

Следующий код выводит случайное число с плавающей точкой из диапазона [0.0; 1.0):

    import random

    num = random.random()
    print(num)

# uniform()

Функция uniform() тоже возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон для отбора значений.

Следующий код выводит случайное число с плавающей точкой из диапазона [1.5; 17.3]:

    import random

    num = random.uniform(1.5, 17.3)
    print(num)

# Начальные значения случайного числа

Числа, генерируемые функциями модуля random, не являются подлинно случайными. 

Несмотря на то, что обычно их называют случайными числами, это псевдослучайные числа, вычисляемые на основе формулы. 

Формула, генерирующая случайные числа, должна быть инициализирована начальным значением. 

Оно используется в вычислении, возвращающем следующее случайное число в ряду. 

Когда модуль random импортируется, он получает системное время из внутреннего генератора тактовых импульсов компьютера и использует его как начальное значение. 

Системное время - целое число, представляющее текущую дату и время вплоть до одной сотой секунды. 

Если бы всегда использовалось одно и то же начальное значение, функции генерации случайных чисел всегда  возвращали бы один и тот же ряд псевдослучайных чисел. 

Поскольку системное время меняется каждую сотую долю секунды, можно без опасений утверждать, что всякий раз, когда импортируется модуль random, будет сгенерирована отличающаяся от предыдущих последовательность случайных чисел.

# seed()

Вместе с тем, могут иметься некоторые программы, где требуется всегда генерировать одну и ту же последовательность случайных чисел. 

При необходимости для этого можно вызвать функцию seed(), задав начальное значение.

Следующий код генерирует 10 случайных чисел, и при этом содержит инструкцию, явно устанавливающую начальное значение для генератора случайных чисел:

    import random

    random.seed(17)   # явно устанавливаем начальное значение для генератора случайных чисел

    for _ in range(10):
        print(random.randint(1, 100))

Результатом выполнения такого кода может быть:

    67
    54
    39
    47
    38
    23
    99
    91
    91
    70

Если выполнить такой код еще раз, то мы получим ту же самую последовательность псевдослучайных чисел.

## Примечания

### Примечание 1. 

Подключение модуля следующим образом:

    from random import *

позволяет в дальнейшем не писать название модуля и символ точки при вызове функций модуля.

### Примечание 2. 

Функции модуля random на самом деле являются методами одноименного класса random.

### Примечание 3. 
Функция randint() реализована на основе функции randrange() следующим образом:

    # Return random integer in range [a, b], including both end points.
    def randint(self, a, b):
        return self.randrange(a, b + 1)

# Решение задач

## Задача 1. 
Профессор Тимур преподает вводный курс статистики и попросил вас написать программу, которую он мог бы использовать на занятиях для имитации бросания игральных кубиков. Программа должна случайным образом генерировать два числа в диапазоне от 1 до 6 и показывать их.

### Решение. 

Для генерации целых чисел мы будем использовать функцию randint():

    import random

    print('Бросаем кубики... ')
    print('Значения граней:')
    print(random.randint(1, 6))
    print(random.randint(1, 6))

## Задача 2. 
В интервью с профессором Тимуром вы выясняете, что он хотел бы использовать программу для имитации нескольких поочередных бросаний кубика.

### Решение. 

Будем использовать цикл while, который имитирует один бросок кубиков и затем спрашивает пользователя,
следует ли сделать еще один бросок. Цикл будет повторяться до тех пор, пока пользователь отвечает "да", набирая букву "д":

    import random

    again = 'д'
    while again.lower() == 'д':
        print('Бросаем кубики... ')
        print('Значения граней:')
        print(random.randint(1, 6))
        print(random.randint(1, 6))
        again = input('Бросить кубики еще раз? (д = да, н = нет): ')

## Задача 3. 

Профессор Тимур был так доволен написанным вами симулятором бросания кубиков, что попросил вас разработать еще одну программу. Он хотел бы иметь симулятор десятикратного поочередного подбрасывания монеты. 

Всякий раз, когда программа имитирует подбрасывание монеты, она должна случайным образом показывать "орла" или "решку".

### Решение. 

Мы можем сымитировать бросание монеты путем генерации случайного числа в диапазоне от 0 до 1. Для генерации целых чисел мы будем использовать функцию randint():

    import random

    for _ in range(10):
        num = random.randint(0, 1)
        if num == 0:
            print('Орел')
        else:
            print('Решка')


# shuffle()

Функция shuffle() принимает список в качестве обязательного аргумента и перемешивает его случайным образом.

Следующий код перемешивает список numbers случайным образом, а затем выводит его содержимое:

    import random

    numbers = [1, 2, 3, 4, 5, 6, 7, 8]
    random.shuffle(numbers)
    print(numbers)

Результатом работы такого кода может быть:

    [4, 7, 8, 1, 2, 3, 6, 5]

# choice()

Функция choice() принимает список (строку) в качестве обязательного аргумента и возвращает один случайный элемент из переданного списка (строки).

Следующий код выводит по одному случайному элементу из строки 'BEEGEEK' и списков [1, 2, 3, 4], ['a', 'b', 'c', 'd']:

    import random

    print(random.choice('BEEGEEK'))
    print(random.choice([1, 2, 3, 4]))
    print(random.choice(['a', 'b', 'c', 'd']))

Результатом работы такого кода может быть:

    E
    3
    c

# sample()

Функция sample() принимает два обязательных аргумента: список (строку) и количество случайных элементов, а возвращает список случайных элементов в указанном количестве.

Результатом работы кода:

    import random
    
    numbers = [2, 5, 8, 9, 12]

    print(random.sample(numbers, 1))
    print(random.sample(numbers, 2))
    print(random.sample(numbers, 3))
    print(random.sample(numbers, 5))

может быть:

    [9]
    [12, 5]
    [9, 2, 8]
    [12, 8, 9, 5, 2]

Количество случайных элементов не должно превышать длину начального списка (строки). Следующий код:

    import random
    
    numbers = [2, 5, 8, 9, 12]

    print(random.sample(numbers, 6))

приведет к ошибке:

    ValueError: Sample larger than population or is negative

## Примечания
### Примечание. 
Подробнее о модуле random можно почитать тут.
https://docs.python.org/3/library/random.html#

# 15.2 Числовая угадайка

## Угадайка чисел

### Описание проекта: 
программа генерирует случайное число в диапазоне от 1 до 100 и просит пользователя угадать это число. 

Если догадка пользователя больше случайного числа, то программа должна вывести сообщение 'Слишком много, попробуйте еще раз'. 

Если догадка меньше случайного числа, то программа должна вывести сообщение 'Слишком мало, попробуйте еще раз'. 

Если пользователь угадывает число, то программа должна поздравить его и вывести сообщение 'Вы угадали, поздравляем!'.

Составляющие проекта:

+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Работа с модулем random для генерации случайных чисел.

## Оптимальная стратегия угадывания числа

Чтобы гарантированно угадать задуманное число от 1 до 100 потребуется не более 7 попыток.

Оптимальный алгоритм угадывания: положим left = 1 и right = 100.

+ Называем число, равное middle = (left + right) // 2;
+ Если число middle равно задуманному числу, то мы угадали!;
+ Если число middle меньше задуманного числа, то положим left = middle + 1 и продолжим алгоритм;
+ Если число middle больше задуманного числа, то положим right = middle - 1 и продолжим алгоритм.

Поскольку на каждой итерации мы отбрасываем половину чисел, то гарантировано угадаем задуманное число за величину, равную log 2 ​n (двоичный логарифм) округленную до целого в большую сторону. При n = 100 получаем 7 попыток.

Примечание 1. Почитать подробнее о двоичном логарифме можно тут.
https://ru.wikipedia.org/wiki/Двоичный_логарифм

Примечание 2. Модуль math содержит функцию, вычисляющую двоичный логарифм.

## Заголовок программы

1. Подключите модуль random;
2. Сгенерируйте случайное число от 1 до 100;
3. Выведите текст приветствия пользователю: 'Добро пожаловать в числовую угадайку'.

## Функция проверки корректности введенных данных

Пользователь потенциально может ввести неверные данные, например, не число, или число превышающее 100. 

Важно предусмотреть такую возможность, чтобы программа продолжала правильно работать. 

Обработка такого рода ситуаций называется защитой от дурака.
https://ru.wikipedia.org/wiki/Защита_от_дурака

+ Напишите функцию is_valid() в которую передается один строковый аргумент. 

    Функция возвращает значение True если переданный аргумент является целым числом от 1 до 100 и False в противном случае. 

## Основной цикл программы

1. Организуйте цикл, который будет запрашивать у пользователя данные (цикл может быть бесконечным (while True) или может использовать сигнальную метку с последующим переключением, после угадывания числа);

2. Запросите у пользователя число от 1 до 00;
3. Проверьте введенные данные с помощью функции is_valid():
    + если данные некорректны, выведите текст: 'А может быть все-таки введем целое число от 1 до 100?' и перейдите к следующей итерации основного цикла;
    + если данные корректны, преобразуйте их к целому числу для удобства дальнейшей работы.

## Сравнение введенного числа с загаданным

1. Организуйте сравнение введенного числа с загаданным числом:
    + Если введенное число меньше загаданного числа, выведите текст: 'Ваше число меньше загаданного, попробуйте еще разок';
    + Если введенное число больше загаданного числа, выведите текст: 'Ваше число больше загаданного, попробуйте еще разок';
    + Если введенное число равно загаданному числу, выведите текст: 'Вы угадали, поздравляем!'.
2. Выведите прощальное сообщение пользователю: 'Спасибо, что играли в числовую угадайку. Еще увидимся...'.
# TODO:
## Улучшения проекта
1. Добавьте подсчет попыток, сделанных пользователем. Когда число отгадано, программа должна показать количество попыток;
2. Добавьте возможность генерации нового числа (повторная игра), после того, как пользователь угадал число;
3. Добавить возможность указания правой границы для случайного выбора числа (от 1 до n).

# 15.3 Магический шар 8
## Магический шар 8
### Описание проекта: 

Магический шар 8 (шар судьбы) — шуточный способ предсказывать будущее. Программа должна просить пользователя задать некий вопрос, чтобы случайным образом на него ответить.

## Составляющие проекта:

+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Работа с модулем random для генерации случайных чисел.
## Варианты ответов

Традиционно шар имеет 2020 ответов, которые можно разделить на четыре группы.

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/039.PNG)

Положительные	            Нерешительно положительные Нейтральные	                    Отрицательные
Бесспорно	                Мне кажется - да	       Пока неясно, попробуй снова	    Даже не думай
Предрешено	                Вероятнее всего	           Спроси позже	                    Мой ответ - нет
Никаких сомнений	        Хорошие перспективы	       Лучше не рассказывать	        По моим данным - нет
Определённо да	            Знаки говорят - да	       Сейчас нельзя предсказать	    Перспективы не очень хорошие
Можешь быть уверен в этом	Да	                       Сконцентрируйся и спроси опять	Весьма сомнительно


## Примечания
### Примечание 1. 

Внутри магического шара есть ёмкость с тёмной жидкостью, например, чернилами. В жидкости плавает фигура с 2020 гранями, на каждой из них нанесено по одному ответу.

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/040.PNG)

Примечание 2. Многогранник с 2020 гранями называется икосаэдр.
https://ru.wikipedia.org/wiki/Икосаэдр

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/041.PNG)

## Заголовок программы
1. Подключите модуль random;
2. Создайте список answers, содержащий 20 потенциальных ответов (Бесспорно, Предрешено, и т.д.).

## Приветствие пользователя
1. Выведите текстовое сообщение: 'Привет Мир, я магический шар, и я знаю ответ на любой твой вопрос.';
2. Уточните как зовут пользователя;
3. Выведите слова приветствия, например, 'Привет Тимур'.

## Основной цикл программы
1. Организуйте цикл, который будет запрашивать у пользователя данные;
2. Запросите у пользователя вопрос;
3. Выведите случайный ответ с помощью функции choice() передав список answers в качестве аргумента;
4. Уточните у пользователя, хочет ли он задать еще один вопрос, если да, то вернитесь в основной цикл программы, если нет выведите сообщение 'Возвращайся если возникнут вопросы!' и завершите программу.

# 15.4 Генератор безопасных паролей

## Генератор безопасных паролей

### Описание проекта: 

программа генерирует заданное количество паролей и включает в себя умную настройку на длину пароля, а также на то, какие символы требуется в него включить, а какие исключить.

## Составляющие проекта:

+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл for;
+ Написание пользовательских функций;
+ Работа с модулем random для генерации случайных чисел.

## Заголовок программы
1. Подключите модуль random;
2. Создайте строковые константы:
###
    digits: 0123456789;
    lowercase_letters: abcdefghijklmnopqrstuvwxyz;
    uppercase_letters: ABCDEFGHIJKLMNOPQRSTUVWXYZ;
    punctuation: !#$%&*+-=?@^_.

3. Создайте переменную chars = '', которая будет содержать все символы, которые могут быть в генерируемом пароле.

## Считывание пользовательских данных

Программа должна запрашивать у пользователя следующую информацию:

1. Количество паролей для генерации;
2. Длину одного пароля;
3. Включать ли цифры 0123456789?
4. Включать ли прописные буквы ABCDEFGHIJKLMNOPQRSTUVWXYZ?
5. Включать ли строчные буквы abcdefghijklmnopqrstuvwxyz?
6. Включать ли символы !#$%&*+-=?@^_?
7. Исключать ли неоднозначные символы il1Lo0O?

## Настройка генерируемых паролей
На основании введенной пользователем информации, сформируйте переменную chars, содержащую все символы, которые могут быть в генерируемом пароле.

## Генерации пароля

1. Напишите функцию generate_password(), которая принимает два аргумента:

+ length: длину пароля;
+ chars: алфавит из символов которого состоит пароль;

и возвращает пароль.

2. Используя цикл for, сгенерируйте необходимое количество паролей.

# 15.5 Шифр Цезаря

## Шифр Цезаря

Шифр Цезаря (шифр сдвига) — один из самых простых и наиболее широко известных методов шифрования. 

Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите.

Шифр подстановки — метод шифрования с заменой элементов исходного открытого текста другими, в соответствии с неким правилом.

Например, в шифре со сдвигом вправо на 33 позиции символ A заменяется символом D, символ B — символом E, и так далее, до символа Z, заменяемого символом C.

![Шифр Цезаря](/StepikPython/Python_Generation_for_beginners/pictures/042.png)

Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки со своими генералами.
https://ru.wikipedia.org/wiki/Гай_Юлий_Цезарь

Шифр Цезаря легко взламывается и не имеет почти никакого практического применения.

## Математическая модель
Если сопоставить каждый символ алфавита с его порядковым номером (нумеруя с 00), то шифрование и дешифрование можно выразить формулами модульной арифметики:

    y = (x + k) mod n, 
    x = (y − k) mod n,

где x — символ открытого текста, y — символ шифрованного текста, n — мощность алфавита (количество символов), а k — ключ.
https://ru.wikipedia.org/wiki/Мощность_множества

Под операцией mod подразумевается операция нахождения остатка. В языке Python для нахождения остатка от деления двух чисел, мы используем оператор %.

## Пример

Шифрование с использованием ключа k=3. Буква «Е» «сдвигается» на три буквы вперед и становится буквой «З». Твердый знак, перемещенный на три буквы вперед, становится буквой «Э», буква «Я», перемещенная на три буквы вперед, становится буквой «В», и так далее:

    Исходный алфавит: А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я
    Шифрованный:      Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я А Б В 

Оригинальный текст:

    Съешь же ещё этих мягких французских булок, да выпей чаю.
Шифрованный текст:

    Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.

## Взлом шифра

Шифр Цезаря может быть легко взломан даже в случае, когда взломщик знает только зашифрованный текст. Можно рассмотреть две ситуации:

1. Взломщик знает (или предполагает), что использовался простой шифр подстановки, но не знает, что это — схема Цезаря.
2. Взломщик знает, что использовался шифр Цезаря, но не знает значение сдвига.
В первом случае шифр может быть взломан с применением метода частотного анализа.
https://ru.wikipedia.org/wiki/Частотный_анализ

Используя этот метод, взломщик, вероятно, быстро заметит регулярность в решении и поймет, что используемый шифр — шифр Цезаря.

Во втором случае взлом шифра еще более прост. Существует не так много вариантов значений сдвига (26 для английского языка, 32 для русского языка), все они могут быть проверены перебором.

## Примечания
### Примечание 1. 

Используемое преобразование в шифре Цезаря обычно обозначают как ROT N, где N — сдвиг, ROT — сокращение от слова ROTATE, в данном случае «циклический сдвиг». Например, обозначение ROT 2 обозначает сдвиг на 2 позиции, то есть, «а» превращается в «в», «б» в «г», и так далее, и в конце «ю» превращается в «а» а «я» — в «б».

### Примечание 2. 
Число разных преобразований зависит от длины алфавита:

+ для русского языка возможно 32 разных преобразования (преобразования ROT 0 и ROT 33 сохраняют исходный текст, а дальше начинаются уже повторения);
+ для английского языка возможны 25 разных преобразований (преобразования ROT 0 и ROT 26 сохраняют исходный текст, а дальше начинаются уже повторения).

### Примечание 3. 

Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

### Примечание 4. 
Естественным развитием шифра Цезаря стал шифр Виженера.
https://ru.wikipedia.org/wiki/Шифр_Виженера

## Шифр Цезаря
### Описание проекта: 

требуется написать программу, способную шифровать и дешифровать текст в соответствии с алгоритмом Цезаря. Она должна запрашивать у пользователя следующие данные:

+ направление: шифрование или дешифрование;
+ язык алфавита: русский или английский;
+ шаг сдвига (со сдвигом вправо).

### Примечание 1. 
Считайте, что в русском языке 32 буквы (буква ё отсутствует).

### Примечание 2. 
Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

### Примечание 3. 
Сохраните регистр символов. Например, текст: "Умом Россию не понять" при сдвиге на одну позицию вправо будет преобразован в: "Фнпн Спттйя ож рпоауэ".

### Составляющие проекта:

+ Целые числа (тип int);
+ Модульная арифметика;
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл for/while;
+ Строковые методы.

# 15.6 Калькулятор систем счисления

## Системы счисления

Система счисления — символический метод записи чисел, то есть представление чисел с помощью письменных знаков.

+ число — некоторая абстрактная сущность, мера для описания количества чего-либо;
+ цифра — знак, используемый для записи чисел.

Цифры бывают разные, а самые распространенные — 
+ арабские цифры, представляемые знаками от нуля (0) до девяти (9); 
+ менее распространены римские цифры, их можно встретить на циферблате часов или в обозначении века (XIX век).

Поскольку чисел гораздо больше, чем цифр, для записи числа обычно используется набор цифр. 

Только для самых малых по величине целых чисел достаточно одной цифры.

Существует много способов записи чисел с помощью цифр, называемых системами счисления. 

Величина числа может зависеть от порядка цифр в записи, а может и не зависеть. Все системы счисления можно разделить на 4 основные группы:

+ унарные;
+ позиционные;
+ непозиционные;
+ смешанные.

## Унарные системы счисления

В древние времена, когда люди начали считать, появилась потребность и записывать числа. 

Количество предметов изображалось черточками или насечками на какой-либо твердой поверхности: 
+ камне, 
+ дереве,
+ глине. 

Позже значки стали группировать по три или по пять. 

Такая система записи чисел называется унарной (единичной), так как любое число в ней образуется путем повторения одного знака, символизирующего единицу. 

Отголоски унарной системы счисления встречаются и сегодня:
+ счетные палочки для обучения счету;
+  полоски, нашитые на рукаве и обозначающие на каком курсе учится курсант военного училища.

## Позиционные системы счисления

В позиционных системах счисления значение цифры зависит от ее положения — позиции — в числе.

Например, число 1515 обозначает пятнадцать, 5151 — пятьдесят один.

Позиционные системы счисления позволяют легко производить арифметические расчеты.

Представление чисел с помощью арабских цифр — самая распространенная позиционная система счисления, она называется десятичной системой счисления потому, что использует десять цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9.

Запомни: максимальная цифра (9) на единицу меньше количества цифр (10).

Количество цифр, используемое в системе счисления, называется ее основанием. 

В десятичной системе основание равно десяти, в двоичной системе — двум, ну а в восьмеричной и шестнадцатеричной — соответственно, восьми и шестнадцати.

Запомни: В позиционной системе счисления с основанием p используются цифры от 0 до p − 1.

## Непозиционные системы счисления

В непозиционных системах счисления значение цифры не зависит от ее положения — позиции — в записанном числе. Примером непозиционной системы счисления является римская система (см. примечание).

Запомни: при использовании непозиционных систем счисления очень сложно выполнять математические расчеты и  необходимо большое количество различных знаков для записи чисел, особенно больших.

# Смешанные системы счисления

Смешанные системы счисления — это когда числа, заданные в системе счисления с основанием p изображают с помощью цифр другой системы, с основанием q, где q < p.

Такая система называется q-p - ичной со старшим основанием p и младшим основанием q.

Денежные знаки — пример смешанной системы счисления. Сейчас в России используются монеты и купюры следующих номиналов: по 1, 2, 5, 10, 50, 100, 200, 500, 1000, 2000, 5000 рублей и по 5, 10, 50 копеек. 

Чтобы получить некоторую сумму в рублях, нужно использовать некоторое количество денежных знаков различного достоинства. 

Таким образом, у этой системы целый ряд оснований, равный достоинствам денежных знаков, также используется основание той системы, с помощью которой производится их счет.

## Примечания
### Примечание 1.  

Римская система счисления — непозиционная, в ней для записи чисел используются буквы латинского алфавита:

    I — означает «один» (1);
    V — означает «пять» (5);
    X — означает «десять» (10);
    L — означает «пятьдесят» (50);
    C — означает «сто» (100);
    D — означает «пятьсот» (500);
    M — означает «тысяча» (1000).

Для записи чисел в римской системе используются два правила:

+ каждый меньший знак, поставленный слева от большего, вычитается из него;
+ каждый меньший знак, поставленный справа от большего, прибавляется к нему.

Примеры:

+ число 49 в римской системе счисления имеет вид XLIX = (50 - 10) + (10 - 1) = 40 + 9 (две группы первого вида).
+ число 444 в римской системе счисления будет записано в виде CDXLIV=(500-100)+(50-10)+(5-1)=400+40+4 (три группы второго вида).

Римская система счисления сегодня используется в основном для обозначения знаменательных и юбилейных дат, разделов и глав в книгах.

### Примечание 2. 

Наиболее употребляемыми в настоящее время позиционными системами являются:

1 — единичная (счёт на пальцах, зарубки и др.);
2 — двоичная (в дискретной математике, информатике, программировании);
8 — восьмеричная;
10 — десятичная (используется повсеместно);
12 — двенадцатеричная (счёт дюжинами);
16 — шестнадцатеричная (используется в программировании, информатике).

### Примечание 3. 

Первая позиционная система счисления была придумана еще в Древнем Вавилоне, причем вавилонская нумерация была шестидесятеричная, т.е. в ней использовалось шестьдесят цифр. 

Мы до сих пор считаем, час – 60 минут, минута – 60 секунд, окружность – 360 ∘.

### Примечание 4. 
Для обозначения цифр в системах счисления с основанием больше 10 традиционно используются буквы английского алфавита — 10 = A, 11 = B, 12 = C, и так далее.

# Перевод чисел из любой системы счисления в десятичную

Мы пользуемся свернутой формой записи числа, но мы знаем, что, например, десятичное число

352 = 3 * 100 + 5 * 10 + 2.

В развернутой форме производится умножение цифр числа на степень основания, т.е. 352 = 3 * 10 ** 2 + 5 * 10 ** 1 + 2 10 ** 0.

То есть любое число в позиционной системе счисления можно записать в развернутой форме и перевести в десятичную систему счисления.

## Примеры
### Пример 1. 
Перевести двоичное число 110101_2 в десятичную систему счисления.

### Решение. 
Пронумеруем разряды двоичного числа справа налево начиная с нуля . 

![2](/StepikPython/Python_Generation_for_beginners/pictures/043.PNG)

В памяти компьютера числа представлены в двоичной системе счисления, поэтому в информатике часто возникает необходимость перевода чисел из двоичной системы в десятичную и обратно.

## Пример 2. 
Перевести число из четверичной системы счисления 3211_4 в десятичную систему счисления.

### Решение. 
Пронумеруем разряды четверичного числа справа налево начиная с нуля 

![4](/StepikPython/Python_Generation_for_beginners/pictures/044.PNG)

## Пример 3. 
Перевести число из восьмеричной системы счисления 214_8 в десятичную систему счисления.

Решение. Пронумеруем разряды восьмеричного числа справа налево начиная с нуля ![8](/StepikPython/Python_Generation_for_beginners/pictures/045.PNG)

Пример 4. Перевести число из шестнадцатеричной системы счисления 2AF_16 в десятичную систему счисления.

Решение. Пронумеруем разряды шестнадцатеричного числа справа налево начиная с нуля.

![16](/StepikPython/Python_Generation_for_beginners/pictures/046.PNG)

В записи числа в шестнадцатеричной системе счисления A=10 и F=15.

# Перевод чисел из десятичной системы счисления в любую другую

Для перевода чисел из десятичной системы счисления в любую другую пользуются следующим алгоритмом:

+ делим данное число на основание новой системы счисления и фиксируем целое частное и остаток от деления (остаток всегда меньше основания);
+ если полученное частное больше основания, то делим частное на основание и вновь фиксируем новое частное и остаток от деления;
+ повторяем этот процесс до тех пор, пока частное не получится меньше делителя, то есть основания новой системы счисления;
+ полученные остатки, являющиеся цифрами числа в новой системе счисления, приводим в соответствие с ее алфавитом;
+ записываем последнее частное и полученные остатки в обратном порядке в ряд слева направо.

## Примеры
### Пример 1. 
Перевести десятичное число 25_10 в двоичную систему счисления.

### Решение. 

В соответствии с алгоритмом получаем:

![2](/StepikPython/Python_Generation_for_beginners/pictures/047.PNG)

## Пример 2. 
Перевести десятичное число 125_10 в восьмеричную систему счисления.

Решение. В соответствии с алгоритмом получаем:

![8](/StepikPython/Python_Generation_for_beginners/pictures/048.PNG)

## Пример 3. 
Перевести десятичное число 428_10 в шестнадцатеричную систему счисления.

### Решение. 
Так как в шестнадцатеричной системе счисления A = 10, C = 12, то в соответствии с алгоритмом получаем:

![16](/StepikPython/Python_Generation_for_beginners/pictures/048.PNG)

# Двоичная, восьмеричная и шестнадцатеричная системы счисления

В информатике и программировании часто используются двоичная, восьмеричная и шестнадцатеричная системы счисления. 

В Python встроены три функции bin(), oct(), hex(), которые возвращают строковые представления целого десятичного числа в соответствующей системе счисления.

# bin()
Функция bin() возвращает строку с двоичным представлением указанного целого числа.

Следующий программный код: 

    print(bin(10))
    print(bin(128))
    print(bin(150))
    print(bin(18765))
выводит:

    0b1010
    0b10000000
    0b10010110
    0b100100101001101

Важно: обратите внимание на приставку 0b, которая сигнализирует о том, что число представлено в двоичной системе счисления.

# oct()

Функция oct() возвращает строку с восьмеричным представлением указанного целого числа.

Следующий программный код: 

    print(oct(10))
    print(oct(128))
    print(oct(150))
    print(oct(18765))

выводит:

    0o12
    0o200
    0o226
    0o44515

Важно: обратите внимание на приставку 0o, которая сигнализирует о том, что число представлено в восьмеричной системе счисления.

# hex()

Функция hex() возвращает строку с шестнадцатеричным представлением указанного целого числа.

Следующий программный код: 

    print(hex(10))
    print(hex(128))
    print(hex(150))
    print(hex(18765))

выводит:

    0xa
    0x80
    0x96
    0x494d

Важно: обратите внимание на приставку 0x, которая сигнализирует о том, что число представлено в шестнадцатеричной системе счисления.

## Примечания
### Примечание 1. 
Если нам требуется избавиться от приставок 0b, 0o, 0x, то мы можем воспользоваться строковым срезом:

    num = 127

    bin_num = bin(num)  # 0b1111111
    oct_num = oct(num)  # 0o177
    hex_num = hex(num)  # 0x7f

    print(bin_num[2:])  # 1111111
    print(oct_num[2:])  # 177
    print(hex_num[2:])  # 7f

## Примечание 2. 
Обратите внимание, что функция hex() возвращает шестнадцатеричное число с маленькими символами a, b, c, d, e, f. Для преобразования к верхнему регистру можно использовать строковый метод upper():

    num = 127432

    hex_num = hex(num)          # 0x1f1c8
    print(hex_num[2:].upper())  # 1F1C8

# 15.7 Угадайка слов

## Угадайка слов
### Описание проекта: 
программа загадывает слово, а пользователь должен его угадать. 

Изначально все буквы слова неизвестны. 

Также рисуется виселица с петлей. 

Пользователь предлагает букву, которая может входить в это слово. 

Если такая буква есть в слове, то программа ставит букву столько раз, сколько она встречается в слове. 

Если такой буквы нет, к виселице добавляется круг в петле, изображающий голову. 

Пользователь продолжает отгадывать буквы до тех пор, пока не отгадает всё слово. 

За каждую неудачную попытку добавляется еще одна часть туловища висельника (обычно их 6: голова, туловище, 2 руки и 2 ноги.

## Составляющие проекта:


+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Создание пользовательских функций;
+ Списочные выражения;
+ Работа с модулем random для генерации случайных чисел.

## Примечания

### Примечание 1. 

На английском игра называется Hangman.

### Примечание 2. 

Почитать подробнее об игре можно тут.
https://ru.wikipedia.org/wiki/Виселица_(игра)

## Заголовок программы
1. Подключите модуль random;
2. Создайте глобальный список word_list, содержащий слова, которые будут использоваться в игре.

## Функция, возвращающая случайное слово
Напишите функцию get_word() которая возвращает случайное слово из списка word_list в верхнем регистре.

## Функция, возвращающая текущее состояние

Функция display_hangman() принимает один аргумент tries – количество попыток угадывания слова и возвращает текущее состояние игры в графическом виде:

+ значение tries = 6 соответствует начальному положению, пустая висилица;
+ ...
+ значение tries = 0 соответствует конечному положению, то есть проигрышу и полностью нарисованному телу повешенного. 

### Примечание. 
Для вывода символа бэкслеша \\ используется экранирование символа с помощью \\, то есть комбинация \\\\.
###
    # функция получения текущего состояния
    def display_hangman(tries):
        stages = [  # финальное состояние: голова, торс, обе руки, обе ноги
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |     / \\
                    -
                    ''',
                    # голова, торс, обе руки, одна нога
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |     / 
                    -
                    ''',
                    # голова, торс, обе руки
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |      
                    -
                    ''',
                    # голова, торс и одна рука
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|
                    |      |
                    |     
                    -
                    ''',
                    # голова и торс
                    '''
                    --------
                    |      |
                    |      O
                    |      |
                    |      |
                    |     
                    -
                    ''',
                    # голова
                    '''
                    --------
                    |      |
                    |      O
                    |    
                    |      
                    |     
                    -
                    ''',
                    # начальное состояние
                    '''
                    --------
                    |      |
                    |      
                    |    
                    |      
                    |     
                    -
                    '''
        ]
        return stages[tries]


## Функция play()

Напишите функцию play(), в которой будет осуществляться основная логика игры. Функция play() принимает в качестве аргумента слово word, сгенерированное функцией  get_word().

    def play(word):
        # тело функции

Используйте следующие локальные переменные:

    word_completion = '_' * len(word)  # строка, содержащая символы _ на каждую букву задуманного слова
    guessed = False                    # сигнальная метка
    guessed_letters = []               # список уже названных букв
    guessed_words = []                 # список уже названных слов
    tries = 6                          # количество попыток

1. Функция play() в самом начале должна:
    + отобразить текст 'Давайте играть в угадайку слов!';
    + отобразить текущее состояние игры, распечатав результат вызова функции display_hangman() с начальным количеством допустимых промахов tries = 6;
    + отобразить начальное слово word_completion в виде строки с символом _ на каждую букву задуманного слова;

2. Необходимо обрабатывать ввод букв или слова целиком. 

3. Предусмотрите защиту от дурака, на случай если пользователь ввел символ, не являющийся буквой;

4. Если пользователь вводит уже названную букву или слово, то необходимо ему об этом сообщить, и не засчитывать попытку;

5. Если пользователь угадал букву, то требуется заменить все символы _ соответствующие этой букве;
6. Если пользователь угадал слово целиком, то следует его поздравить и вывести текст 'Поздравляем, вы угадали слово! Вы победили!';
7. Если пользователь исчерпал все свои попытки и не угадал слово, следует вывести загаданное слово.

### Примечание. 

Переводите все символы в верхний регистр.

## Основной цикл программы
1. Организуйте цикл, который будет содержать: генерацию случайного слова с помощью функции get_word(), а затем последующий вызов функции play().
2. Организуйте повторный запуск игры, если пользователь пожелает играть еще раз.

## Улучшения проекта
1. Можно отображать первую и последнюю букву слова;
2. Слова можно выделить в категории и давать подсказку пользователю;
3. Существует также вариант игры с 8 частями — добавляются ступни, а также самый длинный вариант, когда сначала за не отгаданную букву рисуются части самой виселицы.

