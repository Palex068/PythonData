# 15  Работа над мини-проектами

# Содержание

+ [Модуль random](#151-модуль-random)
    + [Случайные числа](#случайные-числа)
    + [Модуль random](#модуль-random)
        + [randint()](#randint)
        + [randrange()](#randrange)
        + [random()](#random)
        + [uniform()](#uniform)
    + [Начальные значения случайного числа](#начальные-значения-случайного-числа)
        + [seed()](#seed)
    + [Примечания](#примечания-1)
    + [Решение задач](#решение-задач)
        + [shuffle()](#shuffle)
        + [choice()](#choice)
        + [sample()](#sample)
    + [Примечания](#примечания-12)
+ [Числовая угадайка](#152-числовая-угадайка)
    + [Угадайка чисел](#угадайка-чисел)
        + [Описание проекта](#описание-проекта-числовая-угадайка)
        + [Составляющие проекта](#составляющие-проекта-числовая-угадайка)
    + [Оптимальная стратегия угадывания числа](#оптимальная-стратегия-угадывания-числа)
    + [Заголовок программы](#заголовок-программы-числовая-угадайка)
    + [Функция проверки корректности введенных данных](#функция-проверки-корректности-введенных-данных-числовая-угадайка)
    + [Основной цикл программы](#основной-цикл-программы-числовая-угадайка)
    + [Сравнение введенного числа с загаданным](#сравнение-введенного-числа-с-загаданным)
    + [Улучшения проекта](#улучшения-проекта-числовая-угадайка)
+ [Магический шар 8](#153-магический-шар-8)
    + [Описание проекта](#описание-проекта-магический-шар)
    + [Составляющие проекта](#составляющие-проекта-магический-шар)
    + [Варианты ответов](#варианты-ответов)
    + [Примечания](#примечания-3)
    + [Заголовок программы](#заголовок-программы-магический-шар)
    + [Приветствие пользователя](#приветствие-пользователя-программы-магический-шар)
    + [Основной цикл](#основной-цикл-программы-магический-шар)
+ [Генератор безопасных паролей](#генератор-безопасных-паролей)
    + [Описание проекта](#описание-проекта-генератор-безопасных-паролей)
    + [Составляющие проекта](#составляющие-проекта-генератор-безопасных-паролей)
    + [Заголовок программы](#заголовок-программы-генератор-безопасных-паролей)
    + [Считывание пользовательских данных](#считывание-пользовательских-данных-программы-генератор-безопасных-паролей)
    + [Настройка генерируемых паролей](#настройка-генерируемых-паролей)
    + [Генерации пароля](#генерации-пароля)
+ [Шифр Цезаря](#155-шифр-цезаря)
    + [Математическая модель](#математическая-модель)
    + [Взлом шифра](#взлом-шифра)
    + [Примечания](#примечания-155)
    + [Описание проекта](#описание-проекта-шифр-цезаря)
    + [Составляющие проекта](#составляющие-проекта-шифр-цезаря)
+ [Калькулятор систем счисления](#156-калькулятор-систем-счисления)
    + [Системы счисления](#системы-счисления)
        + [Унарные системы счисления](#унарные-системы-счисления)
        + [Позиционные системы счисления](#позиционные-системы-счисления)
        + [Непозиционные системы счисления](#непозиционные-системы-счисления)
        + [Смешанные системы счисления](#смешанные-системы-счисления)
        + [Примечания](#примечания-156)
    + [Перевод чисел из любой системы счисления в десятичную](#перевод-чисел-из-любой-системы-счисления-в-десятичную)
    + [Перевод чисел из десятичной системы счисления в любую другую](#перевод-чисел-из-десятичной-системы-счисления-в-любую-другую)
    + [Двоичная, восьмеричная и шестнадцатеричная системы счисления](#двоичная-восьмеричная-и-шестнадцатеричная-системы-счисления)
        + [bin()](#bin)
        + [oct()](#oct)
        + [hex()](#hex)
+ [Угадайка слов](#157-угадайка-слов)
        
[Содержание курса](/StepikPython/Python_Generation_for_beginners/README.MD)

# 15.1 Модуль random

## Тема урока: модуль random

1. Случайные числа
2. Модуль random

Аннотация. Урок посвящен модулю random, который содержит функции по работе со случайными числами.

## Случайные числа

Случайные числа широко используются в различных задачах программирования:

+ случайные числа используются в играх. <br>
Например, компьютерным играм, которые позволяют игроку подбрасывать игральный кубик, нужны случайные числа для представления значений кубика. <br>
Программы, которые раскрывают игральные карты, вынимаемые из перетасованной колоды, используют случайные числа для представления достоинства карт;
+ случайные числа применяются в программах имитационного моделирования. <br>
В некоторых симуляциях компьютер должен случайным образом решить, как будет вести себя человек, животное, насекомое или другое живое существо. <br>
Нередко конструируются формулы, где случайное число используется для определения различных вариантов действий и событий, происходящих в программе;
+ случайные числа распространены в статистических программах, случайным образом отбирающих данные для анализа;
+ случайные числа используются в компьютерной безопасности для шифрования уязвимых данных.

Python предлагает встроенные функции для работы со случайными числами. Эти функции хранятся в модуле random в стандартной библиотеке.

[Содержание](#содержание)

<hr>

## Модуль random

Модуль random предоставляет функции для генерации случайных чисел, букв и случайного выбора элементов последовательности (списка, строки и т.д.).

Для использования этих функций в начале программы необходимо подключить модуль, что делается командой import:

>import random

После подключения модуля мы можем использовать его функции.

[Содержание](#содержание)

<hr>

### randint()

Функция randint() принимает два обязательных аргумента a и b и возвращает случайное целое число из отрезка [a; b].

Следующий код выводит два случайных целых числа: num1 из отрезка [0; 17] и num2 из отрезка [-5; 5] . 

```python
import random

num1 = random.randint(0, 17)
num2 = random.randint(-5, 5)

print(num1)
print(num2)
```

Важно: левая и правая граница a и b включаются в диапазон генерируемых случайных чисел. Результатом вызова функции random.randint(2, 9) может быть любое число от 2 до 9 включительно.

Следующий код выводит 10 случайных целых чисел из диапазона [1; 100]:
```python
import random

for _ in range(10):
    print(random.randint(1, 100))
```

Среди этих чисел возможны повторения, поскольку каждый раз выбирается случайное.

[Содержание](#содержание)

<hr>

### randrange()

Функция randrange()

Если вы помните, как применять функцию range(), то почувствуете себя непринужденно с функцией randrange(). Функция randrange() принимает такие же аргументы, что и функция range(). Различие состоит в том, что функция randrange() не возвращает саму последовательность чисел. 

Вместо этого она возвращает случайно выбранное число из последовательности чисел.

Следующий код присваивает переменной num случайное число в диапазоне от 0 до 9:

```python
import random

num = random.randrange(10)
```

Аргумент 10 задает конечный предел последовательности значений. Функция возвратит случайно выбранное число из последовательности чисел от 0 до конечного предела, исключая сам предел.

Следующий код задает начальное значение и конечный предел последовательности:

```python
import random

num = random.randrange(5, 10)
```

Таким образом в переменной num будет храниться случайное число в диапазоне от 5 до 9.

Следующий код задает начальное значение, конечный предел и величину шага:

```python
import random

num = random.randrange(0, 101, 10)
```

Таким образом в переменной num будет храниться случайное число из последовательности чисел:

$0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100$.

[Содержание](#содержание)

<hr>

### random()

Функции randint() и randrange() возвращают случайное целое число. А вот функция random() возвращает случайное число с плавающей точкой (вещественное число). В функцию random() никаких аргументов не передается. Функция random() возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (исключая 1.0).

Следующий код выводит случайное число с плавающей точкой из диапазона [0.0; 1.0):

```python
import random

num = random.random()
print(num)
```

[Содержание](#содержание)

<hr>

### uniform()

Функция uniform() тоже возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон для отбора значений.

Следующий код выводит случайное число с плавающей точкой из диапазона [1.5; 17.3]:

```python
import random

num = random.uniform(1.5, 17.3)
print(num)
```

[Содержание](#содержание)

<hr>

## Начальные значения случайного числа

Числа, генерируемые функциями модуля random, не являются подлинно случайными. 

Несмотря на то, что обычно их называют случайными числами, это __псевдослучайные числа__, вычисляемые на основе формулы. 

Формула, генерирующая случайные числа, должна быть инициализирована __начальным значением__. 

Оно используется в вычислении, возвращающем следующее случайное число в ряду. 

Когда модуль random импортируется, он получает системное время из внутреннего генератора тактовых импульсов компьютера и использует его как начальное значение. 

Системное время - целое число, представляющее текущую дату и время вплоть до одной сотой секунды. 

Если бы всегда использовалось одно и то же начальное значение, функции генерации случайных чисел всегда  возвращали бы один и тот же ряд псевдослучайных чисел. 

Поскольку системное время меняется каждую сотую долю секунды, можно без опасений утверждать, что всякий раз, когда импортируется модуль random, будет сгенерирована отличающаяся от предыдущих последовательность случайных чисел.

[Содержание](#содержание)

<hr>

### seed()

Вместе с тем, могут иметься некоторые программы, где требуется всегда генерировать одну и ту же последовательность случайных чисел. 

При необходимости для этого можно вызвать функцию seed(), задав начальное значение.

Следующий код генерирует 10 случайных чисел, и при этом содержит инструкцию, явно устанавливающую начальное значение для генератора случайных чисел:

```python
import random

random.seed(17)   # явно устанавливаем начальное значение для генератора случайных чисел

for _ in range(10):
    print(random.randint(1, 100))
```

Результатом выполнения такого кода может быть:

```python
67
54
39
47
38
23
99
91
91
70
```

Если выполнить такой код еще раз, то мы получим ту же самую последовательность псевдослучайных чисел.

[Содержание](#содержание)

<hr>

## Примечания 1

### Примечание 1.1. 

Подключение модуля следующим образом:

```python
from random import *
```

позволяет в дальнейшем не писать название модуля и символ точки при вызове функций модуля.

### Примечание 2.2. 

Функции модуля random на самом деле являются методами одноименного класса random.

### Примечание 2.3. 
Функция randint() реализована на основе функции randrange() следующим образом:

```python
# Return random integer in range [a, b], including both end points.
def randint(self, a, b):
    return self.randrange(a, b + 1)
```

[Содержание](#содержание)

<hr>

## Решение задач

### Задача 1. 
Профессор Тимур преподает вводный курс статистики и попросил вас написать программу, которую он мог бы использовать на занятиях для имитации бросания игральных кубиков. Программа должна случайным образом генерировать два числа в диапазоне от 1 до 6 и показывать их.

### Решение 1. 

Для генерации целых чисел мы будем использовать функцию randint():

```python
import random

print('Бросаем кубики... ')
print('Значения граней:')
print(random.randint(1, 6))
print(random.randint(1, 6))
```

### Задача 2. 
В интервью с профессором Тимуром вы выясняете, что он хотел бы использовать программу для имитации нескольких поочередных бросаний кубика.

### Решение 2. 

Будем использовать цикл while, который имитирует один бросок кубиков и затем спрашивает пользователя,
следует ли сделать еще один бросок. Цикл будет повторяться до тех пор, пока пользователь отвечает "да", набирая букву "д":

```python
import random

again = 'д'
while again.lower() == 'д':
    print('Бросаем кубики... ')
    print('Значения граней:')
    print(random.randint(1, 6))
    print(random.randint(1, 6))
    again = input('Бросить кубики еще раз? (д = да, н = нет): ')
```

### Задача 3. 

Профессор Тимур был так доволен написанным вами симулятором бросания кубиков, что попросил вас разработать еще одну программу. Он хотел бы иметь симулятор десятикратного поочередного подбрасывания монеты. 

Всякий раз, когда программа имитирует подбрасывание монеты, она должна случайным образом показывать "орла" или "решку".

### Решение 3.  

Мы можем сымитировать бросание монеты путем генерации случайного числа в диапазоне от 0 до 1. Для генерации целых чисел мы будем использовать функцию randint():

```python
import random

for _ in range(10):
    num = random.randint(0, 1)
    if num == 0:
        print('Орел')
    else:
        print('Решка')
```

[Содержание](#содержание)

<hr>

## shuffle()

Функция shuffle() принимает список в качестве обязательного аргумента и перемешивает его случайным образом.

Следующий код перемешивает список numbers случайным образом, а затем выводит его содержимое:

```python
import random

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)
print(numbers)
```

Результатом работы такого кода может быть:

```python
[4, 7, 8, 1, 2, 3, 6, 5]
```
[Содержание](#содержание)

<hr>

## choice()

Функция choice() принимает список (строку) в качестве обязательного аргумента и возвращает один случайный элемент из переданного списка (строки).

Следующий код выводит по одному случайному элементу из строки 'BEEGEEK' и списков [1, 2, 3, 4], ['a', 'b', 'c', 'd']:

```python
import random

print(random.choice('BEEGEEK'))
print(random.choice([1, 2, 3, 4]))
print(random.choice(['a', 'b', 'c', 'd']))
```

Результатом работы такого кода может быть:

```python
E
3
c
```

[Содержание](#содержание)

<hr>

## sample()

Функция sample() принимает два обязательных аргумента: список (строку) и количество случайных элементов, а возвращает список случайных элементов в указанном количестве.

Результатом работы кода:

```python
import random

numbers = [2, 5, 8, 9, 12]

print(random.sample(numbers, 1))
print(random.sample(numbers, 2))
print(random.sample(numbers, 3))
print(random.sample(numbers, 5))
```

может быть:
```python
[9]
[12, 5]
[9, 2, 8]
[12, 8, 9, 5, 2]
```

Количество случайных элементов не должно превышать длину начального списка (строки). Следующий код:

```python
import random

numbers = [2, 5, 8, 9, 12]

print(random.sample(numbers, 6))
```

приведет к ошибке:

```python
ValueError: Sample larger than population or is negative
```

[Содержание](#содержание)

<hr>

## Примечания 1.2

### Примечание 1.2.1. 
Подробнее о модуле random можно почитать [тут](https://docs.python.org/3/library/random.html#).

[Содержание](#содержание)

<hr>

# 15.2 Числовая угадайка

## Угадайка чисел

### Описание проекта Числовая угадайка: 
программа генерирует случайное число в диапазоне от 1 до 100 и просит пользователя угадать это число. 

Если догадка пользователя больше случайного числа, то программа должна вывести сообщение 'Слишком много, попробуйте еще раз'. 

Если догадка меньше случайного числа, то программа должна вывести сообщение 'Слишком мало, попробуйте еще раз'. 

Если пользователь угадывает число, то программа должна поздравить его и вывести сообщение 'Вы угадали, поздравляем!'.

### Составляющие проекта Числовая угадайка:
+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Работа с модулем random для генерации случайных чисел.

[Содержание](#содержание)

<hr>

## Оптимальная стратегия угадывания числа

Чтобы гарантированно угадать задуманное число от 1 до 100 потребуется не более 7 попыток.

__Оптимальный алгоритм угадывания__: положим left = 1 и right = 100.

+ Называем число, равное middle = (left + right) // 2;
+ Если число middle равно задуманному числу, то мы угадали!;
+ Если число middle меньше задуманного числа, то положим left = middle + 1 и продолжим алгоритм;
+ Если число middle больше задуманного числа, то положим right = middle - 1 и продолжим алгоритм.

Поскольку на каждой итерации мы отбрасываем половину чисел, то гарантировано угадаем задуманное число за величину, равную $log_2 \space ​n$ (двоичный логарифм) округленную до целого в большую сторону. При $n = 100$ получаем $7$ попыток.

Примечание 1. Почитать подробнее о двоичном логарифме можно [тут](https://ru.wikipedia.org/wiki/Двоичный_логарифм).

Примечание 2. Модуль [math](/StepikPython/Python_Generation_for_beginners/006.md#63-модуль-math) содержит функцию, вычисляющую двоичный логарифм.

[Содержание](#содержание)

<hr>

## Заголовок программы Числовая угадайка

1. Подключите модуль random;
2. Сгенерируйте случайное число от 1 до 100;
3. Выведите текст приветствия пользователю: 'Добро пожаловать в числовую угадайку'.

[Содержание](#содержание)

<hr>

## Функция проверки корректности введенных данных Числовая угадайка

Пользователь потенциально может ввести неверные данные, например, не число, или число превышающее 100. 

Важно предусмотреть такую возможность, чтобы программа продолжала правильно работать. 

Обработка такого рода ситуаций называется защитой от [дурака](https://ru.wikipedia.org/wiki/Защита_от_дурака).

Напишите функцию is_valid() в которую передается один строковый аргумент. 

Функция возвращает значение True если переданный аргумент является целым числом от 1 до 100 и False в противном случае. 

[Содержание](#содержание)

<hr>

## Основной цикл программы Числовая угадайка

1. Организуйте цикл, который будет запрашивать у пользователя данные (цикл может быть бесконечным (while True) или может использовать сигнальную метку с последующим переключением, после угадывания числа);
2. Запросите у пользователя число от 1 до 00;
3. Проверьте введенные данные с помощью функции is_valid():
+ если данные некорректны, выведите текст: 'А может быть все-таки введем целое число от 1 до 100?' и перейдите к следующей итерации основного цикла;
+ если данные корректны, преобразуйте их к целому числу для удобства дальнейшей работы.

[Содержание](#содержание)

<hr>

## Сравнение введенного числа с загаданным

1. Организуйте сравнение введенного числа с загаданным числом:
    + Если введенное число меньше загаданного числа, выведите текст: 'Ваше число меньше загаданного, попробуйте еще разок';
    + Если введенное число больше загаданного числа, выведите текст: 'Ваше число больше загаданного, попробуйте еще разок';
    + Если введенное число равно загаданному числу, выведите текст: 'Вы угадали, поздравляем!'.
2. Выведите прощальное сообщение пользователю: 'Спасибо, что играли в числовую угадайку. Еще увидимся...'.

[Содержание](#содержание)

<hr>

## TODO:

### Улучшения проекта Числовая угадайка
1. Добавьте подсчет попыток, сделанных пользователем. Когда число отгадано, программа должна показать количество попыток;
2. Добавьте возможность генерации нового числа (повторная игра), после того, как пользователь угадал число;
3. Добавить возможность указания правой границы для случайного выбора числа (от 1 до n).

[Содержание](#содержание)

<hr>

# 15.3 Магический шар 8

## Магический шар 8

### Описание проекта Магический шар: 

Магический шар 8 (шар судьбы) — шуточный способ предсказывать будущее. Программа должна просить пользователя задать некий вопрос, чтобы случайным образом на него ответить.

## Составляющие проекта Магический шар:

+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Работа с модулем random для генерации случайных чисел.

[Содержание](#содержание)

<hr>

## Варианты ответов

Традиционно шар имеет $20$ ответов, которые можно разделить на четыре группы.

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/039.PNG)

|Положительные | Нерешительно положительные | Нейтральные | Отрицательные |
|--------------|----------------------------|-------------|---------------|
|Бесспорно | Мне кажется - да | Пока неясно, попробуй снова	| Даже не думай |
|Предрешено | Вероятнее всего | Спроси позже | Мой ответ - нет |
|Никаких сомнений | Хорошие перспективы | Лучше не рассказывать | По моим данным - нет |
|Определённо да	| Знаки говорят - да | Сейчас нельзя предсказать | Перспективы не очень хорошие |
|Можешь быть уверен в этом | Да | Сконцентрируйся и спроси опять | Весьма сомнительно |

[Содержание](#содержание)

<hr>

## Примечания 3
### Примечание 3.1. 

Внутри магического шара есть ёмкость с тёмной жидкостью, например, чернилами. В жидкости плавает фигура с $20$ гранями, на каждой из них нанесено по одному ответу.

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/040.PNG)

### Примечание 3.2. 

Многогранник с $20$ гранями называется [икосаэдр](https://ru.wikipedia.org/wiki/Икосаэдр).

![Answers](/StepikPython/Python_Generation_for_beginners/pictures/041.PNG)

[Содержание](#содержание)

<hr>

## Заголовок программы Магический шар
1. Подключите модуль random;
2. Создайте список answers, содержащий 20 потенциальных ответов (Бесспорно, Предрешено, и т.д.).

[Содержание](#содержание)

<hr>

## Приветствие пользователя программы Магический шар
1. Выведите текстовое сообщение: 'Привет Мир, я магический шар, и я знаю ответ на любой твой вопрос.';
2. Уточните как зовут пользователя;
3. Выведите слова приветствия, например, 'Привет Тимур'.

[Содержание](#содержание)

<hr>

## Основной цикл программы Магический шар
1. Организуйте цикл, который будет запрашивать у пользователя данные;
2. Запросите у пользователя вопрос;
3. Выведите случайный ответ с помощью функции choice() передав список answers в качестве аргумента;
4. Уточните у пользователя, хочет ли он задать еще один вопрос, если да, то вернитесь в основной цикл программы, если нет выведите сообщение 'Возвращайся если возникнут вопросы!' и завершите программу.

[Содержание](#содержание)

<hr>


# 15.4 Генератор безопасных паролей

## Генератор безопасных паролей

### Описание проекта Генератор безопасных паролей: 

программа генерирует заданное количество паролей и включает в себя умную настройку на длину пароля, а также на то, какие символы требуется в него включить, а какие исключить.

[Содержание](#содержание)

<hr>

## Составляющие проекта Генератор безопасных паролей:

+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл for;
+ Написание пользовательских функций;
+ Работа с модулем random для генерации случайных чисел.

[Содержание](#содержание)

<hr>

## Заголовок программы Генератор безопасных паролей
1. Подключите модуль random;
2. Создайте строковые константы:

```python
digits = '0123456789'
lowercase_letters = 'abcdefghijklmnopqrstuvwxyz'
uppercase_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
punctuation = '!#$%&*+-=?@^_'
```

3. Создайте переменную chars = '', которая будет содержать все символы, которые могут быть в генерируемом пароле.

[Содержание](#содержание)

<hr>

## Считывание пользовательских данных программы Генератор безопасных паролей

Программа должна запрашивать у пользователя следующую информацию:

1. Количество паролей для генерации;
2. Длину одного пароля;
3. Включать ли цифры 0123456789?
4. Включать ли прописные буквы ABCDEFGHIJKLMNOPQRSTUVWXYZ?
5. Включать ли строчные буквы abcdefghijklmnopqrstuvwxyz?
6. Включать ли символы !#$%&*+-=?@^_?
7. Исключать ли неоднозначные символы il1Lo0O?

[Содержание](#содержание)

<hr>

## Настройка генерируемых паролей
На основании введенной пользователем информации, сформируйте переменную chars, содержащую все символы, которые могут быть в генерируемом пароле.

[Содержание](#содержание)

<hr>

## Генерации пароля

1. Напишите функцию generate_password(), которая принимает два аргумента:

+ length: длину пароля;
+ chars: алфавит из символов которого состоит пароль;

и возвращает пароль.

2. Используя цикл for, сгенерируйте необходимое количество паролей.

[Содержание](#содержание)

<hr>

# 15.5 Шифр Цезаря

## Шифр Цезаря

__Шифр Цезаря (шифр сдвига)__ — один из самых простых и наиболее широко известных методов шифрования. 

__Шифр Цезаря__ — это вид [шифра подстановки](https://ru.wikipedia.org/wiki/Шифр_подстановки), в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите.

Шифр подстановки — метод шифрования с заменой элементов исходного открытого текста другими, в соответствии с неким правилом.

Например, в шифре со сдвигом вправо на $3$ позиции символ A заменяется символом D, символ B — символом E, и так далее, до символа Z, заменяемого символом C.

![Шифр Цезаря](/StepikPython/Python_Generation_for_beginners/pictures/042.png)

Шифр назван в честь римского полководца [Гая Юлия Цезаря](https://ru.wikipedia.org/wiki/Гай_Юлий_Цезарь), использовавшего его для секретной переписки со своими генералами.


Шифр Цезаря легко взламывается и не имеет почти никакого практического применения.

[Содержание](#содержание)

<hr>

## Математическая модель
Если сопоставить каждый символ алфавита с его порядковым номером (нумеруя с 00), то шифрование и дешифрование можно выразить формулами модульной арифметики:

$y = (x + k) mod \space n$, <br>
$x = (y − k) mod \space n$,

где:<br>
x — символ открытого текста,<br>
y — символ шифрованного текста,<br>
n — [мощность алфавита](https://ru.wikipedia.org/wiki/Мощность_множества) (количество символов), <br>
k — ключ.

Под операцией mod подразумевается операция нахождения остатка. В языке Python для нахождения остатка от деления двух чисел, мы используем оператор %.

### Пример

Шифрование с использованием ключа k=3. Буква «Е» «сдвигается» на три буквы вперед и становится буквой «З». Твердый знак, перемещенный на три буквы вперед, становится буквой «Э», буква «Я», перемещенная на три буквы вперед, становится буквой «В», и так далее:

> Исходный алфавит: А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я
>Шифрованный:      Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я А Б В 

Оригинальный текст:

>Съешь же ещё этих мягких французских булок, да выпей чаю.

Шифрованный текст:

>Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.

[Содержание](#содержание)

<hr>

## Взлом шифра

Шифр Цезаря может быть легко взломан даже в случае, когда взломщик знает только зашифрованный текст. Можно рассмотреть две ситуации:

1. Взломщик знает (или предполагает), что использовался простой шифр подстановки, но не знает, что это — схема Цезаря.
2. Взломщик знает, что использовался шифр Цезаря, но не знает значение сдвига.
В первом случае шифр может быть взломан с применением метода [частотного анализа](https://ru.wikipedia.org/wiki/Частотный_анализ).


Распределение букв в типичном образце текста на английском
языке имеет характерный и предсказуемый вид

![015](/StepikPython/Python_Generation_for_beginners/pictures/015_001.png)

Используя этот метод, взломщик, вероятно, быстро заметит регулярность в решении и поймет, что используемый шифр — шифр Цезаря.

Во втором случае взлом шифра еще более прост. Существует не так много вариантов значений сдвига (26 для английского языка, 32 для русского языка), все они могут быть проверены перебором.

[Содержание](#содержание)

<hr>

## Примечания 15.5
### Примечание 15.5.1. 

Используемое преобразование в шифре Цезаря обычно обозначают как ROT N, где N — сдвиг, ROT — сокращение от слова ROTATE, в данном случае «циклический сдвиг». Например, обозначение ROT 2 обозначает сдвиг на 2 позиции, то есть, «а» превращается в «в», «б» в «г», и так далее, и в конце «ю» превращается в «а» а «я» — в «б».

### Примечание 15.5.2. 
Число разных преобразований зависит от длины алфавита:

+ для русского языка возможно 32 разных преобразования (преобразования ROT 0 и ROT 33 сохраняют исходный текст, а дальше начинаются уже повторения);
+ для английского языка возможны 25 разных преобразований (преобразования ROT 0 и ROT 26 сохраняют исходный текст, а дальше начинаются уже повторения).

### Примечание 15.5.3. 

Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

### Примечание 15.5.4. 
Естественным развитием шифра Цезаря стал шифр [Виженера](https://ru.wikipedia.org/wiki/Шифр_Виженера).

[Содержание](#содержание)

<hr>


## Описание проекта Шифр Цезаря: 

требуется написать программу, способную шифровать и дешифровать текст в соответствии с алгоритмом Цезаря. Она должна запрашивать у пользователя следующие данные:

+ направление: шифрование или дешифрование;
+ язык алфавита: русский или английский;
+ шаг сдвига (со сдвигом вправо).

Считайте, что в русском языке 32 буквы (буква ё отсутствует).

Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

Сохраните регистр символов. Например, текст: "Умом Россию не понять" при сдвиге на одну позицию вправо будет преобразован в: "Фнпн Спттйя ож рпоауэ".

[Содержание](#содержание)

<hr>

## Составляющие проекта Шифр Цезаря:

+ Целые числа (тип int);
+ Модульная арифметика;
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл for/while;
+ Строковые методы.

[Содержание](#содержание)

<hr>

# 15.6 Калькулятор систем счисления

## Системы счисления

__Система счисления__ — символический метод записи чисел, то есть представление чисел с помощью письменных знаков.

+ число — некоторая абстрактная сущность, мера для описания количества чего-либо;
+ цифра — знак, используемый для записи чисел.

Цифры бывают разные, а самые распространенные — 
+ __арабские цифры__, представляемые знаками от нуля $(0)$ до девяти $(9)$; 
+ менее распространены __римские цифры__, их можно встретить на циферблате часов или в обозначении века (XIX век).

Поскольку чисел гораздо больше, чем цифр, для записи числа обычно используется набор цифр. 

Только для самых малых по величине целых чисел достаточно одной цифры.

Существует много способов записи чисел с помощью цифр, __называемых системами счисления__. 

Величина числа может зависеть от порядка цифр в записи, а может и не зависеть. Все системы счисления можно разделить на 4 основные группы:

+ унарные;
+ позиционные;
+ непозиционные;
+ смешанные.

[Содержание](#содержание)

<hr>

### Унарные системы счисления

В древние времена, когда люди начали считать, появилась потребность и записывать числа. 

Количество предметов изображалось черточками или насечками на какой-либо твердой поверхности: 
+ камне, 
+ дереве,
+ глине. 

Позже значки стали группировать по три или по пять. 

Такая система записи чисел называется унарной (единичной), так как любое число в ней образуется путем повторения одного знака, символизирующего единицу. 

Отголоски унарной системы счисления встречаются и сегодня:
+ счетные палочки для обучения счету;
+  полоски, нашитые на рукаве и обозначающие на каком курсе учится курсант военного училища.

[Содержание](#содержание)

<hr>

### Позиционные системы счисления

В позиционных системах счисления значение цифры зависит от ее положения — позиции — в числе.

Например, число $15$ обозначает пятнадцать, $51$ — пятьдесят один.

Позиционные системы счисления позволяют легко производить арифметические расчеты.

Представление чисел с помощью арабских цифр — самая распространенная позиционная система счисления, она называется __десятичной системой счисления__ потому, что использует десять цифр: $0, 1, 2, 3, 4, 5, 6, 7, 8, 9$.

Запомни: максимальная цифра $(9)$ на единицу меньше количества цифр $(10)$.

Количество цифр, используемое в системе счисления, называется ее основанием. 

В десятичной системе основание равно десяти, в двоичной системе — двум, ну а в восьмеричной и шестнадцатеричной — соответственно, восьми и шестнадцати.

Запомни: В позиционной системе счисления с основанием p используются цифры от $0$ до $p − 1$.

[Содержание](#содержание)

<hr>

### Непозиционные системы счисления

В непозиционных системах счисления значение цифры не зависит от ее положения — позиции — в записанном числе. Примером непозиционной системы счисления является [римская система](https://ru.wikibooks.org/wiki/Римская_система_счисления) (см. примечание).

Запомни: при использовании непозиционных систем счисления очень сложно выполнять математические расчеты и  необходимо большое количество различных знаков для записи чисел, особенно больших.

[Содержание](#содержание)

<hr>

### Смешанные системы счисления

Смешанные системы счисления — это когда числа, заданные в системе счисления с основанием $p$ изображают с помощью цифр другой системы, с основанием $q$, где $q < p$.

Такая система называется q-p - ичной со старшим основанием p и младшим основанием q.

Денежные знаки — пример __смешанной__ системы счисления. Сейчас в России используются монеты и купюры следующих номиналов: по $1, 2, 5, 10, 50, 100, 200, 500, 1000, 2000, 5000$ рублей и по $5, 10, 50$ копеек. 

Чтобы получить некоторую сумму в рублях, нужно использовать некоторое количество денежных знаков различного достоинства. 

Таким образом, у этой системы целый ряд оснований, равный достоинствам денежных знаков, также используется основание той системы, с помощью которой производится их счет.

[Содержание](#содержание)

<hr>

## Примечания 15.6
### Примечание 15.6.1.  

Римская система счисления — непозиционная, в ней для записи чисел используются буквы латинского алфавита:

    I — означает «один» (1);
    V — означает «пять» (5);
    X — означает «десять» (10);
    L — означает «пятьдесят» (50);
    C — означает «сто» (100);
    D — означает «пятьсот» (500);
    M — означает «тысяча» (1000).

Для записи чисел в римской системе используются два правила:

+ каждый меньший знак, поставленный слева от большего, вычитается из него;
+ каждый меньший знак, поставленный справа от большего, прибавляется к нему.

Примеры:

+ число 49 в римской системе счисления имеет вид XLIX = (50 - 10) + (10 - 1) = 40 + 9 (две группы первого вида).
+ число 444 в римской системе счисления будет записано в виде CDXLIV=(500-100)+(50-10)+(5-1)=400+40+4 (три группы второго вида).

Римская система счисления сегодня используется в основном для обозначения знаменательных и юбилейных дат, разделов и глав в книгах.

### Примечание 15.6.2. 

Наиболее употребляемыми в настоящее время позиционными системами являются:

>1 — единичная (счёт на пальцах, зарубки и др.);<br>
>2 — двоичная (в дискретной математике, информатике, программировании);<br>
>8 — восьмеричная;<br>
>10 — десятичная (используется повсеместно);<br>
>12 — двенадцатеричная (счёт дюжинами);<br>
>16 — шестнадцатеричная (используется в программировании, информатике).<br>

### Примечание 15.6.3. 

Первая позиционная система счисления была придумана еще в Древнем Вавилоне, причем вавилонская нумерация была шестидесятеричная, т.е. в ней использовалось шестьдесят цифр. 

Мы до сих пор считаем, час – 60 минут, минута – 60 секунд, окружность – 360 ∘.

### Примечание 4. 
Для обозначения цифр в системах счисления с основанием больше 10 традиционно используются буквы английского алфавита — 10 = A, 11 = B, 12 = C, и так далее.

[Содержание](#содержание)

<hr>

## Перевод чисел из любой системы счисления в десятичную

Мы пользуемся свернутой формой записи числа, но мы знаем, что, например, десятичное число

352 = 3 * 100 + 5 * 10 + 2.

В развернутой форме производится умножение цифр числа на степень основания, т.е. 352 = 3 * 10 ** 2 + 5 * 10 ** 1 + 2 10 ** 0.

То есть любое число в позиционной системе счисления можно записать в развернутой форме и перевести в десятичную систему счисления.

[Содержание](#содержание)

<hr>

## Примеры 1
### Пример 1.1. 
Перевести двоичное число 110101_2 в десятичную систему счисления.

__Решение__<br>
Пронумеруем разряды двоичного числа справа налево начиная с нуля . 

![2](/StepikPython/Python_Generation_for_beginners/pictures/043.PNG)

В памяти компьютера числа представлены в двоичной системе счисления, поэтому в информатике часто возникает необходимость перевода чисел из двоичной системы в десятичную и обратно.

### Пример 1.2. 
Перевести число из четверичной системы счисления 3211_4 в десятичную систему счисления.

__Решение__ <br>
Пронумеруем разряды четверичного числа справа налево начиная с нуля 

![4](/StepikPython/Python_Generation_for_beginners/pictures/044.PNG)

### Пример 1.3. 
Перевести число из восьмеричной системы счисления 214_8 в десятичную систему счисления.

__Решение.__<br> 
Пронумеруем разряды восьмеричного числа справа налево начиная с нуля ![8](/StepikPython/Python_Generation_for_beginners/pictures/045.PNG)

### Пример 1.4. 
Перевести число из шестнадцатеричной системы счисления 2AF_16 в десятичную систему счисления.

Решение. Пронумеруем разряды шестнадцатеричного числа справа налево начиная с нуля.

![16](/StepikPython/Python_Generation_for_beginners/pictures/046.PNG)

В записи числа в шестнадцатеричной системе счисления A=10 и F=15.

[Содержание](#содержание)

<hr>

## Перевод чисел из десятичной системы счисления в любую другую

Для перевода чисел из десятичной системы счисления в любую другую пользуются следующим алгоритмом:

+ делим данное число на основание новой системы счисления и фиксируем целое частное и остаток от деления (остаток всегда меньше основания);
+ если полученное частное больше основания, то делим частное на основание и вновь фиксируем новое частное и остаток от деления;
+ повторяем этот процесс до тех пор, пока частное не получится меньше делителя, то есть основания новой системы счисления;
+ полученные остатки, являющиеся цифрами числа в новой системе счисления, приводим в соответствие с ее алфавитом;
+ записываем последнее частное и полученные остатки в обратном порядке в ряд слева направо.

[Содержание](#содержание)

<hr>

## Примеры 2
### Пример 2.1. 
Перевести десятичное число 25_10 в двоичную систему счисления.

__Решение.__ <br>

В соответствии с алгоритмом получаем:

![2](/StepikPython/Python_Generation_for_beginners/pictures/047.PNG)

### Пример 2.2. 
Перевести десятичное число 125_10 в восьмеричную систему счисления.

Решение. В соответствии с алгоритмом получаем:

![8](/StepikPython/Python_Generation_for_beginners/pictures/048.PNG)

### Пример 2.3. 
Перевести десятичное число 428_10 в шестнадцатеричную систему счисления.

__Решение.__
Так как в шестнадцатеричной системе счисления A = 10, C = 12, то в соответствии с алгоритмом получаем:

![16](/StepikPython/Python_Generation_for_beginners/pictures/048.PNG)

[Содержание](#содержание)

<hr>

## Двоичная, восьмеричная и шестнадцатеричная системы счисления

В информатике и программировании часто используются двоичная, восьмеричная и шестнадцатеричная системы счисления. 

В Python встроены три функции bin(), oct(), hex(), которые возвращают строковые представления целого десятичного числа в соответствующей системе счисления.

[Содержание](#содержание)

<hr>

## bin()
Функция bin() возвращает строку с двоичным представлением указанного целого числа.

Следующий программный код: 

```python
print(bin(10))
print(bin(128))
print(bin(150))
print(bin(18765))
```

выводит:

```python
0b1010
0b10000000
0b10010110
0b100100101001101
```

Важно: обратите внимание на приставку 0b, которая сигнализирует о том, что число представлено в двоичной системе счисления.

[Содержание](#содержание)

<hr>

## oct()

Функция oct() возвращает строку с восьмеричным представлением указанного целого числа.

Следующий программный код: 

```python
print(oct(10))
print(oct(128))
print(oct(150))
print(oct(18765))
```

выводит:

```python
0o12
0o200
0o226
0o44515
```

Важно: обратите внимание на приставку 0o, которая сигнализирует о том, что число представлено в восьмеричной системе счисления.

[Содержание](#содержание)

<hr>

## hex()

Функция hex() возвращает строку с шестнадцатеричным представлением указанного целого числа.

Следующий программный код: 

```python
print(hex(10))
print(hex(128))
print(hex(150))
print(hex(18765))
```

выводит:

```python
0xa
0x80
0x96
0x494d
```

Важно: обратите внимание на приставку 0x, которая сигнализирует о том, что число представлено в шестнадцатеричной системе счисления.

[Содержание](#содержание)

<hr>

## Примечания 15.6.2
### Примечание 15.6.2.1. 
Если нам требуется избавиться от приставок 0b, 0o, 0x, то мы можем воспользоваться строковым срезом:

```python
num = 127

bin_num = bin(num)  # 0b1111111
oct_num = oct(num)  # 0o177
hex_num = hex(num)  # 0x7f

print(bin_num[2:])  # 1111111
print(oct_num[2:])  # 177
print(hex_num[2:])  # 7f
```

## Примечание 15.6.2.2. 
Обратите внимание, что функция hex() возвращает шестнадцатеричное число с маленькими символами a, b, c, d, e, f. Для преобразования к верхнему регистру можно использовать строковый метод upper():

```python
num = 127432

hex_num = hex(num)          # 0x1f1c8
print(hex_num[2:].upper())  # 1F1C8
```

[Содержание](#содержание)

<hr>

# 15.7 Угадайка слов

## Угадайка слов
### Описание проекта: 
программа загадывает слово, а пользователь должен его угадать. 

Изначально все буквы слова неизвестны. 

Также рисуется виселица с петлей. 

Пользователь предлагает букву, которая может входить в это слово. 

Если такая буква есть в слове, то программа ставит букву столько раз, сколько она встречается в слове. 

Если такой буквы нет, к виселице добавляется круг в петле, изображающий голову. 

Пользователь продолжает отгадывать буквы до тех пор, пока не отгадает всё слово. 

За каждую неудачную попытку добавляется еще одна часть туловища висельника (обычно их 6: голова, туловище, 2 руки и 2 ноги.

## Составляющие проекта:


+ Целые числа (тип int);
+ Переменные;
+ Ввод / вывод данных (функции input() и print());
+ Условный оператор (if/elif/else);
+ Цикл while;
+ Бесконечный цикл;
+ Операторы break, continue;
+ Создание пользовательских функций;
+ Списочные выражения;
+ Работа с модулем random для генерации случайных чисел.

## Примечания

### Примечание 1. 

На английском игра называется Hangman.

### Примечание 2. 

Почитать подробнее об игре можно тут.
https://ru.wikipedia.org/wiki/Виселица_(игра)

## Заголовок программы
1. Подключите модуль random;
2. Создайте глобальный список word_list, содержащий слова, которые будут использоваться в игре.

## Функция, возвращающая случайное слово
Напишите функцию get_word() которая возвращает случайное слово из списка word_list в верхнем регистре.

## Функция, возвращающая текущее состояние

Функция display_hangman() принимает один аргумент tries – количество попыток угадывания слова и возвращает текущее состояние игры в графическом виде:

+ значение tries = 6 соответствует начальному положению, пустая висилица;
+ ...
+ значение tries = 0 соответствует конечному положению, то есть проигрышу и полностью нарисованному телу повешенного. 

### Примечание. 
Для вывода символа бэкслеша \\ используется экранирование символа с помощью \\, то есть комбинация \\\\.
###
    # функция получения текущего состояния
    def display_hangman(tries):
        stages = [  # финальное состояние: голова, торс, обе руки, обе ноги
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |     / \\
                    -
                    ''',
                    # голова, торс, обе руки, одна нога
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |     / 
                    -
                    ''',
                    # голова, торс, обе руки
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|/
                    |      |
                    |      
                    -
                    ''',
                    # голова, торс и одна рука
                    '''
                    --------
                    |      |
                    |      O
                    |     \\|
                    |      |
                    |     
                    -
                    ''',
                    # голова и торс
                    '''
                    --------
                    |      |
                    |      O
                    |      |
                    |      |
                    |     
                    -
                    ''',
                    # голова
                    '''
                    --------
                    |      |
                    |      O
                    |    
                    |      
                    |     
                    -
                    ''',
                    # начальное состояние
                    '''
                    --------
                    |      |
                    |      
                    |    
                    |      
                    |     
                    -
                    '''
        ]
        return stages[tries]


## Функция play()

Напишите функцию play(), в которой будет осуществляться основная логика игры. Функция play() принимает в качестве аргумента слово word, сгенерированное функцией  get_word().

    def play(word):
        # тело функции

Используйте следующие локальные переменные:

    word_completion = '_' * len(word)  # строка, содержащая символы _ на каждую букву задуманного слова
    guessed = False                    # сигнальная метка
    guessed_letters = []               # список уже названных букв
    guessed_words = []                 # список уже названных слов
    tries = 6                          # количество попыток

1. Функция play() в самом начале должна:
    + отобразить текст 'Давайте играть в угадайку слов!';
    + отобразить текущее состояние игры, распечатав результат вызова функции display_hangman() с начальным количеством допустимых промахов tries = 6;
    + отобразить начальное слово word_completion в виде строки с символом _ на каждую букву задуманного слова;

2. Необходимо обрабатывать ввод букв или слова целиком. 

3. Предусмотрите защиту от дурака, на случай если пользователь ввел символ, не являющийся буквой;

4. Если пользователь вводит уже названную букву или слово, то необходимо ему об этом сообщить, и не засчитывать попытку;

5. Если пользователь угадал букву, то требуется заменить все символы _ соответствующие этой букве;
6. Если пользователь угадал слово целиком, то следует его поздравить и вывести текст 'Поздравляем, вы угадали слово! Вы победили!';
7. Если пользователь исчерпал все свои попытки и не угадал слово, следует вывести загаданное слово.

### Примечание. 

Переводите все символы в верхний регистр.

## Основной цикл программы
1. Организуйте цикл, который будет содержать: генерацию случайного слова с помощью функции get_word(), а затем последующий вызов функции play().
2. Организуйте повторный запуск игры, если пользователь пожелает играть еще раз.

## Улучшения проекта
1. Можно отображать первую и последнюю букву слова;
2. Слова можно выделить в категории и давать подсказку пользователю;
3. Существует также вариант игры с 8 частями — добавляются ступни, а также самый длинный вариант, когда сначала за не отгаданную букву рисуются части самой виселицы.

[Содержание курса](/StepikPython/Python_Generation_for_beginners/README.MD)