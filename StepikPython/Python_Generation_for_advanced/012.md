# 12  Модули random и string
# 12.1 Модуль random. Часть 1

## Тема урока: модуль random
1. Случайные числа
2. Псевдослучайные числа
3. Модуль random

Аннотация. Урок посвящен модулю random, который содержит функции по работе с псевдослучайными числами.

# Случайные числа

Случайные числа – последовательность чисел, в которой невозможно предсказать следующее число, зная все предыдущие.

Случайные числа широко используются в различных задачах программирования:

+ в играх (имитация подбрасывания игрального кубика и другие подобные ситуации);
+ в программах имитационного моделирования;
+ в статистических программах, случайным образом отбирающих данные для анализа;
+ в компьютерной безопасности для шифрования уязвимых данных.

Для создания истинно случайных чисел можно бросать монету, игральные кости, или измерять какой-нибудь шумовой сигнал.

# Псевдослучайные числа

Ставить сложные электронные приборы на каждый компьютер для генерации истинно случайных чисел дорого, поэтому математики и программисты создали алгоритмы получения псевдослучайных чисел.

Для обычного человека псевдослучайные числа практически не отличаются от случайных, однако они вычисляются по математической формуле, и зная первое число и формулу, можно определить любое следующее.

Python предлагает встроенные функции для работы с псевдослучайными числами. Эти функции хранятся в модуле random в стандартной библиотеке.

# Модуль random

Модуль random предоставляет функции для генерации псевдослучайных чисел, букв и случайного выбора элементов последовательности (списка, строки и т.д.).

Для использования этих функций в начале программы необходимо подключить модуль, что делается командой import:

    import random

После подключения модуля мы можем использовать его функции.

# randint()

Функция randint() принимает два обязательных аргумента a и b и возвращает псевдослучайное целое число из отрезка [a; b].

Следующий код выводит два псевдослучайных целых числа: num1 из отрезка [0; 17] и num2 из отрезка [-5; 5]. 

    import random

    num1 = random.randint(0, 17)
    num2 = random.randint(-5, 5)

Левая и правая граница a и b включаются в диапазон генерируемых псевдослучайных чисел. Результатом вызова функции random.randint(2, 9) может быть любое число от 2 до 9, включая 2 и 9.

Следующий код выводит 10 псевдослучайных целых чисел из диапазона [1; 100]:

    import random

    for _ in range(10):
        print(random.randint(1, 100))

Среди этих чисел возможны повторения.

# randrange()

Если вы помните, как применять функцию range(), то почувствуете себя непринужденно с функцией randrange(). 

Функция randrange() принимает такие же аргументы, что и функция range(). Различие состоит в том, что функция randrange() не возвращает саму последовательность чисел. Вместо этого она возвращает случайно выбранное число из последовательности чисел.

Следующий код присваивает переменной num псевдослучайное число в диапазоне от 0 до 9:

    import random

    num = random.randrange(10)

Аргумент 10 задает конечный предел последовательности значений. Функция возвратит случайно выбранное число из последовательности чисел от 0 до конечного предела, исключая сам предел.

Следующий код задает начальное значение и конечный предел последовательности:

    import random

    num = random.randrange(5, 10)

Таким образом в переменной num будет храниться псевдослучайное число в диапазоне от 5 до 9.

Следующий код задает начальное значение, конечный предел и величину шага:

    import random

    num = random.randrange(0, 101, 10)

Таким образом в переменной num будет храниться псевдослучайное число из последовательности чисел: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100.

# random()

Функции randint() и randrange() возвращают псевдослучайное целое число. А вот функция random() возвращает псевдослучайное число с плавающей точкой (вещественное число). В функцию random() никаких аргументов не передается. Функция random() возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (исключая 1.0).

Следующий код выводит случайное число с плавающей точкой из диапазона [0.0; 1.0):

    import random

    num = random.random()
    print(num)

# uniform()

Функция uniform() тоже возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон для отбора значений.

Следующий код выводит псевдослучайное число с плавающей точкой из диапазона [1.5; 17.3] (включительно):

    import random

    num = random.uniform(1.5, 17.3)
    print(num)

# seed()

Как уже было сказано псевдослучайные числа вычисляются на основе некой формулы. Генерация случайных чисел инициируется начальным значением. Оно используется в вычислении, возвращающем следующее случайное число в ряду. Когда модуль random импортируется, он получает системное время из внутреннего генератора тактовых импульсов компьютера и использует его как начальное значение. Системное время – целое число, представляющее собой текущую дату и время вплоть до сотой секунды. Если бы всегда использовалось одно и то же начальное значение, функции генерации случайных чисел всегда  возвращали бы один и тот же ряд псевдослучайных чисел. Поскольку системное время меняется каждую сотую долю секунды, можно утверждать, что всякий раз, когда импортируется модуль random, будет создана отличающаяся от предыдущих последовательность случайных чисел.

Вместе с тем, некоторые программы требуют генерации одной и той же последовательности случайных чисел. Для этого можно вызвать функцию seed(), задав начальное значение.

Следующий код генерирует 10 псевдослучайных чисел, и при этом содержит инструкцию, явно устанавливающую начальное значение для генератора случайных чисел:

    import random

    random.seed(17)   # явно устанавливаем начальное значение для генератора случайных чисел

    for _ in range(10):
        print(random.randint(1, 100))

Результат выполнения такого кода:

    67
    54
    39
    47
    38
    23
    99
    91
    91
    70

Если выполнить код еще раз, получим ту же самую последовательность псевдослучайных чисел.

## Примечания
### Примечание 1. 
Подключение модуля следующим образом:

    from random import *

позволяет в дальнейшем не писать название модуля и символ точки при вызове функций модуля.

### Примечание 2. 
Функции модуля random на самом деле являются методами одноименного класса random.

### Примечание 3. 
В Python для генерации псевдослучайных чисел используется один из самых совершенных алгоритмов генерации псевдослучайных чисел – "вихрь Мерсенна", разработанный в 1997 году. Реализация выполнена на языке C, является быстрой и потокобезопасной.
https://ru.wikipedia.org/wiki/Вихрь_Мерсенна
### Примечание 4. 
Настоящие случайные числа можно получить с сайта. Данный сайт использует атмосферный шум для создания по-настоящему случайных чисел.

### Примечание 5. 
Пусть r – случайное число из интервала (0; 1). Для того, чтобы перевести такое число в интервал (a; b) можно воспользоваться формулой a + (b-a) ** r.

# 12.2 Модуль random. Часть 2

## Тема урока: модуль random
1. Метод shuffle()
2. Метод choice()
3. Метод sample()
4. Модуль string

Аннотация. Урок посвящен модулю random, в частности, методам работы с последовательностями.

# shuffle()

Метод shuffle() принимает список в качестве обязательного аргумента и перемешивает его случайным образом.

Следующий код перемешивает список numbers случайным образом, а затем выводит его содержимое:

    import random

    numbers = [1, 2, 3, 4, 5, 6, 7, 8]
    random.shuffle(numbers)
    print(numbers)

Результатом работы такого кода может быть:

    [4, 7, 8, 1, 2, 3, 6, 5]

# choice()

Метод choice() принимает список (строку, кортеж) в качестве обязательного аргумента и возвращает один случайный элемент.

Следующий код выводит по одному случайному элементу из строки 'BEEGEEK', списка [1, 2, 3, 4] и кортежа  ('a', 'b', 'c', 'd'):

    import random

    print(random.choice('BEEGEEK'))
    print(random.choice([1, 2, 3, 4]))
    print(random.choice(('a', 'b', 'c', 'd')))

Результатом работы такого кода может быть:

    E
    3
    c

# sample()

Метод sample() принимает два обязательных аргумента: первый – список (строка, кортеж, множество), второй – количество случайных элементов. Возвращает список из указанного количества уникальных (имеющих разные индексы) случайных элементов.

Результатом работы кода:

    import random
    
    numbers = [2, 5, 8, 9, 12]

    print(random.sample(numbers, 1))
    print(random.sample(numbers, 2))
    print(random.sample(numbers, 3))
    print(random.sample(numbers, 5))

может быть:

    [9]
    [12, 5]
    [9, 2, 8]
    [12, 8, 9, 5, 2]

Количество случайных элементов не должно превышать длину исходного списка (строки). Следующий код:

    import random
    
    numbers = [2, 5, 8, 9, 12]

    print(random.sample(numbers, 6))

приведет к ошибке:

    ValueError: Sample larger than population or is negative

# string

Встроенный модуль string раньше использовался для расширения стандартных возможностей (функционала) строкового типа данных str. На текущий момент все функции из модуля string переехали в методы строкового типа данных str, однако в модуле string остались удобные константные строки, которые можно использовать при решении задач.

Приведенный ниже код:

    import string

    print(string.ascii_letters)
    print(string.ascii_uppercase)
    print(string.ascii_lowercase)
    print(string.digits)
    print(string.hexdigits)
    print(string.octdigits)
    print(string.punctuation)
    print(string.printable)

выводит:

    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
    ABCDEFGHIJKLMNOPQRSTUVWXYZ
    abcdefghijklmnopqrstuvwxyz
    0123456789
    0123456789abcdefABCDEF
    01234567
    !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
    0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ \t\n\r\x0b\x0c

## Примечания
### Примечание 1. 
Помимо рассмотренных в уроке методов, модуль random содержит много дополнительных методов. Подробнее о модуле random можно почитать в документации.

https://docs.python.org/3/library/random.html#

# 12.3 Метод Монте-Карло и Bogosort

# Метод Монте-Карло
Метод Монте-Карло – группа численных методов, основанных на воспроизведении и статистическом анализе большого числа реализаций случайного процесса. Проводится математическое моделирование случайных процессов и параметры их реализации оцениваются статистически. Метод лежит в основе статистического моделирования.

Метод Монте-Карло часто называют методом статистических испытаний.

Основоположники метода Монте-Карло

![Основоположники метода Монте-Карло](/StepikPython/Python_Generation_for_advanced/pictures/012_01.jpg)

Статистическое моделирование широко применяется для решения задач из различных областей человеческого знания - биологии, химии, физики, экономики и других. Задачи, где широко используется этот подход:

+ численное интегрирование;
+ расчеты в системах массового обслуживания;
+ расчеты качества и надежности изделий;
+ расчеты прохождения нейтронов и других частиц через вещество;
+ передача сообщений при наличии помех;
+ задачи теории игр;
+ задачи динамики разреженного газа;
+ задачи дискретной оптимизации;
+ задачи финансовой математики.

# Вычисление площадей

Применим метод Монте-Карло и к задаче вычисления площади геометрической фигуры на плоскости.

Поместим фигуру в прямоугольник и будем наугад бросать точки в этот прямоугольник. Будем исходить из того, что чем больше площадь фигуры, тем чаще в нее будут попадать точки. 

Таким образом, при большом числе n точек, наугад выбранных внутри прямоугольника, доля точек, содержащихся в данной фигуре k, приближенно равна отношению площади этой фигуры и площади прямоугольника.

Если площадь прямоугольника равна S_0 и в результате испытаний, из которых при k исходах случайные точки оказались внутри фигуры, то площадь S фигуры будет определяться выражением

    S = (k / n) * S_o

Рассмотрим алгоритм решения задачи на конкретных примерах.

## Пример 1. 
Рассмотрим фигуру, множество точек которой определяется следующей системой неравенств:

![Пример1](/StepikPython/Python_Generation_for_advanced/pictures/012_02.JPG)

Алгоритм Монте-Карло: площадь искомой фигуры составляет часть квадрата со сторонами 11. Площадь такого квадрата равна 1.

Генерируем случайные числа x и y равномерно распределенные на отрезке [0; 1]. 

Это будут координаты случайной точки в квадрате, в которую заключена фигура, площадь которой требуется найти. Полученная точка может как попасть в исследуемую фигуру, так и не попасть.

Проверяем принадлежность точки к исследуемой фигуре. Если попадания нет, т.е. не выполняется неравенство y ≤ x ** 2, то переходим к пункту 1 и генерируем координаты новой точки. 

Если попадание есть, то фиксируем это попадание, то есть увеличиваем на единицу значение счетчика числа попаданий и снова переходим к пункту 1.

![Монте-Карло](/StepikPython/Python_Generation_for_advanced/pictures/012_03.png)

Примечание. Заметим, что попадание случайной точки точно на границу фигуры можно отнести как к первому, так и ко второму исходу.

Пункты 1 и 2 следует повторить в цикле достаточно большое количество n раз. 

От количества повторений напрямую зависит точность результата. После проведения n повторов площадь фигуры найдем по формуле:
S = (k / n) * S_0.

Пример программы на Python:

    import random

    n = 1000
    k = 0
    s0 = 1
    for _ in range(n):
        x = random.uniform(0, 1)     # случайное число с плавающей точкой от 0 до 1
        y = random.uniform(0, 1)     # случайное число с плавающей точкой от 0 до 1

        if y <= x**2:                # если попадает в нужную область
            k += 1

    print((k/n)*s0)

Составим таблицу:

    n	        S
    10	        0.6
    100	        0.37
    1000	    0.337
    10000	    0.3337
    100000	    0.33329
    1000000	    0.333571
    10000000	0.3332828
    100000000	0.33336707

## Пример 2. 
Рассмотрим фигуру, множество точек которой определяется следующей системой неравенств:

![Пример2](/StepikPython/Python_Generation_for_advanced/pictures/012_04.PNG)

Графическое изображение указанной фигуры в плоскости xOy имеет вид:

![Пример2](/StepikPython/Python_Generation_for_advanced/pictures/012_05.PNG)

Площадь этой фигуры нам заранее известна и равна S = 8.38404.

![Пример2](/StepikPython/Python_Generation_for_advanced/pictures/012_06.PNG)

Алгоритм Монте-Карло: площадь искомой фигуры составляет часть квадрата со сторонами 4. Площадь такого квадрата равна 16.

Генерируем случайные числа x и y, равномерно распределенные на отрезках [−2; 2]. 

Это будут координаты случайных точек в квадрате, в который заключена фигура искомой площади. 

Полученная точка может как попасть в исследуемую фигуру, так и не не попасть.
Проверяем принадлежность точки к исследуемой фигуре. Если попадания нет, не выполняется хотя бы одно из  неравенств 

    y ** 3 - 2x ** 2 ≤−1 или 2 y + x ** 3 ≤ 3, 

переходим к пункту 1 и генерируем координаты новой точки. 

Если попадание есть, фиксируем это попадание, то есть увеличиваем на единицу значение счетчика числа попаданий и снова переходим к пункту 1.

    import random

    n = 1000
    k = 0
    s0 = 16
    for _ in range(n):
        x = random.uniform(-2, 2)
        y = random.uniform(-2, 2)

        if y**3 - 2*x**2 <= -1 and 2*y + x**3 <= 3:
            k += 1

    print((k/n)*s0)

Составим таблицу:

n       	S
10  	    9.6
100	        8.96
1000	    8.224
10000	    8.3824
100000	    8.36528
1000000	    8.383376
10000000	8.3841584
100000000	8.38404134

## Примечания

### Примечание 1. 

Свое экзотическое название метод получил от города Монте-Карло в княжестве Монако, известного благодаря казино, поскольку именно рулетка является одним из самых широко известных генераторов случайных чисел. Станислав Улам пишет в своей автобиографии «Приключения математика», что название было предложено Николасом Метрополисом в честь его дяди, азартного игрока.

![Монте-Карло](/StepikPython/Python_Generation_for_advanced/pictures/012_07.gif)

### Примечание 2. 
Активное применение метода началось с появлением ЭВМ, способных выполнять сотни операций для получения необходимых статистических данных. Развитие метода Монте-Карло пришлось на 1950-е годы, когда его использовали ученые из лаборатории ВВС США и исследовательской корпорации RAND, работающие над созданием водородной бомбы, в том числе и гениальный ученый Джон фон Нейман. Неймана считают одним из основателей метода, как, впрочем, и самих ЭВМ.

### Примечание 3. 
Аналогичным образом можно вычислять объемы тел в пространстве.

### Примечание 4. 
Подробнее о методе Монте-Карло можно почитать тут.
https://ru.qaz.wiki/wiki/Monte_Carlo_method

![Условие задачи](/StepikPython/Python_Generation_for_advanced/pictures/012_08.PNG)


Напишите программу, которая при помощи метода Монте-Карло определяет приближённое значение числа π.

![Условие задачи](/StepikPython/Python_Generation_for_advanced/pictures/012_09.PNG)


# Болотная сортировка

Болотная сортировка (Bogosort) — неэффективный алгоритм сортировки, используемый только в образовательных целях и противопоставляемый другим, более реалистичным алгоритмам.

Принцип работы алгоритма прост, как плесень. 

Перетряхиваем список случайным образом до тех пор пока он внезапно не отсортируется. 

Процесс может счастливо завершиться сразу, а может длиться до тепловой смерти Вселенной. Это уж как повезёт.

   Bogo sort is the fastest sort if you're very lucky.

# Время работы алгоритма

Среднее время работы алгоритма болотной сортировки на современном компьютере:

![Время сортировки](/StepikPython/Python_Generation_for_advanced/pictures/012_10.PNG)

Колода в 3232 карты будет сортироваться компьютером в среднем 2,7\cdot 10^{19}2,7⋅10 
19 лет.

# Реализация алгоритма

Для реализации алгоритма болотной сортировки будем использовать функцию shuffle(), которая случайным образом перемешивает содержимое списка.

import random

    def is_sort(nums):                   # отсортирован ли список?
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                return False
        return True

    def bogosort(nums):                  # реализация алгоритма болотной сортировки
        while not is_sort(nums):
            random.shuffle(nums)
        return nums

    numbers = list(range(10))
    random.shuffle(numbers)              # перемешиваем начальный список
    print(numbers)                       # выводим начальный список

    sorted_numbers = bogosort(numbers)

    print(sorted_numbers)                # выводим отсортированный список

